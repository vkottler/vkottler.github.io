

<!DOCTYPE html>


<html >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Struct i2c0 &#8212; hal-rp2040 1.1.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/collapsible-lists/css/tree_view.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
    <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'generated/structRP2040_1_1i2c0';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Struct io_bank0" href="structRP2040_1_1io__bank0.html" />
    <link rel="prev" title="Struct dma" href="structRP2040_1_1dma.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="None"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    <p class="title logo__title">hal-rp2040 1.1.0 documentation</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active has-children"><a class="reference internal" href="root.html">Library API</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="namespace_RP2040.html">Namespace RP2040</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1adc.html">Struct adc</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1busctrl.html">Struct busctrl</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1clocks.html">Struct clocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1dma.html">Struct dma</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Struct i2c0</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1io__bank0.html">Struct io_bank0</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1io__qspi.html">Struct io_qspi</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1pads__bank0.html">Struct pads_bank0</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1pads__qspi.html">Struct pads_qspi</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1pio0.html">Struct pio0</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1pll__sys.html">Struct pll_sys</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1ppb.html">Struct ppb</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1psm.html">Struct psm</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1pwm.html">Struct pwm</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1resets.html">Struct resets</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1rosc.html">Struct rosc</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1rtc.html">Struct rtc</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1sio.html">Struct sio</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1spi0.html">Struct spi0</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1syscfg.html">Struct syscfg</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1sysinfo.html">Struct sysinfo</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1tbman.html">Struct tbman</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1timer.html">Struct timer</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1uart0.html">Struct uart0</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1usbctrl__dpram.html">Struct usbctrl_dpram</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1usbctrl__regs.html">Struct usbctrl_regs</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1vreg__and__chip__reset.html">Struct vreg_and_chip_reset</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1watchdog.html">Struct watchdog</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1xip__ctrl.html">Struct xip_ctrl</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1xip__ssi.html">Struct xip_ssi</a></li>
<li class="toctree-l2"><a class="reference internal" href="structRP2040_1_1xosc.html">Struct xosc</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_BUSCTRL__PERFSEL0__PERFSEL0_8h_1ac277eefaab69ab78e6ba1fe57377f559.html">Enum BUSCTRL_PERFSEL0_PERFSEL0</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_BUSCTRL__PERFSEL1__PERFSEL1_8h_1ad0c8d47fbe04c26bdd8a1d8cc9de37c4.html">Enum BUSCTRL_PERFSEL1_PERFSEL1</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_BUSCTRL__PERFSEL2__PERFSEL2_8h_1a9ff69388eb45ea7608a874433db59268.html">Enum BUSCTRL_PERFSEL2_PERFSEL2</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_BUSCTRL__PERFSEL3__PERFSEL3_8h_1a09a48fd570e0068cf82bf87abd6aa8e5.html">Enum BUSCTRL_PERFSEL3_PERFSEL3</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_CLOCKS__CLK__ADC__CTRL__AUXSRC_8h_1a538de767e8970cc3ad10111eef4223b2.html">Enum CLOCKS_CLK_ADC_CTRL_AUXSRC</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_CLOCKS__CLK__GPOUT0__CTRL__AUXSRC_8h_1ae4c9b948e6d8e4d6b52f3dcf7f82d013.html">Enum CLOCKS_CLK_GPOUT0_CTRL_AUXSRC</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_CLOCKS__CLK__GPOUT1__CTRL__AUXSRC_8h_1ae9e37ac43e0545cc1c2304753ab4af4d.html">Enum CLOCKS_CLK_GPOUT1_CTRL_AUXSRC</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_CLOCKS__CLK__GPOUT2__CTRL__AUXSRC_8h_1aa07fd69b38b19b6e1c68c5b912c600f9.html">Enum CLOCKS_CLK_GPOUT2_CTRL_AUXSRC</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_CLOCKS__CLK__GPOUT3__CTRL__AUXSRC_8h_1a5525fdaf8fc994805cf9dfeaa9ed7594.html">Enum CLOCKS_CLK_GPOUT3_CTRL_AUXSRC</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_CLOCKS__CLK__PERI__CTRL__AUXSRC_8h_1a4e17fc805aa2734f9a7e0eb5c7da8e1f.html">Enum CLOCKS_CLK_PERI_CTRL_AUXSRC</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_CLOCKS__CLK__REF__CTRL__AUXSRC_8h_1a5d6f4ad6838e30d915c48b93b521ac40.html">Enum CLOCKS_CLK_REF_CTRL_AUXSRC</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_CLOCKS__CLK__REF__CTRL__SRC_8h_1a7077a7e0a8404fc43f9dea61815b1fff.html">Enum CLOCKS_CLK_REF_CTRL_SRC</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_CLOCKS__CLK__RTC__CTRL__AUXSRC_8h_1ad714821df0446576d8bd0920a1dc6791.html">Enum CLOCKS_CLK_RTC_CTRL_AUXSRC</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_CLOCKS__CLK__SYS__CTRL__AUXSRC_8h_1a83c373ba89043b1c9187d2dd71b6a162.html">Enum CLOCKS_CLK_SYS_CTRL_AUXSRC</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_CLOCKS__CLK__USB__CTRL__AUXSRC_8h_1af633000a50b5a3b95cab2dba3caf9373.html">Enum CLOCKS_CLK_USB_CTRL_AUXSRC</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_CLOCKS__FC0__SRC__FC0__SRC_8h_1a1edf2efccbbb67db8803dc9feb052aa0.html">Enum CLOCKS_FC0_SRC_FC0_SRC</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH0__CTRL__TRIG__DATA__SIZE_8h_1abcd2c38655b2d10b6713c21a45665bc4.html">Enum DMA_CH0_CTRL_TRIG_DATA_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH0__CTRL__TRIG__RING__SIZE_8h_1abed3344cdd2bd3a9b2f9ed4fe83e4ef1.html">Enum DMA_CH0_CTRL_TRIG_RING_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH0__CTRL__TRIG__TREQ__SEL_8h_1a81d4e7d340b07b4ae3edb29eac6fcebc.html">Enum DMA_CH0_CTRL_TRIG_TREQ_SEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH10__CTRL__TRIG__DATA__SIZE_8h_1ab6970a37de6743110f003ccde084ef41.html">Enum DMA_CH10_CTRL_TRIG_DATA_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH10__CTRL__TRIG__RING__SIZE_8h_1ac0437840fd55b888adcb713b9b8be21e.html">Enum DMA_CH10_CTRL_TRIG_RING_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH10__CTRL__TRIG__TREQ__SEL_8h_1a75db2e25b8b57768e6b8f48b3a5b9000.html">Enum DMA_CH10_CTRL_TRIG_TREQ_SEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH11__CTRL__TRIG__DATA__SIZE_8h_1a68b03d6cafc3bff977bae4a9e2b1b29c.html">Enum DMA_CH11_CTRL_TRIG_DATA_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH11__CTRL__TRIG__RING__SIZE_8h_1a9e29d42dc8a4cc35f8a429f26241f499.html">Enum DMA_CH11_CTRL_TRIG_RING_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH11__CTRL__TRIG__TREQ__SEL_8h_1a85f677231bdcb3b723baa1df43583551.html">Enum DMA_CH11_CTRL_TRIG_TREQ_SEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH1__CTRL__TRIG__DATA__SIZE_8h_1a43ce52026dc818883f6102b31b814419.html">Enum DMA_CH1_CTRL_TRIG_DATA_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH1__CTRL__TRIG__RING__SIZE_8h_1a81876d1c59561ef2cf4d3fa1ef62d999.html">Enum DMA_CH1_CTRL_TRIG_RING_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH1__CTRL__TRIG__TREQ__SEL_8h_1a42624920161a413f0191bfd1da298da3.html">Enum DMA_CH1_CTRL_TRIG_TREQ_SEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH2__CTRL__TRIG__DATA__SIZE_8h_1a5dec9993c910044bf8675243b3056288.html">Enum DMA_CH2_CTRL_TRIG_DATA_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH2__CTRL__TRIG__RING__SIZE_8h_1ab2ddcf7bce7788fa492eac9aebb8e63f.html">Enum DMA_CH2_CTRL_TRIG_RING_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH2__CTRL__TRIG__TREQ__SEL_8h_1a7abfbff6ae17016cc265322b9a161edc.html">Enum DMA_CH2_CTRL_TRIG_TREQ_SEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH3__CTRL__TRIG__DATA__SIZE_8h_1a8a4b438d6032955bf933d6c8a9dfb331.html">Enum DMA_CH3_CTRL_TRIG_DATA_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH3__CTRL__TRIG__RING__SIZE_8h_1ad06ede27a7e07b11e46cca676ac6da8a.html">Enum DMA_CH3_CTRL_TRIG_RING_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH3__CTRL__TRIG__TREQ__SEL_8h_1a7c5c31c150f2e1a8db89ed8d48600302.html">Enum DMA_CH3_CTRL_TRIG_TREQ_SEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH4__CTRL__TRIG__DATA__SIZE_8h_1a893e3e85d8c65973d1d25d63011b94a9.html">Enum DMA_CH4_CTRL_TRIG_DATA_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH4__CTRL__TRIG__RING__SIZE_8h_1a20841ee4c6a0b6ddb51481e03f7988bd.html">Enum DMA_CH4_CTRL_TRIG_RING_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH4__CTRL__TRIG__TREQ__SEL_8h_1af070eed24ca2f85c7f9bd7bf97a127cd.html">Enum DMA_CH4_CTRL_TRIG_TREQ_SEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH5__CTRL__TRIG__DATA__SIZE_8h_1a6e042ad3e07b132edcc1b5a42408cb69.html">Enum DMA_CH5_CTRL_TRIG_DATA_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH5__CTRL__TRIG__RING__SIZE_8h_1a1300a1bce8bc162d64bdc8c321530fe2.html">Enum DMA_CH5_CTRL_TRIG_RING_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH5__CTRL__TRIG__TREQ__SEL_8h_1a3a3a6dcc7be92e158ba6ed22706f99da.html">Enum DMA_CH5_CTRL_TRIG_TREQ_SEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH6__CTRL__TRIG__DATA__SIZE_8h_1a8370dabcc3377e67abfa3c6d83f2f2e1.html">Enum DMA_CH6_CTRL_TRIG_DATA_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH6__CTRL__TRIG__RING__SIZE_8h_1ac9827adef8f58cb02021c249c228524f.html">Enum DMA_CH6_CTRL_TRIG_RING_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH6__CTRL__TRIG__TREQ__SEL_8h_1a864f4bb8fc881432e53859b3992aa398.html">Enum DMA_CH6_CTRL_TRIG_TREQ_SEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH7__CTRL__TRIG__DATA__SIZE_8h_1a46c95af2ae6b1f8cd4b93ad184bc3274.html">Enum DMA_CH7_CTRL_TRIG_DATA_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH7__CTRL__TRIG__RING__SIZE_8h_1ab09a47766ada820df660f8f5a0ac8528.html">Enum DMA_CH7_CTRL_TRIG_RING_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH7__CTRL__TRIG__TREQ__SEL_8h_1a8f9cc967d8480b04127dda4266eed2cd.html">Enum DMA_CH7_CTRL_TRIG_TREQ_SEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH8__CTRL__TRIG__DATA__SIZE_8h_1a03e3ede494cfd452a5cce927ebaf624e.html">Enum DMA_CH8_CTRL_TRIG_DATA_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH8__CTRL__TRIG__RING__SIZE_8h_1ab296b22156b4ba74d6219f55735ff61e.html">Enum DMA_CH8_CTRL_TRIG_RING_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH8__CTRL__TRIG__TREQ__SEL_8h_1ad02be1ce0d9f83dfd9b8e775af814145.html">Enum DMA_CH8_CTRL_TRIG_TREQ_SEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH9__CTRL__TRIG__DATA__SIZE_8h_1af0ab19fd5b65e274b9c4316780e61d89.html">Enum DMA_CH9_CTRL_TRIG_DATA_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH9__CTRL__TRIG__RING__SIZE_8h_1a13251b48b56d7c9cbc28eba9ebbaec7a.html">Enum DMA_CH9_CTRL_TRIG_RING_SIZE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__CH9__CTRL__TRIG__TREQ__SEL_8h_1af4549c92109768d8673dceb4818713cd.html">Enum DMA_CH9_CTRL_TRIG_TREQ_SEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_DMA__SNIFF__CTRL__CALC_8h_1a2b87e13ee6e074361427558978fcae02.html">Enum DMA_SNIFF_CTRL_CALC</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_I2C0__IC__CON__SPEED_8h_1a6c7a1393cd969e5ac462e886b2102f60.html">Enum I2C0_IC_CON_SPEED</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO0__CTRL__FUNCSEL_8h_1a3d4278c93b49f13295ac35371a510d5c.html">Enum IO_BANK0_GPIO0_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO0__CTRL__INOVER_8h_1ad2001e7940019429755ebcdbc1830f9c.html">Enum IO_BANK0_GPIO0_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO0__CTRL__IRQOVER_8h_1a3809b3e0017ebe4c626ae0c0769b5343.html">Enum IO_BANK0_GPIO0_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO0__CTRL__OEOVER_8h_1a7a66be67e0cdcb7aee5a378ce08ab541.html">Enum IO_BANK0_GPIO0_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO0__CTRL__OUTOVER_8h_1abc98ca8853de02909a0d09fb48d27d26.html">Enum IO_BANK0_GPIO0_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO10__CTRL__FUNCSEL_8h_1a6a4d818de589e74c4c92a823ee68712e.html">Enum IO_BANK0_GPIO10_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO10__CTRL__INOVER_8h_1a83f6a45345a9ab6a358579508b429d91.html">Enum IO_BANK0_GPIO10_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO10__CTRL__IRQOVER_8h_1acd7ff9762cb8a1d915b503d48b8bb021.html">Enum IO_BANK0_GPIO10_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO10__CTRL__OEOVER_8h_1a5dafcfb54e46936988fc3e2df028d653.html">Enum IO_BANK0_GPIO10_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO10__CTRL__OUTOVER_8h_1aaf910f7468e3c30dbebf7f1097ed167a.html">Enum IO_BANK0_GPIO10_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO11__CTRL__FUNCSEL_8h_1abe4366386deac65e998c77cd57f337af.html">Enum IO_BANK0_GPIO11_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO11__CTRL__INOVER_8h_1a276b82e0d93fab09295914afa8b877e8.html">Enum IO_BANK0_GPIO11_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO11__CTRL__IRQOVER_8h_1a2664e82ad5090f45a39af419f6129062.html">Enum IO_BANK0_GPIO11_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO11__CTRL__OEOVER_8h_1afceb10400b7461565f6bc9ef313d1a3e.html">Enum IO_BANK0_GPIO11_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO11__CTRL__OUTOVER_8h_1a2537bcdfbdbe83e2c82e624ca145eee4.html">Enum IO_BANK0_GPIO11_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO12__CTRL__FUNCSEL_8h_1a7f80eaf17f92dcd1ee469c55a63d044c.html">Enum IO_BANK0_GPIO12_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO12__CTRL__INOVER_8h_1ae34ad1092e358616326bde3a51c7c0e3.html">Enum IO_BANK0_GPIO12_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO12__CTRL__IRQOVER_8h_1acd318002096edfc1c84cb953618f81ae.html">Enum IO_BANK0_GPIO12_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO12__CTRL__OEOVER_8h_1a4a6c2dc8a849dbd7dda20b007623478f.html">Enum IO_BANK0_GPIO12_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO12__CTRL__OUTOVER_8h_1ad2bb371be2adc2db9ee74e7d5976c988.html">Enum IO_BANK0_GPIO12_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO13__CTRL__FUNCSEL_8h_1a6a8791758b8ac00bb394f6edfe48c1ad.html">Enum IO_BANK0_GPIO13_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO13__CTRL__INOVER_8h_1a4c9a4d81bb8c2bb2fd15e4561abc837e.html">Enum IO_BANK0_GPIO13_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO13__CTRL__IRQOVER_8h_1a0a64e22a366ea85182d05b8a19d9293f.html">Enum IO_BANK0_GPIO13_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO13__CTRL__OEOVER_8h_1a711f277ae32cce8bde7c456d6f605717.html">Enum IO_BANK0_GPIO13_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO13__CTRL__OUTOVER_8h_1a07946c02ee9d950a7ef2eed105c4fad1.html">Enum IO_BANK0_GPIO13_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO14__CTRL__FUNCSEL_8h_1aba678c0eb58513f27d9dda0d331024a8.html">Enum IO_BANK0_GPIO14_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO14__CTRL__INOVER_8h_1ac1fadd637ce703f312a3f2c2d0b330f7.html">Enum IO_BANK0_GPIO14_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO14__CTRL__IRQOVER_8h_1ad140339f697dad441d989f284f76bdd3.html">Enum IO_BANK0_GPIO14_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO14__CTRL__OEOVER_8h_1adbd65881009a4c8032fbeb0488fecf1f.html">Enum IO_BANK0_GPIO14_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO14__CTRL__OUTOVER_8h_1ae05fbe7b056474f5f2b2cace1808bcf4.html">Enum IO_BANK0_GPIO14_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO15__CTRL__FUNCSEL_8h_1a360f1bcf37319c22c4178caefff6e398.html">Enum IO_BANK0_GPIO15_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO15__CTRL__INOVER_8h_1ad7d92d9799388aa471c46dfce6bc6bc5.html">Enum IO_BANK0_GPIO15_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO15__CTRL__IRQOVER_8h_1a31a52cf169596b2414de7d89160da360.html">Enum IO_BANK0_GPIO15_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO15__CTRL__OEOVER_8h_1a9a9f4efd6e16805548b93ce96ca6af60.html">Enum IO_BANK0_GPIO15_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO15__CTRL__OUTOVER_8h_1add2dd686fb8a3e8f69535beca7ec20e1.html">Enum IO_BANK0_GPIO15_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO16__CTRL__FUNCSEL_8h_1a50ae43c16b567ebacdd7fff4706650cc.html">Enum IO_BANK0_GPIO16_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO16__CTRL__INOVER_8h_1aa16ac58c8c01e7d9657a00f71c696ccd.html">Enum IO_BANK0_GPIO16_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO16__CTRL__IRQOVER_8h_1a00a7623006470174b45a1fcdc8e0d445.html">Enum IO_BANK0_GPIO16_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO16__CTRL__OEOVER_8h_1aa85ef4ed68f06e22228756114901b3f1.html">Enum IO_BANK0_GPIO16_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO16__CTRL__OUTOVER_8h_1af4f0ff9665d06239f0ca619bad384fa6.html">Enum IO_BANK0_GPIO16_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO17__CTRL__FUNCSEL_8h_1a5cfcb81e0907bb18068ac3d6901ee143.html">Enum IO_BANK0_GPIO17_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO17__CTRL__INOVER_8h_1a369daf50bef0770c247d0ec119ce2f91.html">Enum IO_BANK0_GPIO17_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO17__CTRL__IRQOVER_8h_1a1ff56842823cdb11166771fe650cd7d6.html">Enum IO_BANK0_GPIO17_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO17__CTRL__OEOVER_8h_1a15d3eec64fc240f201786526ba9c1f8d.html">Enum IO_BANK0_GPIO17_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO17__CTRL__OUTOVER_8h_1accee5b638e4d1233b07eb4830260a63f.html">Enum IO_BANK0_GPIO17_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO18__CTRL__FUNCSEL_8h_1a3cc422ab9315025cfe3ff536650d9456.html">Enum IO_BANK0_GPIO18_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO18__CTRL__INOVER_8h_1a7bd5e2d71d0644a810471ee26f2be022.html">Enum IO_BANK0_GPIO18_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO18__CTRL__IRQOVER_8h_1a04a009e793167851088b1ba19c6a6d45.html">Enum IO_BANK0_GPIO18_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO18__CTRL__OEOVER_8h_1aaf02a8993999cff970f0a20eff6c96a7.html">Enum IO_BANK0_GPIO18_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO18__CTRL__OUTOVER_8h_1a81a7337ae6bc9801b75879f97cfd97b2.html">Enum IO_BANK0_GPIO18_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO19__CTRL__FUNCSEL_8h_1a968a858d991b97e3e44070a9267965c3.html">Enum IO_BANK0_GPIO19_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO19__CTRL__INOVER_8h_1a8a873d811ff0af54a1c4539d8c702273.html">Enum IO_BANK0_GPIO19_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO19__CTRL__IRQOVER_8h_1ae8f0d1947ad1e0b9a244607136b9e52d.html">Enum IO_BANK0_GPIO19_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO19__CTRL__OEOVER_8h_1ad2afbf2aeef8e0666429dc5d64830ee6.html">Enum IO_BANK0_GPIO19_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO19__CTRL__OUTOVER_8h_1a3796c1be9fa20e3c47d335acbf5a218e.html">Enum IO_BANK0_GPIO19_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO1__CTRL__FUNCSEL_8h_1ad6941d1c8b8a5257010a0e6559d540de.html">Enum IO_BANK0_GPIO1_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO1__CTRL__INOVER_8h_1a297d16ca3bb5bba638b9d8d9c28da5a4.html">Enum IO_BANK0_GPIO1_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO1__CTRL__IRQOVER_8h_1ae50513db7ee24214651d7022e8141c59.html">Enum IO_BANK0_GPIO1_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO1__CTRL__OEOVER_8h_1a6696e3b92617611e9587c5b2478b23ec.html">Enum IO_BANK0_GPIO1_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO1__CTRL__OUTOVER_8h_1a2848c4c9f3adf771cce337b7a9b0899b.html">Enum IO_BANK0_GPIO1_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO20__CTRL__FUNCSEL_8h_1ad7daf682631529cb9b2a5f62368c02ad.html">Enum IO_BANK0_GPIO20_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO20__CTRL__INOVER_8h_1af0689e2fbad80afc8af54b1df61f2fd6.html">Enum IO_BANK0_GPIO20_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO20__CTRL__IRQOVER_8h_1a36b8052ede4a54d7f77e5e9b6b8711db.html">Enum IO_BANK0_GPIO20_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO20__CTRL__OEOVER_8h_1a0511273256f591b65585c78dc5c5c151.html">Enum IO_BANK0_GPIO20_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO20__CTRL__OUTOVER_8h_1a80c20bf4794b64f99e03c61edfedbff3.html">Enum IO_BANK0_GPIO20_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO21__CTRL__FUNCSEL_8h_1a04b045c28c3ac31336f40c684361e3cf.html">Enum IO_BANK0_GPIO21_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO21__CTRL__INOVER_8h_1a93dc4657c590448c5fc59d541b9ec71e.html">Enum IO_BANK0_GPIO21_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO21__CTRL__IRQOVER_8h_1adc2ce444e3309e79008ee98edfda51f0.html">Enum IO_BANK0_GPIO21_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO21__CTRL__OEOVER_8h_1a49b7acc8d1c45a867fb6889a14d85f37.html">Enum IO_BANK0_GPIO21_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO21__CTRL__OUTOVER_8h_1a87dcb6161abcf5765ad283218bac9289.html">Enum IO_BANK0_GPIO21_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO22__CTRL__FUNCSEL_8h_1a6e7950fd703eda82bf45b97a8a60e013.html">Enum IO_BANK0_GPIO22_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO22__CTRL__INOVER_8h_1a824c5308b767d16798654d7aa31f7abb.html">Enum IO_BANK0_GPIO22_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO22__CTRL__IRQOVER_8h_1a9683f5ad085a096ad2212b5cc43d1a41.html">Enum IO_BANK0_GPIO22_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO22__CTRL__OEOVER_8h_1a9118b2026ff677029ce68e8f761d4815.html">Enum IO_BANK0_GPIO22_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO22__CTRL__OUTOVER_8h_1a3c3cfd08805e22842cd0c091c411a7f6.html">Enum IO_BANK0_GPIO22_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO23__CTRL__FUNCSEL_8h_1a973770b8c0c2b8aea3cfa33fed9a196b.html">Enum IO_BANK0_GPIO23_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO23__CTRL__INOVER_8h_1a3460a4f516f51fe261dff2e153b5dbe0.html">Enum IO_BANK0_GPIO23_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO23__CTRL__IRQOVER_8h_1acd15321a39c21fa73aa997711e3b1c8a.html">Enum IO_BANK0_GPIO23_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO23__CTRL__OEOVER_8h_1a9923394795fe2b901c3f55980e012c31.html">Enum IO_BANK0_GPIO23_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO23__CTRL__OUTOVER_8h_1ab79e76278fd561a128c3f443404ee359.html">Enum IO_BANK0_GPIO23_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO24__CTRL__FUNCSEL_8h_1a3b20e58d96a9fc12a6ba9db804cd3c76.html">Enum IO_BANK0_GPIO24_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO24__CTRL__INOVER_8h_1a3e36619ca2e106dae915d60984e4b1c1.html">Enum IO_BANK0_GPIO24_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO24__CTRL__IRQOVER_8h_1ae8501d894988300cb362243641850546.html">Enum IO_BANK0_GPIO24_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO24__CTRL__OEOVER_8h_1a2c1f7ef1a80b92967ee8e03945d8c4be.html">Enum IO_BANK0_GPIO24_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO24__CTRL__OUTOVER_8h_1af7c37b523d86ae2f5dd24af46eb2ab81.html">Enum IO_BANK0_GPIO24_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO25__CTRL__FUNCSEL_8h_1a3e9ba339e52924094a179ab2110c4e83.html">Enum IO_BANK0_GPIO25_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO25__CTRL__INOVER_8h_1ac46e1e78fda83f5299252130cb365c5d.html">Enum IO_BANK0_GPIO25_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO25__CTRL__IRQOVER_8h_1a7b3d418357ad155ce7340007c8648653.html">Enum IO_BANK0_GPIO25_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO25__CTRL__OEOVER_8h_1ad1dcdd7291a851208a938ee3cb4ab554.html">Enum IO_BANK0_GPIO25_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO25__CTRL__OUTOVER_8h_1ad140b83b3453f7895adc78e4c00ca0ed.html">Enum IO_BANK0_GPIO25_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO26__CTRL__FUNCSEL_8h_1a7392c219c9e49e71195de77b47a49255.html">Enum IO_BANK0_GPIO26_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO26__CTRL__INOVER_8h_1a0d10c5494ca44ca46a7891bf1b26dead.html">Enum IO_BANK0_GPIO26_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO26__CTRL__IRQOVER_8h_1a00f8d90b2ea2a949e806ec101384a811.html">Enum IO_BANK0_GPIO26_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO26__CTRL__OEOVER_8h_1ade9dc19b767752dd3b80829619d8e027.html">Enum IO_BANK0_GPIO26_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO26__CTRL__OUTOVER_8h_1a69956f4a7fbf9497b4365a6ba6323ba7.html">Enum IO_BANK0_GPIO26_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO27__CTRL__FUNCSEL_8h_1a5b523495112c56f1f4536f2467d4c013.html">Enum IO_BANK0_GPIO27_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO27__CTRL__INOVER_8h_1a12b2d4e8a220a55800161c48042139a6.html">Enum IO_BANK0_GPIO27_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO27__CTRL__IRQOVER_8h_1af8d088bb225124e2809ed4789cabdfb4.html">Enum IO_BANK0_GPIO27_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO27__CTRL__OEOVER_8h_1a16b815c90da3342c9781d54602620f26.html">Enum IO_BANK0_GPIO27_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO27__CTRL__OUTOVER_8h_1a5bf74731914f9ad8fe121316843887e3.html">Enum IO_BANK0_GPIO27_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO28__CTRL__FUNCSEL_8h_1a6457bf0e33b761cd77d28f3cdd22b8bf.html">Enum IO_BANK0_GPIO28_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO28__CTRL__INOVER_8h_1a677362a6be72c8b780a7c2cc95452595.html">Enum IO_BANK0_GPIO28_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO28__CTRL__IRQOVER_8h_1a955fa42175f0eb85cff15ef695b15e0c.html">Enum IO_BANK0_GPIO28_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO28__CTRL__OEOVER_8h_1adee129654d763a5f9644e25219576fef.html">Enum IO_BANK0_GPIO28_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO28__CTRL__OUTOVER_8h_1a3fea211dfa27b25b3b83225acc8badb6.html">Enum IO_BANK0_GPIO28_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO29__CTRL__FUNCSEL_8h_1a829622bcaf6a1bd1f543e532f4f85c42.html">Enum IO_BANK0_GPIO29_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO29__CTRL__INOVER_8h_1a25286cf16141dd3668d1b8cdaf76496d.html">Enum IO_BANK0_GPIO29_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO29__CTRL__IRQOVER_8h_1a30482c7394aef70abdd63050e15251fb.html">Enum IO_BANK0_GPIO29_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO29__CTRL__OEOVER_8h_1a3d2f151c010a676cec6db6236c86958f.html">Enum IO_BANK0_GPIO29_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO29__CTRL__OUTOVER_8h_1a00b2df9e1dbabbcaab508a7a08ae204d.html">Enum IO_BANK0_GPIO29_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO2__CTRL__FUNCSEL_8h_1a8276f1fe90f348b3a2324792fba4049a.html">Enum IO_BANK0_GPIO2_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO2__CTRL__INOVER_8h_1ac53cde862e17d40c46c9667a875cbaaa.html">Enum IO_BANK0_GPIO2_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO2__CTRL__IRQOVER_8h_1a67b53dd4dd914329008d78d5a4268078.html">Enum IO_BANK0_GPIO2_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO2__CTRL__OEOVER_8h_1ac47e0c7a7a23b0973a6c44a00aa8d154.html">Enum IO_BANK0_GPIO2_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO2__CTRL__OUTOVER_8h_1a427ce7c2851f0252f9a7f716b524212c.html">Enum IO_BANK0_GPIO2_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO3__CTRL__FUNCSEL_8h_1a67f025096ac0a27733ee1b8cee8d5c16.html">Enum IO_BANK0_GPIO3_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO3__CTRL__INOVER_8h_1af8be8e434600ded1fff9e95488806bec.html">Enum IO_BANK0_GPIO3_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO3__CTRL__IRQOVER_8h_1a820da50737f5766c44b0f89175bfeadb.html">Enum IO_BANK0_GPIO3_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO3__CTRL__OEOVER_8h_1a482bcedfdf3cd25772ff4dd8ce434602.html">Enum IO_BANK0_GPIO3_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO3__CTRL__OUTOVER_8h_1a3852a7d46e71472947732bbf79fc56f7.html">Enum IO_BANK0_GPIO3_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO4__CTRL__FUNCSEL_8h_1a5ce3f5d8bea2c0452679d6c1852b596c.html">Enum IO_BANK0_GPIO4_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO4__CTRL__INOVER_8h_1ade00ab3ec21cfd07ea43ef8cb611ea40.html">Enum IO_BANK0_GPIO4_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO4__CTRL__IRQOVER_8h_1ad62613208b3df5f8f392515a0ae3db36.html">Enum IO_BANK0_GPIO4_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO4__CTRL__OEOVER_8h_1ac60cf732b298079c5bff513d2980c627.html">Enum IO_BANK0_GPIO4_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO4__CTRL__OUTOVER_8h_1ac2dcebb1c8882abececa0e50276a8b2c.html">Enum IO_BANK0_GPIO4_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO5__CTRL__FUNCSEL_8h_1af02fa967c0b4bb628de273fdb1b04d01.html">Enum IO_BANK0_GPIO5_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO5__CTRL__INOVER_8h_1a772bf542588b8349ea7c0b1bda1bb016.html">Enum IO_BANK0_GPIO5_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO5__CTRL__IRQOVER_8h_1a1d8041d8005a6cdc66e88e29271248b4.html">Enum IO_BANK0_GPIO5_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO5__CTRL__OEOVER_8h_1a6c39d635af3a4e3582c42487c1445552.html">Enum IO_BANK0_GPIO5_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO5__CTRL__OUTOVER_8h_1a3ec863060ef4359a904981c621e7e040.html">Enum IO_BANK0_GPIO5_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO6__CTRL__FUNCSEL_8h_1aad2d393074bca7bf8564cfd30da7bbe6.html">Enum IO_BANK0_GPIO6_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO6__CTRL__INOVER_8h_1a3af0595633d47a36d85190558c583dbb.html">Enum IO_BANK0_GPIO6_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO6__CTRL__IRQOVER_8h_1ae8c96b0b1613e9f50e72563aafa42584.html">Enum IO_BANK0_GPIO6_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO6__CTRL__OEOVER_8h_1a3f61f535812d6402ea34dc1d37254199.html">Enum IO_BANK0_GPIO6_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO6__CTRL__OUTOVER_8h_1a30ab6a94f0db8c810d0d7bbee55db9a5.html">Enum IO_BANK0_GPIO6_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO7__CTRL__FUNCSEL_8h_1a0430610e9cec57675b54f7725445f98a.html">Enum IO_BANK0_GPIO7_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO7__CTRL__INOVER_8h_1a6d9906dc294588fa18410f082494db2b.html">Enum IO_BANK0_GPIO7_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO7__CTRL__IRQOVER_8h_1a03f1affdce299c981a0b1f83f90e0424.html">Enum IO_BANK0_GPIO7_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO7__CTRL__OEOVER_8h_1a5a0863e6446f795903f0e124932e3c50.html">Enum IO_BANK0_GPIO7_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO7__CTRL__OUTOVER_8h_1a7fd49f8e11171e8a06f4fba1d25cc019.html">Enum IO_BANK0_GPIO7_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO8__CTRL__FUNCSEL_8h_1a4614cc16669c8c64895f47baa1b1306b.html">Enum IO_BANK0_GPIO8_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO8__CTRL__INOVER_8h_1a892d08c5480f9e3c5f9bb7433a4af875.html">Enum IO_BANK0_GPIO8_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO8__CTRL__IRQOVER_8h_1a51dcfea055ea049a672ecd075b7f753d.html">Enum IO_BANK0_GPIO8_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO8__CTRL__OEOVER_8h_1affefe34b27c6ecac3813fbe88e3867c8.html">Enum IO_BANK0_GPIO8_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO8__CTRL__OUTOVER_8h_1abc75d245865e182857ccf54d4b3894e2.html">Enum IO_BANK0_GPIO8_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO9__CTRL__FUNCSEL_8h_1a1ef80260ca08df782c5bbd3b538aa239.html">Enum IO_BANK0_GPIO9_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO9__CTRL__INOVER_8h_1a059fcd1827789770a7659ac7e580735e.html">Enum IO_BANK0_GPIO9_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO9__CTRL__IRQOVER_8h_1ab49b61c0f9bac01bfe14f5c2a04400c2.html">Enum IO_BANK0_GPIO9_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO9__CTRL__OEOVER_8h_1afb8d26d873d79350a29a5443fe3d258b.html">Enum IO_BANK0_GPIO9_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__BANK0__GPIO9__CTRL__OUTOVER_8h_1a05bd9819707349cde109979765b674b9.html">Enum IO_BANK0_GPIO9_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SCLK__CTRL__FUNCSEL_8h_1a9366559bcaa8d352a269824bf2d2205f.html">Enum IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SCLK__CTRL__INOVER_8h_1a043503d88798e4194caae09fc3c9e8b0.html">Enum IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SCLK__CTRL__IRQOVER_8h_1a3edbc3cd36d339c5433412e0701e68a6.html">Enum IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SCLK__CTRL__OEOVER_8h_1a3b68c07e2a248be4ddef394207aca151.html">Enum IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SCLK__CTRL__OUTOVER_8h_1a6a9c7d527a98e8327c2b039547f32926.html">Enum IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD0__CTRL__FUNCSEL_8h_1a5792251adfb1c111493249eeee7c20a5.html">Enum IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD0__CTRL__INOVER_8h_1a9d799c9bc9569aa784191d779b333ad9.html">Enum IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD0__CTRL__IRQOVER_8h_1a481fde51effda5a029571eeb4f428c4e.html">Enum IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD0__CTRL__OEOVER_8h_1afdf0ad72872a89814639c7317f86c61e.html">Enum IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD0__CTRL__OUTOVER_8h_1a2ce74cda7d367c1259847f26e43c6de2.html">Enum IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD1__CTRL__FUNCSEL_8h_1a03fd6a0102916a744ab4105f4fee5f54.html">Enum IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD1__CTRL__INOVER_8h_1ab1e4e381a77bb90d8dd511999216d636.html">Enum IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD1__CTRL__IRQOVER_8h_1a2d0d455c989c7cec7e333a3ed0e6da70.html">Enum IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD1__CTRL__OEOVER_8h_1ab820040d487f67a318833dd2491bcd6a.html">Enum IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD1__CTRL__OUTOVER_8h_1a7278d36bbdeeb895e9e0eac5afb239b0.html">Enum IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD2__CTRL__FUNCSEL_8h_1a90a32833c8412bf171ef47964f64c892.html">Enum IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD2__CTRL__INOVER_8h_1a94ecd6334647d6fb0256db664c445912.html">Enum IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD2__CTRL__IRQOVER_8h_1a4646fafbe2a2764733bc4ac41df22c8e.html">Enum IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD2__CTRL__OEOVER_8h_1a07dbca45aa40621d0872caeb9dfcbca3.html">Enum IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD2__CTRL__OUTOVER_8h_1ae9dc63d2cec6fe9b8d80bbd874656b64.html">Enum IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD3__CTRL__FUNCSEL_8h_1a8ba4b186e35131ec11eae4b6642a4ed0.html">Enum IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD3__CTRL__INOVER_8h_1a0dca829ad1402d86c98afe59b377939e.html">Enum IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD3__CTRL__IRQOVER_8h_1a89c9747098c3d9e765e35ca37d58e31e.html">Enum IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD3__CTRL__OEOVER_8h_1ade442326473a9d7a81d9dba5c263663a.html">Enum IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SD3__CTRL__OUTOVER_8h_1a7171924886d6ea7c22c8f5061c5fcb84.html">Enum IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SS__CTRL__FUNCSEL_8h_1aabde7b66ee51755f396a39b7dab72971.html">Enum IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SS__CTRL__INOVER_8h_1a56c049a0335382748ecfa0d6c19ef1f2.html">Enum IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SS__CTRL__IRQOVER_8h_1a93d8938bc9aebe4c4d9e2596dd9a3c00.html">Enum IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SS__CTRL__OEOVER_8h_1aa53b1bdf7e6fc3fd4f12769c6444ad20.html">Enum IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_IO__QSPI__GPIO__QSPI__SS__CTRL__OUTOVER_8h_1ac7f684ed5607c8df090cf8a63e24e50d.html">Enum IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO0__DRIVE_8h_1a70465de5ebaf2c32a2e94ed3109e2d63.html">Enum PADS_BANK0_GPIO0_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO10__DRIVE_8h_1a419c869dd0c66777d1f9f48ddca44c3e.html">Enum PADS_BANK0_GPIO10_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO11__DRIVE_8h_1a16d5ec91757a8c4048ff244654305663.html">Enum PADS_BANK0_GPIO11_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO12__DRIVE_8h_1a0591956a2437fdf221187374ebb2e2b3.html">Enum PADS_BANK0_GPIO12_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO13__DRIVE_8h_1aa8876cdfa296247566d15497e3cb6d63.html">Enum PADS_BANK0_GPIO13_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO14__DRIVE_8h_1a73eb6397972ce0a3ca306939a6de9259.html">Enum PADS_BANK0_GPIO14_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO15__DRIVE_8h_1a9281ad3edcc6acc7645cdca9c968dc05.html">Enum PADS_BANK0_GPIO15_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO16__DRIVE_8h_1ade7955067644f739e0f4d0e8ebdb65d8.html">Enum PADS_BANK0_GPIO16_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO17__DRIVE_8h_1a4dedb895281e172e5016c54ea59cf8f8.html">Enum PADS_BANK0_GPIO17_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO18__DRIVE_8h_1a495a3222ba58c0b16c8c053f9f53a765.html">Enum PADS_BANK0_GPIO18_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO19__DRIVE_8h_1a11fe285c7c91773fda4a05e64c78ed15.html">Enum PADS_BANK0_GPIO19_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO1__DRIVE_8h_1a14dfd17fcbcb9b7c15c89a70ca2224ff.html">Enum PADS_BANK0_GPIO1_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO20__DRIVE_8h_1a28c3984e25b30bd765c47bbcea79c7e4.html">Enum PADS_BANK0_GPIO20_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO21__DRIVE_8h_1a95aa8bf4c2edeb7e0c9b689206b9c5f3.html">Enum PADS_BANK0_GPIO21_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO22__DRIVE_8h_1ada0d1231ad320848c7fafcac928ff647.html">Enum PADS_BANK0_GPIO22_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO23__DRIVE_8h_1aa68fcc6b7ffb54eaedd046fee2e70c1a.html">Enum PADS_BANK0_GPIO23_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO24__DRIVE_8h_1a023ab73641df00b024eb3a91b93a1495.html">Enum PADS_BANK0_GPIO24_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO25__DRIVE_8h_1a63ed6f118582e9d3a5114c9daaa7ffa5.html">Enum PADS_BANK0_GPIO25_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO26__DRIVE_8h_1ac29bea6a9235b241f70c3212f5abf7d5.html">Enum PADS_BANK0_GPIO26_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO27__DRIVE_8h_1ad480efcc1e0a134da7d33ae1b67faa3e.html">Enum PADS_BANK0_GPIO27_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO28__DRIVE_8h_1ab62ded465b083435637f5e033a050a5a.html">Enum PADS_BANK0_GPIO28_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO29__DRIVE_8h_1abf39ff40eb92db61b3089602e1a22a7e.html">Enum PADS_BANK0_GPIO29_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO2__DRIVE_8h_1a71611ac6772ced742b0bdc8aa4035efc.html">Enum PADS_BANK0_GPIO2_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO3__DRIVE_8h_1a2fbe6e34534273f28739e4eccccc198c.html">Enum PADS_BANK0_GPIO3_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO4__DRIVE_8h_1ad70c7d1b3ad0b5d9bd2397a939a5993a.html">Enum PADS_BANK0_GPIO4_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO5__DRIVE_8h_1ac6aeda1d7601130e6463dcdbc8115346.html">Enum PADS_BANK0_GPIO5_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO6__DRIVE_8h_1a32491598c40f159addaaa953aaea6b68.html">Enum PADS_BANK0_GPIO6_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO7__DRIVE_8h_1aff14b5860ff43eb9bc2bf5eacdb22458.html">Enum PADS_BANK0_GPIO7_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO8__DRIVE_8h_1af15906bb688aa57bd5dc38bed7bc6a89.html">Enum PADS_BANK0_GPIO8_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__GPIO9__DRIVE_8h_1ad3f2afc143853e35936d0e16493e9edc.html">Enum PADS_BANK0_GPIO9_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__SWCLK__DRIVE_8h_1a321817be0c3724a840af5e664d7f95de.html">Enum PADS_BANK0_SWCLK_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__BANK0__SWD__DRIVE_8h_1ad9afd354f7a30f8db19f9e9f6c52553f.html">Enum PADS_BANK0_SWD_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__QSPI__GPIO__QSPI__SCLK__DRIVE_8h_1a62e057bec8e78824a2142737f060ae3b.html">Enum PADS_QSPI_GPIO_QSPI_SCLK_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__QSPI__GPIO__QSPI__SD0__DRIVE_8h_1a60266233d7b2215b5c490f4d713eb8f9.html">Enum PADS_QSPI_GPIO_QSPI_SD0_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__QSPI__GPIO__QSPI__SD1__DRIVE_8h_1a121fa826dbabf375b7ab80bd33afd8b4.html">Enum PADS_QSPI_GPIO_QSPI_SD1_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__QSPI__GPIO__QSPI__SD2__DRIVE_8h_1accdda19f750ea1f918d6fa5eb0b20918.html">Enum PADS_QSPI_GPIO_QSPI_SD2_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__QSPI__GPIO__QSPI__SD3__DRIVE_8h_1a1afcf22672ce7b4f1eab2a7f307d93c1.html">Enum PADS_QSPI_GPIO_QSPI_SD3_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PADS__QSPI__GPIO__QSPI__SS__DRIVE_8h_1a9fc566857f61778d37941299287cb330.html">Enum PADS_QSPI_GPIO_QSPI_SS_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PWM__CH0__CSR__DIVMODE_8h_1a1b46b13f9686c620c9bd38fd8626a4e5.html">Enum PWM_CH0_CSR_DIVMODE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PWM__CH1__CSR__DIVMODE_8h_1a66389a4af73684679a3a363a45315396.html">Enum PWM_CH1_CSR_DIVMODE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PWM__CH2__CSR__DIVMODE_8h_1afa92a12ec839b6d7732c64415a01fa33.html">Enum PWM_CH2_CSR_DIVMODE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PWM__CH3__CSR__DIVMODE_8h_1ac78eebed2301d1ea4fd840ed8043397b.html">Enum PWM_CH3_CSR_DIVMODE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PWM__CH4__CSR__DIVMODE_8h_1a5a7119444f2f669758d3072698700d82.html">Enum PWM_CH4_CSR_DIVMODE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PWM__CH5__CSR__DIVMODE_8h_1a71e9faebf3bdc2a9f66c2b57b93520a7.html">Enum PWM_CH5_CSR_DIVMODE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PWM__CH6__CSR__DIVMODE_8h_1a7ebc437b7fa3b4e86b4c29824cbd3050.html">Enum PWM_CH6_CSR_DIVMODE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_PWM__CH7__CSR__DIVMODE_8h_1a78ef166eddfa7428658eee2e1af5adfa.html">Enum PWM_CH7_CSR_DIVMODE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_ROSC__CTRL__ENABLE_8h_1a3570faca3972fd3da6afb00bbd217276.html">Enum ROSC_CTRL_ENABLE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_ROSC__CTRL__FREQ__RANGE_8h_1a0ebff2e60693c15a35356f0ccb4bfc9e.html">Enum ROSC_CTRL_FREQ_RANGE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_ROSC__DIV__DIV_8h_1a8847629124ffea7dd3ad4141c64b74f4.html">Enum ROSC_DIV_DIV</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_ROSC__FREQA__PASSWD_8h_1a8b16f73fc898ba5e40875b284eeb0724.html">Enum ROSC_FREQA_PASSWD</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_ROSC__FREQB__PASSWD_8h_1a7685c62221caa19ef61436d63a3338ee.html">Enum ROSC_FREQB_PASSWD</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP0__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ae1dcde94a08be755836fe414b7c3895b.html">Enum USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP0__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a285cfe63af2e1e4a93496bb4d38d6078.html">Enum USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP10__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a3eed1f4dbbb9abd1bb58327f27b8f593.html">Enum USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP10__IN__CONTROL__ENDPOINT__TYPE_8h_1a3ed07d6d2209dbd3592b24f48b9b12ad.html">Enum USBCTRL_DPRAM_EP10_IN_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP10__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a82ce804943d084c0dc895d42dcd515c0.html">Enum USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP10__OUT__CONTROL__ENDPOINT__TYPE_8h_1ac2f26e08ac53a5c0302f35cb3fc99b38.html">Enum USBCTRL_DPRAM_EP10_OUT_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP11__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a4e0a6a78096106688647c98f0906cc3d.html">Enum USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP11__IN__CONTROL__ENDPOINT__TYPE_8h_1a87ffeaa5a6d1b38b4390ac1047a90450.html">Enum USBCTRL_DPRAM_EP11_IN_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP11__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a87ef599d615fefbf6b93e3ff22a23ce2.html">Enum USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP11__OUT__CONTROL__ENDPOINT__TYPE_8h_1a010124997a2fb17db530f9a35d0d4994.html">Enum USBCTRL_DPRAM_EP11_OUT_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP12__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a399320ed6bfafca2364083e98c3f49ed.html">Enum USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP12__IN__CONTROL__ENDPOINT__TYPE_8h_1ae59080b6a00b86ab24f0af820062571b.html">Enum USBCTRL_DPRAM_EP12_IN_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP12__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a3651a51d518f6906eb53eb1629fa3475.html">Enum USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP12__OUT__CONTROL__ENDPOINT__TYPE_8h_1ad8298ac0640f17a621c73cda2764ba82.html">Enum USBCTRL_DPRAM_EP12_OUT_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP13__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1aed73d62540729622430336f15926b7c1.html">Enum USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP13__IN__CONTROL__ENDPOINT__TYPE_8h_1a98480379fa9f28cb28c764ce51cef89e.html">Enum USBCTRL_DPRAM_EP13_IN_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP13__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a87bddaebf644ab3b9abc99c4f9ad1d7f.html">Enum USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP13__OUT__CONTROL__ENDPOINT__TYPE_8h_1ad88387bd1254b2921dc30a04a17f8368.html">Enum USBCTRL_DPRAM_EP13_OUT_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP14__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a80e5668b9ca0efccda9419bb6d51b618.html">Enum USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP14__IN__CONTROL__ENDPOINT__TYPE_8h_1a05200ef99eeb46112af0c1fcc8bc4a90.html">Enum USBCTRL_DPRAM_EP14_IN_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP14__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a62d939579ed4ac5d62366cf6390f2cbf.html">Enum USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP14__OUT__CONTROL__ENDPOINT__TYPE_8h_1a3938d48110119bb4ba7b975fc3486895.html">Enum USBCTRL_DPRAM_EP14_OUT_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP15__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a595bd7878cee65eaa09afeb020b8dfc3.html">Enum USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP15__IN__CONTROL__ENDPOINT__TYPE_8h_1a1427f6efb1b68ed1cd6f2ecc382af3b2.html">Enum USBCTRL_DPRAM_EP15_IN_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP15__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a156cd57e3de1f72262cef3fa9a79ce93.html">Enum USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP15__OUT__CONTROL__ENDPOINT__TYPE_8h_1a041bc356c7d327a2996d1df4e11246fa.html">Enum USBCTRL_DPRAM_EP15_OUT_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP1__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a0525fecb389be1f4049109add066939e.html">Enum USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP1__IN__CONTROL__ENDPOINT__TYPE_8h_1a1e9d2e96d61b68b2290d1a3bbabf618c.html">Enum USBCTRL_DPRAM_EP1_IN_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP1__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a7b45b5bbce51ad008b094e8cf4a8e187.html">Enum USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP1__OUT__CONTROL__ENDPOINT__TYPE_8h_1af619e7f200eab6f3ba5f634f42618cc1.html">Enum USBCTRL_DPRAM_EP1_OUT_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP2__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ae5811e6429ca627b2321e9654b63414e.html">Enum USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP2__IN__CONTROL__ENDPOINT__TYPE_8h_1acb0cd125b5aa7cc482bafee43b2aac5f.html">Enum USBCTRL_DPRAM_EP2_IN_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP2__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a91f2ab8d1128c66e6a1f133040fd65c6.html">Enum USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP2__OUT__CONTROL__ENDPOINT__TYPE_8h_1a444e0c2036385155f7cc1062126a5557.html">Enum USBCTRL_DPRAM_EP2_OUT_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP3__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a6b69bf0005c922eacd45eda6f87708a6.html">Enum USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP3__IN__CONTROL__ENDPOINT__TYPE_8h_1adaa0e041a2241eb6f0199ae9ca184dcb.html">Enum USBCTRL_DPRAM_EP3_IN_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP3__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a9d1a19d501e1fd747fa796d3ed18d58b.html">Enum USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP3__OUT__CONTROL__ENDPOINT__TYPE_8h_1af355d419587303c6a333f9527e080f1c.html">Enum USBCTRL_DPRAM_EP3_OUT_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP4__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ae60e88ef76f44627d8147432f528f292.html">Enum USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP4__IN__CONTROL__ENDPOINT__TYPE_8h_1a1bcaa1550a484f53e40b8bc5286d7740.html">Enum USBCTRL_DPRAM_EP4_IN_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP4__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1aa3a33d213186b1d7bb970fe10a128164.html">Enum USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP4__OUT__CONTROL__ENDPOINT__TYPE_8h_1aa258f536121737462732bbb1d5be746d.html">Enum USBCTRL_DPRAM_EP4_OUT_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP5__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1af01839230baa0b03652af598f1f3f8dd.html">Enum USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP5__IN__CONTROL__ENDPOINT__TYPE_8h_1afea50e7769ed98a568f4380531a6eff7.html">Enum USBCTRL_DPRAM_EP5_IN_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP5__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a77911f170e770d9fd401cd81fe5974b9.html">Enum USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP5__OUT__CONTROL__ENDPOINT__TYPE_8h_1aec8a5bd8d13101fae4680c2551a076a3.html">Enum USBCTRL_DPRAM_EP5_OUT_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP6__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a92548adf93f4bf4dfa4dc83156a40f39.html">Enum USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP6__IN__CONTROL__ENDPOINT__TYPE_8h_1a4bd33cd65be5eee5c8c4231378d9904e.html">Enum USBCTRL_DPRAM_EP6_IN_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP6__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a7b84fb2d7bae9b7d17e72ab94c709a4e.html">Enum USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP6__OUT__CONTROL__ENDPOINT__TYPE_8h_1ac3c7b5c0c093582b85749159c002ae5c.html">Enum USBCTRL_DPRAM_EP6_OUT_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP7__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1aec4c45882811117fe58aa64e86615f46.html">Enum USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP7__IN__CONTROL__ENDPOINT__TYPE_8h_1a550a0840fe29ad5663343c04c8273668.html">Enum USBCTRL_DPRAM_EP7_IN_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP7__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ac7429bddb1b1b5843aad8236e7ecd916.html">Enum USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP7__OUT__CONTROL__ENDPOINT__TYPE_8h_1a8e887c69781a08eea732cc308ef5a152.html">Enum USBCTRL_DPRAM_EP7_OUT_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP8__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a1ab50386d72b7ecee467d9fd16f8345e.html">Enum USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP8__IN__CONTROL__ENDPOINT__TYPE_8h_1a9b118bf2b2bd8d298b7b48e5fcf42aed.html">Enum USBCTRL_DPRAM_EP8_IN_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP8__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a840d50806f6ded5bdae809d19ef05956.html">Enum USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP8__OUT__CONTROL__ENDPOINT__TYPE_8h_1afdece070c85912eb1f62e7e53262a473.html">Enum USBCTRL_DPRAM_EP8_OUT_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP9__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a0e7b335ce3bd05c04291ff0d9e95e828.html">Enum USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP9__IN__CONTROL__ENDPOINT__TYPE_8h_1a00b79986be53b363190a98e90168347f.html">Enum USBCTRL_DPRAM_EP9_IN_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP9__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a6f29448b26bb5840662e2172d27d1576.html">Enum USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_USBCTRL__DPRAM__EP9__OUT__CONTROL__ENDPOINT__TYPE_8h_1a027b0a94b17ddfb47d7a5e8a0c245acc.html">Enum USBCTRL_DPRAM_EP9_OUT_CONTROL_ENDPOINT_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_XIP__SSI__CTRLR0__SPI__FRF_8h_1a5e607f6cf8b26adf8cfe17da1f39f831.html">Enum XIP_SSI_CTRLR0_SPI_FRF</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_XIP__SSI__CTRLR0__TMOD_8h_1a0a19e44e64772621a71f387c1e455435.html">Enum XIP_SSI_CTRLR0_TMOD</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_XIP__SSI__SPI__CTRLR0__INST__L_8h_1a5c55168b6c6dcfd960e404e21b7469a3.html">Enum XIP_SSI_SPI_CTRLR0_INST_L</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_XIP__SSI__SPI__CTRLR0__TRANS__TYPE_8h_1a5d1e8f22429f4624ad07ebfefaa01e88.html">Enum XIP_SSI_SPI_CTRLR0_TRANS_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_XOSC__CTRL__ENABLE_8h_1a3f8895aac6a4e34c918d67fe2f083cb9.html">Enum XOSC_CTRL_ENABLE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_XOSC__CTRL__FREQ__RANGE_8h_1a4d20b2b85550b28fff85dbab673e344b.html">Enum XOSC_CTRL_FREQ_RANGE</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_XOSC__STATUS__FREQ__RANGE_8h_1a4c0a3d6fc14dd5b6a6a4f2d6a59bbf08.html">Enum XOSC_STATUS_FREQ_RANGE</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_test__common_8cc_1a840291bc02cba5474a4cb46a9b9566fe.html">Function main</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_BUSCTRL__PERFSEL0__PERFSEL0_8h_1a4fc8349eb321cc01786807cad0f85ba0.html">Function RP2040::from_string(const char *, BUSCTRL_PERFSEL0_PERFSEL0&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_BUSCTRL__PERFSEL1__PERFSEL1_8h_1af2727dbc13a1bdb3bc53fbe37ad213b8.html">Function RP2040::from_string(const char *, BUSCTRL_PERFSEL1_PERFSEL1&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_BUSCTRL__PERFSEL2__PERFSEL2_8h_1a7c65ca51405eb557b7be857a2d52ffd7.html">Function RP2040::from_string(const char *, BUSCTRL_PERFSEL2_PERFSEL2&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_BUSCTRL__PERFSEL3__PERFSEL3_8h_1a277f7e689dc982c6408d8ddfb2687194.html">Function RP2040::from_string(const char *, BUSCTRL_PERFSEL3_PERFSEL3&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__ADC__CTRL__AUXSRC_8h_1af10c56302eb98996fe3a419b63c64875.html">Function RP2040::from_string(const char *, CLOCKS_CLK_ADC_CTRL_AUXSRC&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__GPOUT0__CTRL__AUXSRC_8h_1ada691ce965e3ed555cc570a75a3f174b.html">Function RP2040::from_string(const char *, CLOCKS_CLK_GPOUT0_CTRL_AUXSRC&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__GPOUT1__CTRL__AUXSRC_8h_1a2424d8c92523a4da93b6c3191aa353fb.html">Function RP2040::from_string(const char *, CLOCKS_CLK_GPOUT1_CTRL_AUXSRC&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__GPOUT2__CTRL__AUXSRC_8h_1a0b67863198f6a43a40e5bee978966249.html">Function RP2040::from_string(const char *, CLOCKS_CLK_GPOUT2_CTRL_AUXSRC&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__GPOUT3__CTRL__AUXSRC_8h_1abc1f2a3dd705f5d4f9547a830af3bfa0.html">Function RP2040::from_string(const char *, CLOCKS_CLK_GPOUT3_CTRL_AUXSRC&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__PERI__CTRL__AUXSRC_8h_1ad46fddfec0e3eddaca6ef8930edb791f.html">Function RP2040::from_string(const char *, CLOCKS_CLK_PERI_CTRL_AUXSRC&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__REF__CTRL__AUXSRC_8h_1a886c72abd525f917cfa62a90fcce9f63.html">Function RP2040::from_string(const char *, CLOCKS_CLK_REF_CTRL_AUXSRC&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__REF__CTRL__SRC_8h_1a7dd2f0969e47fdb394c6acbca430784e.html">Function RP2040::from_string(const char *, CLOCKS_CLK_REF_CTRL_SRC&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__RTC__CTRL__AUXSRC_8h_1ac915605f64c53317ee5e382e0dc49818.html">Function RP2040::from_string(const char *, CLOCKS_CLK_RTC_CTRL_AUXSRC&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__SYS__CTRL__AUXSRC_8h_1abbc017deefea3fa9a079ef9eb58d0471.html">Function RP2040::from_string(const char *, CLOCKS_CLK_SYS_CTRL_AUXSRC&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__USB__CTRL__AUXSRC_8h_1ae43d2aaab19cc1f79d163c6078a1f68d.html">Function RP2040::from_string(const char *, CLOCKS_CLK_USB_CTRL_AUXSRC&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__FC0__SRC__FC0__SRC_8h_1a2c783d6efc059e6873f319ebf851c337.html">Function RP2040::from_string(const char *, CLOCKS_FC0_SRC_FC0_SRC&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH0__CTRL__TRIG__DATA__SIZE_8h_1ab9b770118bef03a020915f343c588d57.html">Function RP2040::from_string(const char *, DMA_CH0_CTRL_TRIG_DATA_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH0__CTRL__TRIG__RING__SIZE_8h_1adf8199bc983d09c7334cb7d4c9f5e87c.html">Function RP2040::from_string(const char *, DMA_CH0_CTRL_TRIG_RING_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH0__CTRL__TRIG__TREQ__SEL_8h_1a3db8285fe12d5201daafa2b084c26dce.html">Function RP2040::from_string(const char *, DMA_CH0_CTRL_TRIG_TREQ_SEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH10__CTRL__TRIG__DATA__SIZE_8h_1ab3c6a54d3e18239c41177df75f42ccc6.html">Function RP2040::from_string(const char *, DMA_CH10_CTRL_TRIG_DATA_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH10__CTRL__TRIG__RING__SIZE_8h_1af094145551017d335f2f374eb6c4ca34.html">Function RP2040::from_string(const char *, DMA_CH10_CTRL_TRIG_RING_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH10__CTRL__TRIG__TREQ__SEL_8h_1a0284307cdf6c9f0baa53c7d2aec5c8a9.html">Function RP2040::from_string(const char *, DMA_CH10_CTRL_TRIG_TREQ_SEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH11__CTRL__TRIG__DATA__SIZE_8h_1a02f40f365df7c02975c4025822421a2c.html">Function RP2040::from_string(const char *, DMA_CH11_CTRL_TRIG_DATA_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH11__CTRL__TRIG__RING__SIZE_8h_1a60598e500e2c3abe2e185058e99780b0.html">Function RP2040::from_string(const char *, DMA_CH11_CTRL_TRIG_RING_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH11__CTRL__TRIG__TREQ__SEL_8h_1a1d2ef1f1e8f769a094375b51e1a1ded9.html">Function RP2040::from_string(const char *, DMA_CH11_CTRL_TRIG_TREQ_SEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH1__CTRL__TRIG__DATA__SIZE_8h_1a7d06cb942e45b8eeef8a2ad54eb3d837.html">Function RP2040::from_string(const char *, DMA_CH1_CTRL_TRIG_DATA_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH1__CTRL__TRIG__RING__SIZE_8h_1a52a89a5ab434fe02425850b254021d12.html">Function RP2040::from_string(const char *, DMA_CH1_CTRL_TRIG_RING_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH1__CTRL__TRIG__TREQ__SEL_8h_1a95a136ef134dbf7ebdd866a3be2e58fa.html">Function RP2040::from_string(const char *, DMA_CH1_CTRL_TRIG_TREQ_SEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH2__CTRL__TRIG__DATA__SIZE_8h_1a27f80cf611120447d6ff5fad6cad2c4b.html">Function RP2040::from_string(const char *, DMA_CH2_CTRL_TRIG_DATA_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH2__CTRL__TRIG__RING__SIZE_8h_1abed69fdb67d25da0dd7130b03dfdb883.html">Function RP2040::from_string(const char *, DMA_CH2_CTRL_TRIG_RING_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH2__CTRL__TRIG__TREQ__SEL_8h_1a69c9f46045dda727e9b0d0798a48a53a.html">Function RP2040::from_string(const char *, DMA_CH2_CTRL_TRIG_TREQ_SEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH3__CTRL__TRIG__DATA__SIZE_8h_1a5e4ef7bca5369e96a1d6231c855428d3.html">Function RP2040::from_string(const char *, DMA_CH3_CTRL_TRIG_DATA_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH3__CTRL__TRIG__RING__SIZE_8h_1a98bb78e697339c9685949786cc33d4a0.html">Function RP2040::from_string(const char *, DMA_CH3_CTRL_TRIG_RING_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH3__CTRL__TRIG__TREQ__SEL_8h_1aa067cc8ca26cf5a6a14fe27b67784628.html">Function RP2040::from_string(const char *, DMA_CH3_CTRL_TRIG_TREQ_SEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH4__CTRL__TRIG__DATA__SIZE_8h_1a752ac01fa4ab92d53564c5fad89e5c2e.html">Function RP2040::from_string(const char *, DMA_CH4_CTRL_TRIG_DATA_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH4__CTRL__TRIG__RING__SIZE_8h_1a5eec681f5002c3aba5abb0465e6f4f5b.html">Function RP2040::from_string(const char *, DMA_CH4_CTRL_TRIG_RING_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH4__CTRL__TRIG__TREQ__SEL_8h_1a95cad6869ee5b65e82c019afcfe10e4a.html">Function RP2040::from_string(const char *, DMA_CH4_CTRL_TRIG_TREQ_SEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH5__CTRL__TRIG__DATA__SIZE_8h_1a294fb596f5ada3c7c54e29cb885fc38c.html">Function RP2040::from_string(const char *, DMA_CH5_CTRL_TRIG_DATA_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH5__CTRL__TRIG__RING__SIZE_8h_1a83be0f2d0b970bc4a8c0683b81d1c69a.html">Function RP2040::from_string(const char *, DMA_CH5_CTRL_TRIG_RING_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH5__CTRL__TRIG__TREQ__SEL_8h_1a47a83457c345ddf67df100a65f253df2.html">Function RP2040::from_string(const char *, DMA_CH5_CTRL_TRIG_TREQ_SEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH6__CTRL__TRIG__DATA__SIZE_8h_1abc6eef47e582b78289e13c5f8c1c0dc8.html">Function RP2040::from_string(const char *, DMA_CH6_CTRL_TRIG_DATA_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH6__CTRL__TRIG__RING__SIZE_8h_1a755e4f0ba95b069ff9b6b1673ac548c3.html">Function RP2040::from_string(const char *, DMA_CH6_CTRL_TRIG_RING_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH6__CTRL__TRIG__TREQ__SEL_8h_1a196c0c4f60406cca7b963c2bffbe4164.html">Function RP2040::from_string(const char *, DMA_CH6_CTRL_TRIG_TREQ_SEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH7__CTRL__TRIG__DATA__SIZE_8h_1a152021293d1dc79324f92792cf97db52.html">Function RP2040::from_string(const char *, DMA_CH7_CTRL_TRIG_DATA_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH7__CTRL__TRIG__RING__SIZE_8h_1a062e60c72d284c0a9c779de72fec3be9.html">Function RP2040::from_string(const char *, DMA_CH7_CTRL_TRIG_RING_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH7__CTRL__TRIG__TREQ__SEL_8h_1ae8fb4c9f27aa7aad73fae3fe78344c8b.html">Function RP2040::from_string(const char *, DMA_CH7_CTRL_TRIG_TREQ_SEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH8__CTRL__TRIG__DATA__SIZE_8h_1aca2a757b703cd8e935488c77c695a838.html">Function RP2040::from_string(const char *, DMA_CH8_CTRL_TRIG_DATA_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH8__CTRL__TRIG__RING__SIZE_8h_1a9e19b692eed8a4e5d99977bb781326a6.html">Function RP2040::from_string(const char *, DMA_CH8_CTRL_TRIG_RING_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH8__CTRL__TRIG__TREQ__SEL_8h_1ae9d5a2c733dafae8dab0e42c296202f3.html">Function RP2040::from_string(const char *, DMA_CH8_CTRL_TRIG_TREQ_SEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH9__CTRL__TRIG__DATA__SIZE_8h_1ad187625e46e2ee09eb8807284e6d23ed.html">Function RP2040::from_string(const char *, DMA_CH9_CTRL_TRIG_DATA_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH9__CTRL__TRIG__RING__SIZE_8h_1ad4dbed58bdee78cce4bca6b662fc2101.html">Function RP2040::from_string(const char *, DMA_CH9_CTRL_TRIG_RING_SIZE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH9__CTRL__TRIG__TREQ__SEL_8h_1a54d25eebcd2a82e85d7eda73d30b376d.html">Function RP2040::from_string(const char *, DMA_CH9_CTRL_TRIG_TREQ_SEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__SNIFF__CTRL__CALC_8h_1aff42bdae9df90dba3cd3cde082374083.html">Function RP2040::from_string(const char *, DMA_SNIFF_CTRL_CALC&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_I2C0__IC__CON__SPEED_8h_1a9ca11ea23e1f2b907ac5ca693a91c902.html">Function RP2040::from_string(const char *, I2C0_IC_CON_SPEED&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO0__CTRL__FUNCSEL_8h_1a7e180d0cf1df3539d3624ba6e5a5ad0d.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO0_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO0__CTRL__INOVER_8h_1a0f40cc2d08439bb6994154618b41db2a.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO0_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO0__CTRL__IRQOVER_8h_1aa7a608b8d0ea0ef01a67f84d750fa07f.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO0_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO0__CTRL__OEOVER_8h_1a55a2ba9e579d18071914232a6200d7bd.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO0_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO0__CTRL__OUTOVER_8h_1aba394614f11967d772705adec965f368.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO0_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO10__CTRL__FUNCSEL_8h_1a1847f1b2e8fd5b84845bc261f1ecf3cf.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO10_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO10__CTRL__INOVER_8h_1ac1ea2e598c3c6490bf693d28af04bbf4.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO10_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO10__CTRL__IRQOVER_8h_1afabc04aaa873cd83c4b450dd9c9b2085.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO10_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO10__CTRL__OEOVER_8h_1a2607d2ac7d49df762d7ac941c0ea1c77.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO10_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO10__CTRL__OUTOVER_8h_1a88c401351a824940e25456ab0f79ed5e.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO10_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO11__CTRL__FUNCSEL_8h_1afa611baaf2c81cf0a8fc34e4d1d78180.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO11_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO11__CTRL__INOVER_8h_1a7631abce4436775e65713362d4a48e53.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO11_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO11__CTRL__IRQOVER_8h_1a9f1699240ec41da8ce77b400168cf4b3.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO11_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO11__CTRL__OEOVER_8h_1aaffd8202382624d0b85c3921ea1f3df8.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO11_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO11__CTRL__OUTOVER_8h_1a47ccb28ee9a027022c6d00a03bdd6489.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO11_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO12__CTRL__FUNCSEL_8h_1a7f671e3497749bc4d56a808fbb47346f.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO12_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO12__CTRL__INOVER_8h_1a77e841419da8dae3d5d290e28639f2a0.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO12_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO12__CTRL__IRQOVER_8h_1a20555bfab0673e70a67c48d9d9edcf57.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO12_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO12__CTRL__OEOVER_8h_1a2a4262bcadee7bc8cf6a69b1107a9c87.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO12_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO12__CTRL__OUTOVER_8h_1af5a404e8a5536471c7d98296f4a788ac.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO12_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO13__CTRL__FUNCSEL_8h_1a047554dcb7c9567824d682eeaadf099d.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO13_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO13__CTRL__INOVER_8h_1adfff630d764bcc40d465ed28cd20d8f8.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO13_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO13__CTRL__IRQOVER_8h_1a7b408b83ebbbbdb3997f7389acf79efc.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO13_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO13__CTRL__OEOVER_8h_1a1307c60fa238580c2266facd8c08c31e.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO13_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO13__CTRL__OUTOVER_8h_1a06c252200a64ff376d394a4344210159.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO13_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO14__CTRL__FUNCSEL_8h_1a7331134a671c3681dd885781d65f903a.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO14_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO14__CTRL__INOVER_8h_1a78375b0296a680361d3001d4d1e0ba72.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO14_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO14__CTRL__IRQOVER_8h_1a2717ff681c31a486b7e3550526f5838f.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO14_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO14__CTRL__OEOVER_8h_1a460b3fadd4f3b7ae129be0d5b3aff6e5.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO14_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO14__CTRL__OUTOVER_8h_1a836cd04da92e158957690d9e2a1f7694.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO14_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO15__CTRL__FUNCSEL_8h_1a150f2d38f944e480c67129efe2639dc0.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO15_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO15__CTRL__INOVER_8h_1aacff74ae753f22267dbaabb006ddc81e.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO15_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO15__CTRL__IRQOVER_8h_1a5a22046ca6a1423d5dea2591de33decf.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO15_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO15__CTRL__OEOVER_8h_1a89861382a3e1386a9b9823f380b54eab.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO15_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO15__CTRL__OUTOVER_8h_1a82f11a147daba8de6c5afcc8e1c3e002.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO15_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO16__CTRL__FUNCSEL_8h_1a7b0bd67fff30e9dfcab1700622c84105.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO16_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO16__CTRL__INOVER_8h_1ace843d0854555c132f7b43dc51061d6a.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO16_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO16__CTRL__IRQOVER_8h_1a0b5b322048d665ae0d3ecc1c4404478f.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO16_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO16__CTRL__OEOVER_8h_1a561511f8c8ce599ee6198bcf01165e59.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO16_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO16__CTRL__OUTOVER_8h_1a7129627f7bba0fd5d3180455a522ede9.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO16_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO17__CTRL__FUNCSEL_8h_1a003f590db96576b5d9bd69b0554cada4.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO17_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO17__CTRL__INOVER_8h_1a1a0841397bf78eb81493dcfe150b1c18.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO17_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO17__CTRL__IRQOVER_8h_1a1950fe94447b66f0ab2230caf58411ea.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO17_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO17__CTRL__OEOVER_8h_1ab00884b2b9abacf0f2d6abe6a5a403b2.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO17_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO17__CTRL__OUTOVER_8h_1a883d514f2e6825efe60242689602cf53.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO17_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO18__CTRL__FUNCSEL_8h_1ac99b8bc4b14ec25c71c8e782440c76ac.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO18_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO18__CTRL__INOVER_8h_1a9f7affbd406d773e7c3795ae542dc9aa.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO18_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO18__CTRL__IRQOVER_8h_1a47fe3b6eade467ebb7f89f6b79cfded7.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO18_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO18__CTRL__OEOVER_8h_1a6400c1d56dd14e67b5e0eae76fc32a61.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO18_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO18__CTRL__OUTOVER_8h_1ac69a802872b8bcefce4e6e09abb1d475.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO18_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO19__CTRL__FUNCSEL_8h_1aa937dd53df43d4eedca27da56b4fc1e5.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO19_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO19__CTRL__INOVER_8h_1a1e42542fe712c6ce44b1498f51daa6d4.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO19_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO19__CTRL__IRQOVER_8h_1a49de807083fe9cc74e56fe48409125ba.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO19_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO19__CTRL__OEOVER_8h_1abd3be90a724b2911920f4e38a5ef942e.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO19_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO19__CTRL__OUTOVER_8h_1a73e7e1d5c872879e13c249a5dbfbbd31.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO19_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO1__CTRL__FUNCSEL_8h_1a81d32466bfbd15557e3fb4daf75c54c8.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO1_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO1__CTRL__INOVER_8h_1aa032092d09f7d8ac1eca54b8b62aaa5d.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO1_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO1__CTRL__IRQOVER_8h_1ab452ef6345ca885e9f9c4b87a9be1687.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO1_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO1__CTRL__OEOVER_8h_1a01a6a91b309b645f177d0d89958af865.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO1_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO1__CTRL__OUTOVER_8h_1aa10fed0510d6a8285987d39e661a3357.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO1_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO20__CTRL__FUNCSEL_8h_1a18b2784130f82aed97ddda1629d9120b.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO20_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO20__CTRL__INOVER_8h_1ada899c572bb82f4c21a81b4c3c8096c9.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO20_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO20__CTRL__IRQOVER_8h_1ad879fb72637f9e733f31f65cae249242.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO20_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO20__CTRL__OEOVER_8h_1a3cf97b3507933117be3d8e121d0defc1.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO20_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO20__CTRL__OUTOVER_8h_1a0d3d625e70bedb4f268c38cf45cc79a4.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO20_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO21__CTRL__FUNCSEL_8h_1a9c452d5dfa6e835a33cbbee11c828689.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO21_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO21__CTRL__INOVER_8h_1a97b5d5070cb171ca07fb9efc98695314.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO21_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO21__CTRL__IRQOVER_8h_1ae2916e63c0f75d7587b0d507d71b3990.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO21_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO21__CTRL__OEOVER_8h_1a544e6df1e671dabfdbdffac13e66b016.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO21_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO21__CTRL__OUTOVER_8h_1a10e7df091745aa17010819d72fe7fe4a.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO21_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO22__CTRL__FUNCSEL_8h_1a72dcd7429ccc8fd6d1276a337c3dce82.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO22_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO22__CTRL__INOVER_8h_1a943bc02c08fb082fd7230be34946ee6a.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO22_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO22__CTRL__IRQOVER_8h_1a5fa26bd3bc9d6806dc5f1b39e60705a0.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO22_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO22__CTRL__OEOVER_8h_1afb3ef1db807c900967c80d2201b578d9.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO22_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO22__CTRL__OUTOVER_8h_1a02fcbd5c18fbfe9ad02924934a5e78e7.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO22_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO23__CTRL__FUNCSEL_8h_1a96105f033a82fa1851acf3f99c7bf6df.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO23_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO23__CTRL__INOVER_8h_1a41c6de42e6aee24710db900e79d075c0.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO23_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO23__CTRL__IRQOVER_8h_1a584486c6856afad3ca189cce9378443f.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO23_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO23__CTRL__OEOVER_8h_1ace89e5bece392f7cfcb6d607f6521f9c.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO23_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO23__CTRL__OUTOVER_8h_1a8af872de7f90ca24205e28e7d36ddcce.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO23_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO24__CTRL__FUNCSEL_8h_1a2ff6ed52e0927336cba3827dbd8881a1.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO24_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO24__CTRL__INOVER_8h_1a1c28b6c2d4d699bdfbd38769c2df05c0.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO24_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO24__CTRL__IRQOVER_8h_1a6cfd1ca47e348881c879c542a0991ce9.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO24_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO24__CTRL__OEOVER_8h_1a0795636432cb9e99ada76ff2ee66a9e8.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO24_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO24__CTRL__OUTOVER_8h_1a65ca768635380d5c35a44832b66fdecf.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO24_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO25__CTRL__FUNCSEL_8h_1a374731d7334428696beb10792fa23276.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO25_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO25__CTRL__INOVER_8h_1a91c45f15d74c862912b93a65e7d1f37b.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO25_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO25__CTRL__IRQOVER_8h_1a491895acc90ff6c34d97880f49265355.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO25_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO25__CTRL__OEOVER_8h_1a288443b2bd0cfeea4b30007f29646398.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO25_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO25__CTRL__OUTOVER_8h_1ae4b1cc9eaf06114a3481e89158909d98.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO25_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO26__CTRL__FUNCSEL_8h_1a3112cae4cf0004eff63036b75d0606c8.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO26_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO26__CTRL__INOVER_8h_1aa5fcf448f52436d0f6f33324cad8d2b8.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO26_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO26__CTRL__IRQOVER_8h_1a43168614c75faebcd08df874e33d5912.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO26_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO26__CTRL__OEOVER_8h_1adea9795b089f0a24fa066408e8187e89.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO26_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO26__CTRL__OUTOVER_8h_1a6091a92662454f10db3ea0fb8053274f.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO26_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO27__CTRL__FUNCSEL_8h_1a278d8863d3a90824969cbbc983404b6d.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO27_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO27__CTRL__INOVER_8h_1add18bb18085afa285fcab62bfe4afe80.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO27_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO27__CTRL__IRQOVER_8h_1afa7f3ba4c5dfb807ed33768093cfa2ef.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO27_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO27__CTRL__OEOVER_8h_1aa4e389ef132a39ae94934f9ddc965fbe.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO27_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO27__CTRL__OUTOVER_8h_1ade7017b345fc69b73347b24e4656ba39.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO27_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO28__CTRL__FUNCSEL_8h_1a5e430f2c6d71268ae7bfd5513f7e75a3.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO28_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO28__CTRL__INOVER_8h_1aef11c0599812da0835457dff727e2938.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO28_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO28__CTRL__IRQOVER_8h_1a45a023d4271252c69cd8e75b02910287.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO28_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO28__CTRL__OEOVER_8h_1abb7da41f651e84e19d1a4e32c18b48bf.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO28_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO28__CTRL__OUTOVER_8h_1a06e08c2f4ada876d9eda2a0152af439c.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO28_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO29__CTRL__FUNCSEL_8h_1aaf2a65e718aca5101dc45380b3cab7c2.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO29_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO29__CTRL__INOVER_8h_1af4144e656461f7c724d5a42e8379ab2e.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO29_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO29__CTRL__IRQOVER_8h_1a2602686e97bbfca68cda8dca8a0f4653.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO29_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO29__CTRL__OEOVER_8h_1aba8ed50efe7698d4200b94f555f6909d.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO29_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO29__CTRL__OUTOVER_8h_1abc5831809bc291e22234fd2eea33e2d5.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO29_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO2__CTRL__FUNCSEL_8h_1af51d137dffadb6e880ca936c9a6c46a0.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO2_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO2__CTRL__INOVER_8h_1aa4201dcb7c8b7b7add20ff2a1be923f4.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO2_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO2__CTRL__IRQOVER_8h_1a7d2d611f96e7e6e406cadcd42cc769e6.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO2_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO2__CTRL__OEOVER_8h_1acabd225063b7cb9a2271216d6ac5a47b.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO2_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO2__CTRL__OUTOVER_8h_1abe7e94bf3ad51da491460b7ab1540e43.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO2_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO3__CTRL__FUNCSEL_8h_1a330dbe0d2e71a24fc2c13cd3108f42fb.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO3_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO3__CTRL__INOVER_8h_1a95099ebaa4ca9396c14001aff8452f95.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO3_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO3__CTRL__IRQOVER_8h_1a5b063d469319ec55b81f2a3c9abb3d66.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO3_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO3__CTRL__OEOVER_8h_1af09fb5e521b2ce7ed89bb475569d4a32.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO3_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO3__CTRL__OUTOVER_8h_1abb5ba9ea5c16dc7f8d52fa5406309e01.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO3_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO4__CTRL__FUNCSEL_8h_1abd72c7227442652a202be61d84fcbe9c.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO4_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO4__CTRL__INOVER_8h_1afb2709498edd7f66a4deb3aa68c63cf7.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO4_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO4__CTRL__IRQOVER_8h_1ae265330e4dbf789214909f74a747d634.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO4_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO4__CTRL__OEOVER_8h_1a628640f0402594cfda13ea792599d77e.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO4_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO4__CTRL__OUTOVER_8h_1a2b6d6a4b8e06d0350ffbfff9252a24ac.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO4_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO5__CTRL__FUNCSEL_8h_1adc2dde1b492735ae6c135adc10d6be8a.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO5_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO5__CTRL__INOVER_8h_1acb21f4d50d18c3954c5ccdeada0d2a11.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO5_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO5__CTRL__IRQOVER_8h_1a33aabb946956a1dec601678411ecb139.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO5_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO5__CTRL__OEOVER_8h_1a725689fb5ba8db4c5e66aeadd5942aed.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO5_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO5__CTRL__OUTOVER_8h_1ab37949405945ed8f22e4683ada31380a.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO5_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO6__CTRL__FUNCSEL_8h_1a7cd12683521ccb387b565842c8130804.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO6_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO6__CTRL__INOVER_8h_1a017c692b600925d5a5674938f3f45582.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO6_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO6__CTRL__IRQOVER_8h_1a4fd1abd51c5ba5f3385747b709b3d241.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO6_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO6__CTRL__OEOVER_8h_1a472f30d82396e3675d65c88d9d26f063.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO6_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO6__CTRL__OUTOVER_8h_1a2b014e03ee487e973c28ea9596b5416f.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO6_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO7__CTRL__FUNCSEL_8h_1a0df7a9023c0977c461368fc4bc40d7c8.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO7_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO7__CTRL__INOVER_8h_1aa35d8da13bf6d5671e58119826fd93bb.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO7_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO7__CTRL__IRQOVER_8h_1a9067c36587fca9868d142612effd935f.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO7_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO7__CTRL__OEOVER_8h_1ac48a6358e8b46b4277b928ba2f24a4a4.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO7_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO7__CTRL__OUTOVER_8h_1a97958a96f76108fc968855acc23be627.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO7_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO8__CTRL__FUNCSEL_8h_1a2aaee69ff2d28889af53efd69def4b73.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO8_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO8__CTRL__INOVER_8h_1adc32b51af5d93c372dfbccf7d609a64d.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO8_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO8__CTRL__IRQOVER_8h_1a11d470f6f7c9d930662f9ad1dbb34dda.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO8_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO8__CTRL__OEOVER_8h_1a6a02d21b818b49f5ea24ee6df31999c2.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO8_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO8__CTRL__OUTOVER_8h_1a8fa4bc1898ee6aaf82703170040b8616.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO8_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO9__CTRL__FUNCSEL_8h_1a5c769508c805b3ad72d875da41beabdf.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO9_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO9__CTRL__INOVER_8h_1a8d5c1da5e6abb179ad3e8bb775921bef.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO9_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO9__CTRL__IRQOVER_8h_1a4f7c130105659fb8a70f332cd2247ff1.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO9_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO9__CTRL__OEOVER_8h_1a70fdca804850b239ea9fa21a259533b7.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO9_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO9__CTRL__OUTOVER_8h_1ab1162ce7fdddf0df5099e576ab6e328b.html">Function RP2040::from_string(const char *, IO_BANK0_GPIO9_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SCLK__CTRL__FUNCSEL_8h_1a81976f291539dc6a90ce3e6dc252c0ae.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SCLK__CTRL__INOVER_8h_1aa7c0d321d8e475eb856ac0daa5459be8.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SCLK__CTRL__IRQOVER_8h_1a228b2e86cb7eac933a86656b9058f2f0.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SCLK__CTRL__OEOVER_8h_1a2bb1ba31a149b04cccdec0ae8f7e7ea1.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SCLK__CTRL__OUTOVER_8h_1acfffdd1335ff7d48455c71f30689b9d4.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD0__CTRL__FUNCSEL_8h_1ad37b083a1a6605451a6acba538e2253a.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD0__CTRL__INOVER_8h_1a241d2b341fca375146fb2c4935c725e0.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD0__CTRL__IRQOVER_8h_1a9bca98c3fef28e57c89e5860e71ae897.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD0__CTRL__OEOVER_8h_1a42b9730c89a3e3ac44faa6cf02fab45c.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD0__CTRL__OUTOVER_8h_1ad333c6d513b6b7a16dac3ed812066dfd.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD1__CTRL__FUNCSEL_8h_1a761f16bf7ec164a18d24e8212c35722e.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD1__CTRL__INOVER_8h_1ab083a4929ad12fad73639c768aacc373.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD1__CTRL__IRQOVER_8h_1afd80c41eb2fec5cb5975871756192764.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD1__CTRL__OEOVER_8h_1ad9e4b81495530499314394ec0f6b34e3.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD1__CTRL__OUTOVER_8h_1a79cc0947ca9b4c6c9ef07a1d1942a12f.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD2__CTRL__FUNCSEL_8h_1a180f5a664bcdf1646af84f693375e8b5.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD2__CTRL__INOVER_8h_1a8a19f3a5f8ae9966ea175be88a9fda1e.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD2__CTRL__IRQOVER_8h_1a59aa1608f4a2a2f3623703d0a8191a01.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD2__CTRL__OEOVER_8h_1a14108d7510e33dea2abbc5bb6f159d4e.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD2__CTRL__OUTOVER_8h_1ac0fd1e688c61dfc30579bd5161f3965b.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD3__CTRL__FUNCSEL_8h_1af619ff15af8a53ec0392176672156d8a.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD3__CTRL__INOVER_8h_1aa34a5b9d58b6c74181574b9fb417ebc9.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD3__CTRL__IRQOVER_8h_1a147c791bc44555e1468d3be4d6da7922.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD3__CTRL__OEOVER_8h_1ab80ccb93e50a2d8dd5742361fa4b46a9.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD3__CTRL__OUTOVER_8h_1a931f7eb8c93d71837ab4c853e60ce29b.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SS__CTRL__FUNCSEL_8h_1a023e87878a3394eedaf5504ffec3f851.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SS__CTRL__INOVER_8h_1a1b5259af3722897320fe47ab30f21a24.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SS__CTRL__IRQOVER_8h_1a905d5ca858ebb7a6fe7f3aad41ba5eea.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SS__CTRL__OEOVER_8h_1abd47d4c6f8a6a07c13df867f6fd80d9a.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SS__CTRL__OUTOVER_8h_1a82f2de81a4dd5e51468e78ff19aaeda0.html">Function RP2040::from_string(const char *, IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO0__DRIVE_8h_1a55f43f1ec402f1884bb55ede4910734c.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO0_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO10__DRIVE_8h_1a54c3af09803ae15ca94de039cac43d38.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO10_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO11__DRIVE_8h_1adab1ce172f16067971dc93a15afacd41.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO11_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO12__DRIVE_8h_1a43dcb0c9f9f392903c231faa9cd98979.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO12_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO13__DRIVE_8h_1a3b811633aee9fdd14f362ed101dd677e.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO13_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO14__DRIVE_8h_1a92cf9189b8a26a43a9743cc68e3ddd5c.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO14_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO15__DRIVE_8h_1aa6ca94655dadd21cd2e4307c2b066f4e.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO15_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO16__DRIVE_8h_1a93cd1e38f184e81afe63ce50a6e843c5.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO16_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO17__DRIVE_8h_1a36b4ec76bdf0158bb742945dcc42f761.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO17_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO18__DRIVE_8h_1a296028a8a62b8baa67588521e4158edd.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO18_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO19__DRIVE_8h_1a0ddd0055744b395b9e92851380a4dabb.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO19_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO1__DRIVE_8h_1aa6c2abdadaf21d4bc85ec06d917c10f2.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO1_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO20__DRIVE_8h_1a42b125000d0b6c712bbbd73f41a41956.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO20_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO21__DRIVE_8h_1aefe06db0f37298b2d9b724ebb7419b6c.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO21_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO22__DRIVE_8h_1a25a3775ece8f24595c2da5b9e74acdf3.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO22_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO23__DRIVE_8h_1a363d1879b26af2835def882d90ace2ff.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO23_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO24__DRIVE_8h_1a83633cc5b43eb2c6b02f997d9de57380.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO24_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO25__DRIVE_8h_1ad5d4a555ee8879010387d6b7e2a66d9a.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO25_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO26__DRIVE_8h_1ace320916a4557438de4372bd9a9b8ae0.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO26_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO27__DRIVE_8h_1acff1aa93f30c0f500c1925bf33527e8f.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO27_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO28__DRIVE_8h_1aef72e5cf654537d371227e11b2dd1e8e.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO28_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO29__DRIVE_8h_1a224c9a48ddfbc3a0cfe7acf8292460b5.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO29_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO2__DRIVE_8h_1a5b99e0e2656185917d6ddd0e689c608c.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO2_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO3__DRIVE_8h_1a915d81ab6ef84842f4a670ffa603280e.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO3_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO4__DRIVE_8h_1af5dcc1cba376941fd9a90fb968be7c73.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO4_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO5__DRIVE_8h_1a7d6087c6ccd33e18b15b7d03fefd2505.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO5_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO6__DRIVE_8h_1aee88e8f8b4922275471d25c88b1a1a84.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO6_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO7__DRIVE_8h_1a6a8ab58a83e9bac2106afe01d2aa48ca.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO7_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO8__DRIVE_8h_1aea0b0868f94454ea1ef4411f4ff2419b.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO8_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO9__DRIVE_8h_1a2c0862bee2228b78c7bebd11bba71f29.html">Function RP2040::from_string(const char *, PADS_BANK0_GPIO9_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__SWCLK__DRIVE_8h_1a06220a61b8fe756d8f3533f353655fab.html">Function RP2040::from_string(const char *, PADS_BANK0_SWCLK_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__SWD__DRIVE_8h_1a8350d3eadece080bc2854ebfd55483ff.html">Function RP2040::from_string(const char *, PADS_BANK0_SWD_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__QSPI__GPIO__QSPI__SCLK__DRIVE_8h_1aab4ca452a209fe3a2389f78d9d6f49a4.html">Function RP2040::from_string(const char *, PADS_QSPI_GPIO_QSPI_SCLK_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__QSPI__GPIO__QSPI__SD0__DRIVE_8h_1a83b9f9425aace537dffa188a7a0f6fd6.html">Function RP2040::from_string(const char *, PADS_QSPI_GPIO_QSPI_SD0_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__QSPI__GPIO__QSPI__SD1__DRIVE_8h_1a219d61b4505c8d33c71a41b17ffbc908.html">Function RP2040::from_string(const char *, PADS_QSPI_GPIO_QSPI_SD1_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__QSPI__GPIO__QSPI__SD2__DRIVE_8h_1aa0a257f25cab8a70c71a47a952a824c5.html">Function RP2040::from_string(const char *, PADS_QSPI_GPIO_QSPI_SD2_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__QSPI__GPIO__QSPI__SD3__DRIVE_8h_1abfd0dd0248360ffd927340c29a8e50b8.html">Function RP2040::from_string(const char *, PADS_QSPI_GPIO_QSPI_SD3_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__QSPI__GPIO__QSPI__SS__DRIVE_8h_1affe460cf0633024e18a6e0d57b1e9a0f.html">Function RP2040::from_string(const char *, PADS_QSPI_GPIO_QSPI_SS_DRIVE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PWM__CH0__CSR__DIVMODE_8h_1a64f641d09daa66adf37c69e07fb85abe.html">Function RP2040::from_string(const char *, PWM_CH0_CSR_DIVMODE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PWM__CH1__CSR__DIVMODE_8h_1a0c9a5191e4be189c46a7513532d27628.html">Function RP2040::from_string(const char *, PWM_CH1_CSR_DIVMODE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PWM__CH2__CSR__DIVMODE_8h_1ae3e84d4a1747ee5f46da5c535ea85c63.html">Function RP2040::from_string(const char *, PWM_CH2_CSR_DIVMODE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PWM__CH3__CSR__DIVMODE_8h_1a4847cdb4e18f7e10e0827ae67404ae11.html">Function RP2040::from_string(const char *, PWM_CH3_CSR_DIVMODE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PWM__CH4__CSR__DIVMODE_8h_1a6d3bc62f007258c42863ffd28c549aac.html">Function RP2040::from_string(const char *, PWM_CH4_CSR_DIVMODE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PWM__CH5__CSR__DIVMODE_8h_1a383286e50888d0cdb96c6690132e8a18.html">Function RP2040::from_string(const char *, PWM_CH5_CSR_DIVMODE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PWM__CH6__CSR__DIVMODE_8h_1a12ac5afba9436cc77fb2584f8abeeca8.html">Function RP2040::from_string(const char *, PWM_CH6_CSR_DIVMODE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PWM__CH7__CSR__DIVMODE_8h_1aa656a1c4385eb0e50d299ae3ce5bf302.html">Function RP2040::from_string(const char *, PWM_CH7_CSR_DIVMODE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_ROSC__CTRL__ENABLE_8h_1ac21d9eaa29308b37dc27ade9bf318b0a.html">Function RP2040::from_string(const char *, ROSC_CTRL_ENABLE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_ROSC__CTRL__FREQ__RANGE_8h_1aef7a55da107efa799c6b9b20c59d2617.html">Function RP2040::from_string(const char *, ROSC_CTRL_FREQ_RANGE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_ROSC__DIV__DIV_8h_1acd343d8509d0bf69a9ab65ba930fe267.html">Function RP2040::from_string(const char *, ROSC_DIV_DIV&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_ROSC__FREQA__PASSWD_8h_1a12a81d28c957bc7d3b11ad033ee79e30.html">Function RP2040::from_string(const char *, ROSC_FREQA_PASSWD&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_ROSC__FREQB__PASSWD_8h_1ad01541112286c190686befb17fcdf650.html">Function RP2040::from_string(const char *, ROSC_FREQB_PASSWD&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP0__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ab917e2b1ab804100f5a98d84b70ba71c.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP0__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a49a2480ae5966d755ff3935aef9cffd2.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP10__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ab593190d6755d0692bad1efd974500fc.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP10__IN__CONTROL__ENDPOINT__TYPE_8h_1aa8c5230e4045cf785c8671c7dcc0ca37.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP10_IN_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP10__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1aa98906ae7ff224d37afb4f8a8cafd7bd.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP10__OUT__CONTROL__ENDPOINT__TYPE_8h_1a6dda4c6b5c69294b8b9be872226fb0fe.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP10_OUT_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP11__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a716b440a4458ac1a689cb2da9f89115f.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP11__IN__CONTROL__ENDPOINT__TYPE_8h_1a814c87f17e9402876139e1018a721497.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP11_IN_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP11__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1abb1d98b010b6b17ba9c54802b9af32d5.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP11__OUT__CONTROL__ENDPOINT__TYPE_8h_1aad556ad7e2a97f13bd61f1a57eabd0b2.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP11_OUT_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP12__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a7941c74af9f01ec3c2d2d0ac5de48383.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP12__IN__CONTROL__ENDPOINT__TYPE_8h_1acef8dfbc313139e20ccdda8d84a5b451.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP12_IN_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP12__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a03c77fa13ccd43cbadaa38d62d88b752.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP12__OUT__CONTROL__ENDPOINT__TYPE_8h_1a0efcf157a8cc27b3b902650bd04f6cc0.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP12_OUT_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP13__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a1def06f1446998eeaab096c707088c5c.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP13__IN__CONTROL__ENDPOINT__TYPE_8h_1a3a9c12bdcddb26af09197e989423ba56.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP13_IN_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP13__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a736418e8416e6f3d5d8bbee6cb458ebb.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP13__OUT__CONTROL__ENDPOINT__TYPE_8h_1a36b75bdc969e9b3a15623dfde8545809.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP13_OUT_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP14__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ae56a0144269e6012abef046bb7fed00c.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP14__IN__CONTROL__ENDPOINT__TYPE_8h_1a700118bdd70cfc1174c4e590e55b42aa.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP14_IN_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP14__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a7c34df457e400bb7fd45298d551eda53.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP14__OUT__CONTROL__ENDPOINT__TYPE_8h_1af05172ef4c16f6ab9106999ac11dfdc5.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP14_OUT_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP15__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a0ddb378bba41c541f065864cc9613dbf.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP15__IN__CONTROL__ENDPOINT__TYPE_8h_1ac6dc3ef7b3939c740cf2c3fbb95040b5.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP15_IN_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP15__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a59e17c9bd4eeb1e3f7691051a2b15431.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP15__OUT__CONTROL__ENDPOINT__TYPE_8h_1aaecb480128387f033635520bb1ac3b4c.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP15_OUT_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP1__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ab1f73b372de69454eb6e63097d42bd80.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP1__IN__CONTROL__ENDPOINT__TYPE_8h_1a3f8998e5b53b6f66cd2109fc49a2e888.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP1_IN_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP1__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ac75cac9e54c4f7088bd231c938cf9fcb.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP1__OUT__CONTROL__ENDPOINT__TYPE_8h_1a5fe3b31f0a6f9c3fbe0d4f7823c5eddb.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP1_OUT_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP2__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ad88f23993f5509259ca45c9085a7d2e0.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP2__IN__CONTROL__ENDPOINT__TYPE_8h_1a4dd68577c71bc921291597b807732f7b.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP2_IN_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP2__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a13e73174a6263f91ebc12f3156a89b2f.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP2__OUT__CONTROL__ENDPOINT__TYPE_8h_1a794562a9a73377ec7a32a57debbc2eee.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP2_OUT_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP3__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a7f60d78ae4029d86a5f2e43d9a550738.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP3__IN__CONTROL__ENDPOINT__TYPE_8h_1a0b685fb5f2be76a462c1b8b7a17a6a41.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP3_IN_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP3__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a4bdd2df07720e7027adcfd5701606d39.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP3__OUT__CONTROL__ENDPOINT__TYPE_8h_1af9c44f2b8f7d05182f4b1b760153712a.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP3_OUT_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP4__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a47b62957f29ba5d4f83d350586e8507a.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP4__IN__CONTROL__ENDPOINT__TYPE_8h_1abae28dcc5bc39863932dc977cdc6f986.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP4_IN_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP4__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a4ca96aa4374f5f99a54d9a66d5fa874d.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP4__OUT__CONTROL__ENDPOINT__TYPE_8h_1ad2c8d2eebd0d27ebf3bc7c78c405756d.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP4_OUT_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP5__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a58cba5d4c0a4966adb32abb51ca7e926.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP5__IN__CONTROL__ENDPOINT__TYPE_8h_1a062e2560324cd6c37051981e7a285ca6.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP5_IN_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP5__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a30cb9cebf835593eb07af989447ddbc3.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP5__OUT__CONTROL__ENDPOINT__TYPE_8h_1ac6595b9f76a3efd7b73ff6cb94f9eb6c.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP5_OUT_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP6__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a5368cfdfff3cff0993e25dd444895f98.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP6__IN__CONTROL__ENDPOINT__TYPE_8h_1aedd860c418acbbd9e449c6e9a74d8b99.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP6_IN_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP6__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a275c38af62fe1131475ecdbd650473ce.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP6__OUT__CONTROL__ENDPOINT__TYPE_8h_1a9f42a61b8f5c591d34deedaf1c023532.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP6_OUT_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP7__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1aaae93c5bbed7b37156617b34be88a693.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP7__IN__CONTROL__ENDPOINT__TYPE_8h_1ada175f177993c2ccc909c722b7ea47b1.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP7_IN_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP7__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1afac01b49553a3659685eb00b3f521ef7.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP7__OUT__CONTROL__ENDPOINT__TYPE_8h_1ae3c789da97707bd48b4c4af4a45fb2bf.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP7_OUT_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP8__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a37c38ecc759afa1b159980570d4d6eda.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP8__IN__CONTROL__ENDPOINT__TYPE_8h_1ae2300f97c71f3847b067ab552f92f481.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP8_IN_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP8__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a745889f1904c713bc0009a638323c96d.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP8__OUT__CONTROL__ENDPOINT__TYPE_8h_1a68eab41cc66d4d18f0a17b0b9130c0cb.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP8_OUT_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP9__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a3279215d8deb91bf24c88a94f549dc5d.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP9__IN__CONTROL__ENDPOINT__TYPE_8h_1a9a7c2f8485711d7c9c4c6630676858c6.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP9_IN_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP9__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a214b263bbc138e43c8ae852673ae1212.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP9__OUT__CONTROL__ENDPOINT__TYPE_8h_1a81bd5c1795f906d7fd03cd507e7e80c4.html">Function RP2040::from_string(const char *, USBCTRL_DPRAM_EP9_OUT_CONTROL_ENDPOINT_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_XIP__SSI__CTRLR0__SPI__FRF_8h_1aa82a146ff5caafdeefa18ff56a635d19.html">Function RP2040::from_string(const char *, XIP_SSI_CTRLR0_SPI_FRF&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_XIP__SSI__CTRLR0__TMOD_8h_1aaf081d5bedf99b3e2e5c24c844e6e9e9.html">Function RP2040::from_string(const char *, XIP_SSI_CTRLR0_TMOD&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_XIP__SSI__SPI__CTRLR0__INST__L_8h_1aa05679f3418b0205b8b44ddcbf9fc67d.html">Function RP2040::from_string(const char *, XIP_SSI_SPI_CTRLR0_INST_L&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_XIP__SSI__SPI__CTRLR0__TRANS__TYPE_8h_1a1c6ea7bd536c0a622c8e9d46a2f14329.html">Function RP2040::from_string(const char *, XIP_SSI_SPI_CTRLR0_TRANS_TYPE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_XOSC__CTRL__ENABLE_8h_1aeaf70c93b9b325bdd85f3d002dad8ea5.html">Function RP2040::from_string(const char *, XOSC_CTRL_ENABLE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_XOSC__CTRL__FREQ__RANGE_8h_1ac4576136381f416907a240f81d04830e.html">Function RP2040::from_string(const char *, XOSC_CTRL_FREQ_RANGE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_XOSC__STATUS__FREQ__RANGE_8h_1ae409249f30af95b4622ea79254c265ff.html">Function RP2040::from_string(const char *, XOSC_STATUS_FREQ_RANGE&amp;)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_BUSCTRL__PERFSEL0__PERFSEL0_8h_1ae3e2a552c85cf208b87cc14fbde6144a.html">Function RP2040::to_string(BUSCTRL_PERFSEL0_PERFSEL0)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_BUSCTRL__PERFSEL1__PERFSEL1_8h_1ace02c88ad397372b89d10caa0b073f20.html">Function RP2040::to_string(BUSCTRL_PERFSEL1_PERFSEL1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_BUSCTRL__PERFSEL2__PERFSEL2_8h_1a05482481c737ce2aab56c46df4f3b67d.html">Function RP2040::to_string(BUSCTRL_PERFSEL2_PERFSEL2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_BUSCTRL__PERFSEL3__PERFSEL3_8h_1a2ade387caa1fa09bcc8f9c4641f378ea.html">Function RP2040::to_string(BUSCTRL_PERFSEL3_PERFSEL3)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__ADC__CTRL__AUXSRC_8h_1a97fd9b012e4b7643f628aa5907c3b68c.html">Function RP2040::to_string(CLOCKS_CLK_ADC_CTRL_AUXSRC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__GPOUT0__CTRL__AUXSRC_8h_1a7c385cce0e4d6a1da347cfc708e556a4.html">Function RP2040::to_string(CLOCKS_CLK_GPOUT0_CTRL_AUXSRC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__GPOUT1__CTRL__AUXSRC_8h_1a5dc5c5da7bbf10276c6e23a3cf4db2ef.html">Function RP2040::to_string(CLOCKS_CLK_GPOUT1_CTRL_AUXSRC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__GPOUT2__CTRL__AUXSRC_8h_1a26422a2d01506d6b3cde398980a84d45.html">Function RP2040::to_string(CLOCKS_CLK_GPOUT2_CTRL_AUXSRC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__GPOUT3__CTRL__AUXSRC_8h_1aebee46d9c35b73af731705f9767e1c4d.html">Function RP2040::to_string(CLOCKS_CLK_GPOUT3_CTRL_AUXSRC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__PERI__CTRL__AUXSRC_8h_1a44ccb23d69aaaa0659bce2849816c6bf.html">Function RP2040::to_string(CLOCKS_CLK_PERI_CTRL_AUXSRC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__REF__CTRL__AUXSRC_8h_1a5a3a689afd72317c354233c19e4317cc.html">Function RP2040::to_string(CLOCKS_CLK_REF_CTRL_AUXSRC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__REF__CTRL__SRC_8h_1a8cea234e6eb8ee3a15e0cedfa9226849.html">Function RP2040::to_string(CLOCKS_CLK_REF_CTRL_SRC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__RTC__CTRL__AUXSRC_8h_1a6230594496687659e47bbccdf3b7fc3b.html">Function RP2040::to_string(CLOCKS_CLK_RTC_CTRL_AUXSRC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__SYS__CTRL__AUXSRC_8h_1a102eddfaec54200ccc1944ca1a4a7a0e.html">Function RP2040::to_string(CLOCKS_CLK_SYS_CTRL_AUXSRC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__CLK__USB__CTRL__AUXSRC_8h_1adc769038d30a62f27d0a4080baa44e80.html">Function RP2040::to_string(CLOCKS_CLK_USB_CTRL_AUXSRC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_CLOCKS__FC0__SRC__FC0__SRC_8h_1ab0c389630018ecfb8f826eab9f516898.html">Function RP2040::to_string(CLOCKS_FC0_SRC_FC0_SRC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH0__CTRL__TRIG__DATA__SIZE_8h_1a445cb4d7e2340df7c9b3e12942af16ae.html">Function RP2040::to_string(DMA_CH0_CTRL_TRIG_DATA_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH0__CTRL__TRIG__RING__SIZE_8h_1ab5a14544dce0075ac25400d2afafbafe.html">Function RP2040::to_string(DMA_CH0_CTRL_TRIG_RING_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH0__CTRL__TRIG__TREQ__SEL_8h_1a4d9ab80e80522d5289af994b17e410b9.html">Function RP2040::to_string(DMA_CH0_CTRL_TRIG_TREQ_SEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH10__CTRL__TRIG__DATA__SIZE_8h_1a1c4d2aae108662e237cb00cc706c7e39.html">Function RP2040::to_string(DMA_CH10_CTRL_TRIG_DATA_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH10__CTRL__TRIG__RING__SIZE_8h_1ae4f1c7e17ce38cd22a923e189db8da85.html">Function RP2040::to_string(DMA_CH10_CTRL_TRIG_RING_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH10__CTRL__TRIG__TREQ__SEL_8h_1a1d2f0f1480df71c3d983025f16f16f85.html">Function RP2040::to_string(DMA_CH10_CTRL_TRIG_TREQ_SEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH11__CTRL__TRIG__DATA__SIZE_8h_1a6302c5d773449d2612221ea9289aecae.html">Function RP2040::to_string(DMA_CH11_CTRL_TRIG_DATA_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH11__CTRL__TRIG__RING__SIZE_8h_1a3ed55d8f6a127742f0865cd10d6966cb.html">Function RP2040::to_string(DMA_CH11_CTRL_TRIG_RING_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH11__CTRL__TRIG__TREQ__SEL_8h_1a59678ef66f527c4b60f18be737eec585.html">Function RP2040::to_string(DMA_CH11_CTRL_TRIG_TREQ_SEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH1__CTRL__TRIG__DATA__SIZE_8h_1a6836d21c706bd8a0640cdd6a8db62489.html">Function RP2040::to_string(DMA_CH1_CTRL_TRIG_DATA_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH1__CTRL__TRIG__RING__SIZE_8h_1a4f9b05db65b40576b33df4c7eea7d846.html">Function RP2040::to_string(DMA_CH1_CTRL_TRIG_RING_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH1__CTRL__TRIG__TREQ__SEL_8h_1a2ff31ed774398f83be15b665aa7b9a8d.html">Function RP2040::to_string(DMA_CH1_CTRL_TRIG_TREQ_SEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH2__CTRL__TRIG__DATA__SIZE_8h_1ac6061b126e2f6076b0335731265b51cf.html">Function RP2040::to_string(DMA_CH2_CTRL_TRIG_DATA_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH2__CTRL__TRIG__RING__SIZE_8h_1ad386681e2832c9d9f692f15939bccda9.html">Function RP2040::to_string(DMA_CH2_CTRL_TRIG_RING_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH2__CTRL__TRIG__TREQ__SEL_8h_1aed7a2d0500a3339972042fc03a38a09d.html">Function RP2040::to_string(DMA_CH2_CTRL_TRIG_TREQ_SEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH3__CTRL__TRIG__DATA__SIZE_8h_1a0eeb68f79aeaf7ce872a019e5d8bba29.html">Function RP2040::to_string(DMA_CH3_CTRL_TRIG_DATA_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH3__CTRL__TRIG__RING__SIZE_8h_1af2c9bda644687cef82f84ee8ac39a40c.html">Function RP2040::to_string(DMA_CH3_CTRL_TRIG_RING_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH3__CTRL__TRIG__TREQ__SEL_8h_1a01668ac7a16e61ecdb97ddb54ae9cb63.html">Function RP2040::to_string(DMA_CH3_CTRL_TRIG_TREQ_SEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH4__CTRL__TRIG__DATA__SIZE_8h_1a24b5c6d2db29216d9be3194b4987e616.html">Function RP2040::to_string(DMA_CH4_CTRL_TRIG_DATA_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH4__CTRL__TRIG__RING__SIZE_8h_1a97290a71aa75512985d450f4b6b8cf96.html">Function RP2040::to_string(DMA_CH4_CTRL_TRIG_RING_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH4__CTRL__TRIG__TREQ__SEL_8h_1a03026d40edc2c71d6c8f87bf60b3a17b.html">Function RP2040::to_string(DMA_CH4_CTRL_TRIG_TREQ_SEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH5__CTRL__TRIG__DATA__SIZE_8h_1a9b5e77bd23d44e60ea761358c5b5a015.html">Function RP2040::to_string(DMA_CH5_CTRL_TRIG_DATA_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH5__CTRL__TRIG__RING__SIZE_8h_1a7e3d94e40786eba7f958964e906c273e.html">Function RP2040::to_string(DMA_CH5_CTRL_TRIG_RING_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH5__CTRL__TRIG__TREQ__SEL_8h_1acb58a4e6997f22606620408d8a143e33.html">Function RP2040::to_string(DMA_CH5_CTRL_TRIG_TREQ_SEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH6__CTRL__TRIG__DATA__SIZE_8h_1ae77f1334aedf1323be9cb63601ee9fd6.html">Function RP2040::to_string(DMA_CH6_CTRL_TRIG_DATA_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH6__CTRL__TRIG__RING__SIZE_8h_1aeaa48d86a68578a1d69d3a4791e1032b.html">Function RP2040::to_string(DMA_CH6_CTRL_TRIG_RING_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH6__CTRL__TRIG__TREQ__SEL_8h_1aa352fe3eca70e5755f7239d25dfd9cdb.html">Function RP2040::to_string(DMA_CH6_CTRL_TRIG_TREQ_SEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH7__CTRL__TRIG__DATA__SIZE_8h_1a77476a0e1bf107058530ad06474a209a.html">Function RP2040::to_string(DMA_CH7_CTRL_TRIG_DATA_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH7__CTRL__TRIG__RING__SIZE_8h_1a6bfba0983612234115d7fc59b2a3c407.html">Function RP2040::to_string(DMA_CH7_CTRL_TRIG_RING_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH7__CTRL__TRIG__TREQ__SEL_8h_1a17d909e224a0a5d3e4abab29efe8ce63.html">Function RP2040::to_string(DMA_CH7_CTRL_TRIG_TREQ_SEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH8__CTRL__TRIG__DATA__SIZE_8h_1ab4ce1076159b192a3d8ca3bdba00e7a5.html">Function RP2040::to_string(DMA_CH8_CTRL_TRIG_DATA_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH8__CTRL__TRIG__RING__SIZE_8h_1a55745879efe0b8af26c3bd71e23f7637.html">Function RP2040::to_string(DMA_CH8_CTRL_TRIG_RING_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH8__CTRL__TRIG__TREQ__SEL_8h_1a82e02a22bc56af027a0e722292cf46e8.html">Function RP2040::to_string(DMA_CH8_CTRL_TRIG_TREQ_SEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH9__CTRL__TRIG__DATA__SIZE_8h_1aee1dfcea251a5ffdb1cfddbf12fd0e63.html">Function RP2040::to_string(DMA_CH9_CTRL_TRIG_DATA_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH9__CTRL__TRIG__RING__SIZE_8h_1a7d5ca8358d32b8a7b3fdbe06646eec45.html">Function RP2040::to_string(DMA_CH9_CTRL_TRIG_RING_SIZE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__CH9__CTRL__TRIG__TREQ__SEL_8h_1aa1bae3840a52aaa1b8f580e1fef59eba.html">Function RP2040::to_string(DMA_CH9_CTRL_TRIG_TREQ_SEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_DMA__SNIFF__CTRL__CALC_8h_1a7e9acafc7d91b512a03034df932f40b9.html">Function RP2040::to_string(DMA_SNIFF_CTRL_CALC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_I2C0__IC__CON__SPEED_8h_1a473991e78fea74c814577d2f97f6ee05.html">Function RP2040::to_string(I2C0_IC_CON_SPEED)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO0__CTRL__FUNCSEL_8h_1a08c26e268e711206eb0450292bc6379c.html">Function RP2040::to_string(IO_BANK0_GPIO0_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO0__CTRL__INOVER_8h_1ac2c42c5fd075d231fe7dfd0e86587feb.html">Function RP2040::to_string(IO_BANK0_GPIO0_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO0__CTRL__IRQOVER_8h_1a5bdc709e477790034b93b5231ce023d5.html">Function RP2040::to_string(IO_BANK0_GPIO0_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO0__CTRL__OEOVER_8h_1acb976e7789651b420b8c4c39217f1848.html">Function RP2040::to_string(IO_BANK0_GPIO0_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO0__CTRL__OUTOVER_8h_1a5184f2a6ecce6401ef5d02837d27a82f.html">Function RP2040::to_string(IO_BANK0_GPIO0_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO10__CTRL__FUNCSEL_8h_1a6e2678e61bf02ffcb2e7fe9218027a14.html">Function RP2040::to_string(IO_BANK0_GPIO10_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO10__CTRL__INOVER_8h_1a7d965007a4a064266f16b1d5a5d8b51f.html">Function RP2040::to_string(IO_BANK0_GPIO10_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO10__CTRL__IRQOVER_8h_1a04ffb94b2f6a0718f54267c251fabd9e.html">Function RP2040::to_string(IO_BANK0_GPIO10_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO10__CTRL__OEOVER_8h_1a698447559fddf78bdd7c6a6745d19ee9.html">Function RP2040::to_string(IO_BANK0_GPIO10_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO10__CTRL__OUTOVER_8h_1a74e1b25d9a5c26df6c2bd9abfc9563d8.html">Function RP2040::to_string(IO_BANK0_GPIO10_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO11__CTRL__FUNCSEL_8h_1a9002b716042d8ba57227b71527dbb2a2.html">Function RP2040::to_string(IO_BANK0_GPIO11_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO11__CTRL__INOVER_8h_1a68f1bc9ac7f96eca7d783072e39f2a6b.html">Function RP2040::to_string(IO_BANK0_GPIO11_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO11__CTRL__IRQOVER_8h_1a9649e72dd9fa69881ac282395b5a3348.html">Function RP2040::to_string(IO_BANK0_GPIO11_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO11__CTRL__OEOVER_8h_1af0484d5af52954162122b6e64cf06edf.html">Function RP2040::to_string(IO_BANK0_GPIO11_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO11__CTRL__OUTOVER_8h_1a4ff91cf5b660f1b178d2a99dcb78af20.html">Function RP2040::to_string(IO_BANK0_GPIO11_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO12__CTRL__FUNCSEL_8h_1a2febf84aa40f342b45f2eb9a995d6f84.html">Function RP2040::to_string(IO_BANK0_GPIO12_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO12__CTRL__INOVER_8h_1a08748e5e3d8b30bac920ba19c6629751.html">Function RP2040::to_string(IO_BANK0_GPIO12_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO12__CTRL__IRQOVER_8h_1af61e468692aff25c5fcd65bc0e24451d.html">Function RP2040::to_string(IO_BANK0_GPIO12_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO12__CTRL__OEOVER_8h_1a8a547c3938603c379fa5721bed64c048.html">Function RP2040::to_string(IO_BANK0_GPIO12_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO12__CTRL__OUTOVER_8h_1a22bf32ed1ee0d9ad2dfd14250e37ff7a.html">Function RP2040::to_string(IO_BANK0_GPIO12_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO13__CTRL__FUNCSEL_8h_1a45cbe479f879e962508412829230d4ea.html">Function RP2040::to_string(IO_BANK0_GPIO13_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO13__CTRL__INOVER_8h_1a70643e94e1e085e92a403563a357f398.html">Function RP2040::to_string(IO_BANK0_GPIO13_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO13__CTRL__IRQOVER_8h_1a3f49f87522acc124fd0faf113d6386c9.html">Function RP2040::to_string(IO_BANK0_GPIO13_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO13__CTRL__OEOVER_8h_1aa05e1a63d0279fd176c2a74f602ec2d3.html">Function RP2040::to_string(IO_BANK0_GPIO13_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO13__CTRL__OUTOVER_8h_1a8915770d8ab9221dc5e263574084a858.html">Function RP2040::to_string(IO_BANK0_GPIO13_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO14__CTRL__FUNCSEL_8h_1a391b133f6b0960b1e64c46ea114f6363.html">Function RP2040::to_string(IO_BANK0_GPIO14_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO14__CTRL__INOVER_8h_1a11a5004fa1828d06521a3a8ad3f27344.html">Function RP2040::to_string(IO_BANK0_GPIO14_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO14__CTRL__IRQOVER_8h_1aa6bc8a8624eff04c912fb660da7d88d5.html">Function RP2040::to_string(IO_BANK0_GPIO14_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO14__CTRL__OEOVER_8h_1a0b349ac2d5d741cc0634bed4e36016d7.html">Function RP2040::to_string(IO_BANK0_GPIO14_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO14__CTRL__OUTOVER_8h_1a2d4383874fbd8b7e78df9e0aa7e6697b.html">Function RP2040::to_string(IO_BANK0_GPIO14_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO15__CTRL__FUNCSEL_8h_1a5a250fbc5b32499a90c1f050f50a2e7b.html">Function RP2040::to_string(IO_BANK0_GPIO15_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO15__CTRL__INOVER_8h_1a8e5dbedb1a40fc7cd7592f1fd3a34864.html">Function RP2040::to_string(IO_BANK0_GPIO15_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO15__CTRL__IRQOVER_8h_1a3ae059853a20cb7dfdd803946d23c247.html">Function RP2040::to_string(IO_BANK0_GPIO15_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO15__CTRL__OEOVER_8h_1aab2b655897ca3267a0321e9a9bd9b2bc.html">Function RP2040::to_string(IO_BANK0_GPIO15_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO15__CTRL__OUTOVER_8h_1a52ff0f27ae0192cc674944a7f1921ac5.html">Function RP2040::to_string(IO_BANK0_GPIO15_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO16__CTRL__FUNCSEL_8h_1a96c557a886d9d0ad82a431ec519f6b0b.html">Function RP2040::to_string(IO_BANK0_GPIO16_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO16__CTRL__INOVER_8h_1a58224678e0ea9640c5bb9aadcbdc152a.html">Function RP2040::to_string(IO_BANK0_GPIO16_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO16__CTRL__IRQOVER_8h_1aa752285ce9ddbde219d3d72a5bb3b169.html">Function RP2040::to_string(IO_BANK0_GPIO16_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO16__CTRL__OEOVER_8h_1a85d85de4048a05e24f7a3e75316b7621.html">Function RP2040::to_string(IO_BANK0_GPIO16_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO16__CTRL__OUTOVER_8h_1a712671c448fde6a17aefce9936233314.html">Function RP2040::to_string(IO_BANK0_GPIO16_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO17__CTRL__FUNCSEL_8h_1a78dc7f846f964e72a34a4681d5aeda90.html">Function RP2040::to_string(IO_BANK0_GPIO17_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO17__CTRL__INOVER_8h_1a045a6b729b8e92b16d504ee561edf4f6.html">Function RP2040::to_string(IO_BANK0_GPIO17_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO17__CTRL__IRQOVER_8h_1a6114791857f6de83858c059e07e7ffd5.html">Function RP2040::to_string(IO_BANK0_GPIO17_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO17__CTRL__OEOVER_8h_1a187a6ac6be70c26d06701f607b535ec1.html">Function RP2040::to_string(IO_BANK0_GPIO17_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO17__CTRL__OUTOVER_8h_1a60d4431ee229685922a87c5611ff0cd0.html">Function RP2040::to_string(IO_BANK0_GPIO17_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO18__CTRL__FUNCSEL_8h_1a0fda287f2546e61dd86a6086c1d4484b.html">Function RP2040::to_string(IO_BANK0_GPIO18_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO18__CTRL__INOVER_8h_1a7e778e8a1800246abf8a76c3dd255363.html">Function RP2040::to_string(IO_BANK0_GPIO18_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO18__CTRL__IRQOVER_8h_1a6d9d926b73d74051e70e834025b0a291.html">Function RP2040::to_string(IO_BANK0_GPIO18_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO18__CTRL__OEOVER_8h_1ae20aa85908be2a314ae017f03e5c5136.html">Function RP2040::to_string(IO_BANK0_GPIO18_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO18__CTRL__OUTOVER_8h_1a5bcbf5f53e5817495d3f72824478c2b2.html">Function RP2040::to_string(IO_BANK0_GPIO18_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO19__CTRL__FUNCSEL_8h_1acea5c5f3c36419a06ef8f2e4d19ad8b1.html">Function RP2040::to_string(IO_BANK0_GPIO19_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO19__CTRL__INOVER_8h_1abaafebbad9209ae1d6cbe63a93a01599.html">Function RP2040::to_string(IO_BANK0_GPIO19_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO19__CTRL__IRQOVER_8h_1ac03ce850ad1ceeb2ddf3348136941484.html">Function RP2040::to_string(IO_BANK0_GPIO19_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO19__CTRL__OEOVER_8h_1ab37f8d3b7873f783554339f83c3af0fb.html">Function RP2040::to_string(IO_BANK0_GPIO19_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO19__CTRL__OUTOVER_8h_1a2a1be8619856c062fd7d29e8ac3b9be1.html">Function RP2040::to_string(IO_BANK0_GPIO19_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO1__CTRL__FUNCSEL_8h_1a0f8fb02f79e64beb8c4fea92fec42f0d.html">Function RP2040::to_string(IO_BANK0_GPIO1_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO1__CTRL__INOVER_8h_1afb778c17a133897a4cd662a271f2b46f.html">Function RP2040::to_string(IO_BANK0_GPIO1_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO1__CTRL__IRQOVER_8h_1ae7b96064581ed7db8bc58a1f7c72998d.html">Function RP2040::to_string(IO_BANK0_GPIO1_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO1__CTRL__OEOVER_8h_1aa476f86c2ae3ac2e91cd18d24b2082e9.html">Function RP2040::to_string(IO_BANK0_GPIO1_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO1__CTRL__OUTOVER_8h_1ae0661df4e4f47b152605a091ac5bf1bc.html">Function RP2040::to_string(IO_BANK0_GPIO1_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO20__CTRL__FUNCSEL_8h_1a5041e03eb1b126e418522c097ad5b6f2.html">Function RP2040::to_string(IO_BANK0_GPIO20_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO20__CTRL__INOVER_8h_1a7af39354eb59d22065ab4cb7f6ea612f.html">Function RP2040::to_string(IO_BANK0_GPIO20_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO20__CTRL__IRQOVER_8h_1ae539f9febdabb223d6fb47196e669523.html">Function RP2040::to_string(IO_BANK0_GPIO20_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO20__CTRL__OEOVER_8h_1acd76f55debbf5edc21ea0a2fa6948e74.html">Function RP2040::to_string(IO_BANK0_GPIO20_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO20__CTRL__OUTOVER_8h_1ad41e90097595aa3d30ad66e73bd44d6c.html">Function RP2040::to_string(IO_BANK0_GPIO20_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO21__CTRL__FUNCSEL_8h_1a53c2214253de4c204cd70a9fffbd9914.html">Function RP2040::to_string(IO_BANK0_GPIO21_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO21__CTRL__INOVER_8h_1a502e16d53fa3420c0a0e740cf3ad347c.html">Function RP2040::to_string(IO_BANK0_GPIO21_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO21__CTRL__IRQOVER_8h_1a7e2d1190a815d51e6f02ff4ad14b62b6.html">Function RP2040::to_string(IO_BANK0_GPIO21_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO21__CTRL__OEOVER_8h_1ab1890637f9231ddde0ceb7ddb404d20e.html">Function RP2040::to_string(IO_BANK0_GPIO21_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO21__CTRL__OUTOVER_8h_1aef117aa85ad8a0c8616844d7118833bc.html">Function RP2040::to_string(IO_BANK0_GPIO21_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO22__CTRL__FUNCSEL_8h_1aec75e6910ad199267239d392f185e725.html">Function RP2040::to_string(IO_BANK0_GPIO22_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO22__CTRL__INOVER_8h_1a65c386899f0f72aa37b98f8119d3dc28.html">Function RP2040::to_string(IO_BANK0_GPIO22_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO22__CTRL__IRQOVER_8h_1ab8a0fab85491725a73f7214ecded7951.html">Function RP2040::to_string(IO_BANK0_GPIO22_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO22__CTRL__OEOVER_8h_1a3adf98ce0977970a697ceb18893c2fb0.html">Function RP2040::to_string(IO_BANK0_GPIO22_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO22__CTRL__OUTOVER_8h_1ab790a34e39d4453483767385b98d9df3.html">Function RP2040::to_string(IO_BANK0_GPIO22_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO23__CTRL__FUNCSEL_8h_1a3d0cad47b722cf5ff370251f1bb27dc7.html">Function RP2040::to_string(IO_BANK0_GPIO23_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO23__CTRL__INOVER_8h_1a36c68a343d79316bcfd550f0b89a45d7.html">Function RP2040::to_string(IO_BANK0_GPIO23_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO23__CTRL__IRQOVER_8h_1a97912749c6ade0bf8708054bc09c82ef.html">Function RP2040::to_string(IO_BANK0_GPIO23_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO23__CTRL__OEOVER_8h_1a9aeef7b18d057337274178f592dd7344.html">Function RP2040::to_string(IO_BANK0_GPIO23_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO23__CTRL__OUTOVER_8h_1ab4ed26468495b80877189e25186f48ab.html">Function RP2040::to_string(IO_BANK0_GPIO23_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO24__CTRL__FUNCSEL_8h_1ab0809ac55831810c5ae9c357b906f01f.html">Function RP2040::to_string(IO_BANK0_GPIO24_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO24__CTRL__INOVER_8h_1a830cb245af3e570a795452f0534fc881.html">Function RP2040::to_string(IO_BANK0_GPIO24_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO24__CTRL__IRQOVER_8h_1a69dd3b9d4a72ed20b62f0e36377c1f2f.html">Function RP2040::to_string(IO_BANK0_GPIO24_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO24__CTRL__OEOVER_8h_1ae8e53e72467fc0077058e67bce18c9b6.html">Function RP2040::to_string(IO_BANK0_GPIO24_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO24__CTRL__OUTOVER_8h_1a38f6925ae6df1fe796b564bea11c2874.html">Function RP2040::to_string(IO_BANK0_GPIO24_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO25__CTRL__FUNCSEL_8h_1a2f8faa7de48b7cd89c76639618dfd895.html">Function RP2040::to_string(IO_BANK0_GPIO25_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO25__CTRL__INOVER_8h_1aa97b6baef4ae0e4b762ea0b962291fbd.html">Function RP2040::to_string(IO_BANK0_GPIO25_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO25__CTRL__IRQOVER_8h_1a88368ca637cd62b9b7fd4e38cff830e7.html">Function RP2040::to_string(IO_BANK0_GPIO25_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO25__CTRL__OEOVER_8h_1a400df1bb3f8baad1b57c4527d61cab28.html">Function RP2040::to_string(IO_BANK0_GPIO25_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO25__CTRL__OUTOVER_8h_1a7d0d9c8c779fd8385a5eea48958fd4ea.html">Function RP2040::to_string(IO_BANK0_GPIO25_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO26__CTRL__FUNCSEL_8h_1adf10ba20c24fe75f2b84494cba17856c.html">Function RP2040::to_string(IO_BANK0_GPIO26_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO26__CTRL__INOVER_8h_1a3abd28aee9dbeb5e0ba8564e2d044066.html">Function RP2040::to_string(IO_BANK0_GPIO26_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO26__CTRL__IRQOVER_8h_1a5c3f353e3dc6aa6a7bcd2c4fe58bce62.html">Function RP2040::to_string(IO_BANK0_GPIO26_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO26__CTRL__OEOVER_8h_1a63c78502967b660498538cf33442ae3a.html">Function RP2040::to_string(IO_BANK0_GPIO26_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO26__CTRL__OUTOVER_8h_1a5107106e9c6209e365ad1a90db970728.html">Function RP2040::to_string(IO_BANK0_GPIO26_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO27__CTRL__FUNCSEL_8h_1ad59fc61f1bdb8351f3367433a03f653f.html">Function RP2040::to_string(IO_BANK0_GPIO27_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO27__CTRL__INOVER_8h_1ae38e0dec211ca3080428796c2c9ae1ce.html">Function RP2040::to_string(IO_BANK0_GPIO27_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO27__CTRL__IRQOVER_8h_1afdaf5b0c1ed9463a8583d52c17852942.html">Function RP2040::to_string(IO_BANK0_GPIO27_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO27__CTRL__OEOVER_8h_1ab8b362089e76b705f35846261d5cc4d3.html">Function RP2040::to_string(IO_BANK0_GPIO27_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO27__CTRL__OUTOVER_8h_1ac3e6457c5526de66415fd6dbe7811f06.html">Function RP2040::to_string(IO_BANK0_GPIO27_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO28__CTRL__FUNCSEL_8h_1adefd6a3643dd2dd07f44b1438828bb3e.html">Function RP2040::to_string(IO_BANK0_GPIO28_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO28__CTRL__INOVER_8h_1a2ad666f5dd6996dfbba2abf9a89d336f.html">Function RP2040::to_string(IO_BANK0_GPIO28_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO28__CTRL__IRQOVER_8h_1a36c98bc65a3ea767d0d4011ad568f32e.html">Function RP2040::to_string(IO_BANK0_GPIO28_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO28__CTRL__OEOVER_8h_1ad2467c11855407ee2637cc8811125d5b.html">Function RP2040::to_string(IO_BANK0_GPIO28_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO28__CTRL__OUTOVER_8h_1a8c2cb3646b4b26a93a70d690608f92b0.html">Function RP2040::to_string(IO_BANK0_GPIO28_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO29__CTRL__FUNCSEL_8h_1ae7b78652b53a0f1b0203a4071c5b8b4f.html">Function RP2040::to_string(IO_BANK0_GPIO29_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO29__CTRL__INOVER_8h_1a2e1a6c3153dd577ffeb650161fb025df.html">Function RP2040::to_string(IO_BANK0_GPIO29_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO29__CTRL__IRQOVER_8h_1a9a8a25ff7c983018181da9d2adcf3576.html">Function RP2040::to_string(IO_BANK0_GPIO29_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO29__CTRL__OEOVER_8h_1a3b612bf52eab6f55d6c342c9767ccc76.html">Function RP2040::to_string(IO_BANK0_GPIO29_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO29__CTRL__OUTOVER_8h_1af2ae016c9ae3a3b4c0802eb01bae82cf.html">Function RP2040::to_string(IO_BANK0_GPIO29_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO2__CTRL__FUNCSEL_8h_1ae704106571dd3dd4b6ac7f2b1b97ada9.html">Function RP2040::to_string(IO_BANK0_GPIO2_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO2__CTRL__INOVER_8h_1a42adaae640a7c7220243f55868c919f5.html">Function RP2040::to_string(IO_BANK0_GPIO2_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO2__CTRL__IRQOVER_8h_1a25f4039d5d52634f77161c3c8c950f94.html">Function RP2040::to_string(IO_BANK0_GPIO2_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO2__CTRL__OEOVER_8h_1aa7909ef985bfa5609e11725f2f1e0b20.html">Function RP2040::to_string(IO_BANK0_GPIO2_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO2__CTRL__OUTOVER_8h_1a88a21c7858197369f8c21e3d570baaed.html">Function RP2040::to_string(IO_BANK0_GPIO2_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO3__CTRL__FUNCSEL_8h_1a022e43393375297815f8d35f2645f43a.html">Function RP2040::to_string(IO_BANK0_GPIO3_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO3__CTRL__INOVER_8h_1a9f68b2b8f7eabe6b45a940554ea21e71.html">Function RP2040::to_string(IO_BANK0_GPIO3_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO3__CTRL__IRQOVER_8h_1a5380837f030e7b219cef673dc3ff3e18.html">Function RP2040::to_string(IO_BANK0_GPIO3_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO3__CTRL__OEOVER_8h_1aa471c6900b9105de299868b7b4262690.html">Function RP2040::to_string(IO_BANK0_GPIO3_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO3__CTRL__OUTOVER_8h_1aba30425ecc1ba327bd694a0bdc9cca0b.html">Function RP2040::to_string(IO_BANK0_GPIO3_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO4__CTRL__FUNCSEL_8h_1a18795124dd1f06797093a2ed6099672d.html">Function RP2040::to_string(IO_BANK0_GPIO4_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO4__CTRL__INOVER_8h_1a74dcc1b85760850b21cf225f60b3056c.html">Function RP2040::to_string(IO_BANK0_GPIO4_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO4__CTRL__IRQOVER_8h_1a69177d82fc658ecdd4497a175d665fac.html">Function RP2040::to_string(IO_BANK0_GPIO4_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO4__CTRL__OEOVER_8h_1a6d8c92f52b65cdf14d9b84fa86a276e7.html">Function RP2040::to_string(IO_BANK0_GPIO4_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO4__CTRL__OUTOVER_8h_1a9ce7d04934b88d9c665e26bc52ba1e12.html">Function RP2040::to_string(IO_BANK0_GPIO4_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO5__CTRL__FUNCSEL_8h_1a5f560f49803dbaea67632360c5cc4463.html">Function RP2040::to_string(IO_BANK0_GPIO5_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO5__CTRL__INOVER_8h_1ae5842100f5d8f046b2fa8ff4f21b0b7c.html">Function RP2040::to_string(IO_BANK0_GPIO5_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO5__CTRL__IRQOVER_8h_1a87af62b85b780f8152dfc72944b0d6fb.html">Function RP2040::to_string(IO_BANK0_GPIO5_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO5__CTRL__OEOVER_8h_1a857b3c1151a6da2643de7fbf3528f860.html">Function RP2040::to_string(IO_BANK0_GPIO5_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO5__CTRL__OUTOVER_8h_1a211f968220cb08ae16909cc12222bc31.html">Function RP2040::to_string(IO_BANK0_GPIO5_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO6__CTRL__FUNCSEL_8h_1afe48ecd0eb698c3eee3a05a5e1112862.html">Function RP2040::to_string(IO_BANK0_GPIO6_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO6__CTRL__INOVER_8h_1a0f3ede0d740408282d20ce9a3a777026.html">Function RP2040::to_string(IO_BANK0_GPIO6_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO6__CTRL__IRQOVER_8h_1a22693ec0792dedbab9304692febb1642.html">Function RP2040::to_string(IO_BANK0_GPIO6_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO6__CTRL__OEOVER_8h_1ae43b39b5e1e50179559e917f116a21b5.html">Function RP2040::to_string(IO_BANK0_GPIO6_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO6__CTRL__OUTOVER_8h_1aa4d5c1b9fdb25a14a28b761e349f3618.html">Function RP2040::to_string(IO_BANK0_GPIO6_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO7__CTRL__FUNCSEL_8h_1aa0dc3d1e7b9773ae2c50f7ec8fe9707b.html">Function RP2040::to_string(IO_BANK0_GPIO7_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO7__CTRL__INOVER_8h_1a00b47a9e617fbd8d8f4781ea6c789b76.html">Function RP2040::to_string(IO_BANK0_GPIO7_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO7__CTRL__IRQOVER_8h_1ad60e4db7d15ed8dbbb2c15237fd35b7a.html">Function RP2040::to_string(IO_BANK0_GPIO7_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO7__CTRL__OEOVER_8h_1a217a937791d13b17161358f9d3bb260e.html">Function RP2040::to_string(IO_BANK0_GPIO7_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO7__CTRL__OUTOVER_8h_1a59ba9bd87a7a5b7121f9b64e7915b334.html">Function RP2040::to_string(IO_BANK0_GPIO7_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO8__CTRL__FUNCSEL_8h_1a320b61423911fde8f2f1b605468b5d2a.html">Function RP2040::to_string(IO_BANK0_GPIO8_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO8__CTRL__INOVER_8h_1a14d5386acf083759cef5c98dc2b0d28c.html">Function RP2040::to_string(IO_BANK0_GPIO8_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO8__CTRL__IRQOVER_8h_1aa7b9b2b7b42a4e9d77371576f3c26097.html">Function RP2040::to_string(IO_BANK0_GPIO8_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO8__CTRL__OEOVER_8h_1aeb6efbb46c8438ba812cc52cd1713a84.html">Function RP2040::to_string(IO_BANK0_GPIO8_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO8__CTRL__OUTOVER_8h_1a47f7d8bd44f9c2b6558e2e7b62620326.html">Function RP2040::to_string(IO_BANK0_GPIO8_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO9__CTRL__FUNCSEL_8h_1a26067e1aebb79a2d56464708fe311818.html">Function RP2040::to_string(IO_BANK0_GPIO9_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO9__CTRL__INOVER_8h_1aa38d0ba9b02ca490c95355217192b2bb.html">Function RP2040::to_string(IO_BANK0_GPIO9_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO9__CTRL__IRQOVER_8h_1affee589640df09763ce75ca49c50eea2.html">Function RP2040::to_string(IO_BANK0_GPIO9_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO9__CTRL__OEOVER_8h_1ac02279a72c399d21f391f5f63350b924.html">Function RP2040::to_string(IO_BANK0_GPIO9_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__BANK0__GPIO9__CTRL__OUTOVER_8h_1a2d42f87bcd36ca539af5c5c9800bfbc5.html">Function RP2040::to_string(IO_BANK0_GPIO9_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SCLK__CTRL__FUNCSEL_8h_1a8d8b03cd096b2871b5e16cfb0898e972.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SCLK__CTRL__INOVER_8h_1a48a82819fc7fd136dafb9761e317a72d.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SCLK__CTRL__IRQOVER_8h_1a7f1cf09d4f52141be55c3c3b07e14668.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SCLK__CTRL__OEOVER_8h_1aab7dca478e8c1d81295814aa75191dad.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SCLK__CTRL__OUTOVER_8h_1ae22a355f1e258a94c8f2b94668b03171.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD0__CTRL__FUNCSEL_8h_1a94bad3ae13010a42f6b6532b94ddd574.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD0__CTRL__INOVER_8h_1a5818ac5663e5d224ff0e963d06381a31.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD0__CTRL__IRQOVER_8h_1af1cb069436f5cdeb31af471812e2dfd2.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD0__CTRL__OEOVER_8h_1aa2d0f513ecfa95db82df9363c86a10f6.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD0__CTRL__OUTOVER_8h_1a0fa0ca6f2f2fb59137a7e1005a104500.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD1__CTRL__FUNCSEL_8h_1abb5354e60bf9cc3eb307b3e38b27631b.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD1__CTRL__INOVER_8h_1a2dff5cb7922db00328ee6916ae143c67.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD1__CTRL__IRQOVER_8h_1a2fdcb30dce27428ecd637dca8d890c49.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD1__CTRL__OEOVER_8h_1a0d0ba1022f6d913dbfec68d20b46b3cc.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD1__CTRL__OUTOVER_8h_1a9b2dfaa1daec7bdf31c56005eecf6ed5.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD2__CTRL__FUNCSEL_8h_1a5be9abb57b98c76874439e3f724b6148.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD2__CTRL__INOVER_8h_1aaad4135028b26e19cb01d133ba5566a9.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD2__CTRL__IRQOVER_8h_1a1cdaa5fe591325c9803eb5f01cb42b33.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD2__CTRL__OEOVER_8h_1a9333ff5693995cb7d911af46a1ac7eae.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD2__CTRL__OUTOVER_8h_1a72ef153a0ecebcd4c7fbf637333ad5e7.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD3__CTRL__FUNCSEL_8h_1a64b63cc2ad36e5f5d453987481408217.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD3__CTRL__INOVER_8h_1a6b9faf802b41f65dcf1dc40898a09f06.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD3__CTRL__IRQOVER_8h_1ab4dc6210df60451ac58255e76a9fb611.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD3__CTRL__OEOVER_8h_1a429ebcebf814101b3c4df2867d47a136.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SD3__CTRL__OUTOVER_8h_1a1b596187166a360c12b0c9f3ab0418c3.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SS__CTRL__FUNCSEL_8h_1ae032b1914d933e29be7522ab0cccc174.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SS__CTRL__INOVER_8h_1a69ac4c6e8a49d0a3417fa0a2915c4e77.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SS__CTRL__IRQOVER_8h_1a912d71a65a4177d2db945648cf98a115.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SS__CTRL__OEOVER_8h_1acf048008fb2d73a43389494b399a650a.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_IO__QSPI__GPIO__QSPI__SS__CTRL__OUTOVER_8h_1a65e3bc188c879f3db849b37f7533023f.html">Function RP2040::to_string(IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO0__DRIVE_8h_1a2678f03155e0a24bd3f60375877cce1b.html">Function RP2040::to_string(PADS_BANK0_GPIO0_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO10__DRIVE_8h_1a3f1dc407bd954512a3ac9135380a0fbe.html">Function RP2040::to_string(PADS_BANK0_GPIO10_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO11__DRIVE_8h_1ad8c360e10ad1e56c21584d47f007a223.html">Function RP2040::to_string(PADS_BANK0_GPIO11_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO12__DRIVE_8h_1a32c751fa998ef0a2d5e7a971889ac966.html">Function RP2040::to_string(PADS_BANK0_GPIO12_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO13__DRIVE_8h_1adeaaaef166a341d293c623fa748c2078.html">Function RP2040::to_string(PADS_BANK0_GPIO13_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO14__DRIVE_8h_1acc0f8c58b9312176ae26308a7edaa62a.html">Function RP2040::to_string(PADS_BANK0_GPIO14_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO15__DRIVE_8h_1a0b7568d6481d34788e28f6598cc140f0.html">Function RP2040::to_string(PADS_BANK0_GPIO15_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO16__DRIVE_8h_1aed3670423b4bd02b9b434b78203b1d39.html">Function RP2040::to_string(PADS_BANK0_GPIO16_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO17__DRIVE_8h_1aec722c1761d0802e439f021a143c5f16.html">Function RP2040::to_string(PADS_BANK0_GPIO17_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO18__DRIVE_8h_1ac8d783a13a701cd00b1cc8780decb29d.html">Function RP2040::to_string(PADS_BANK0_GPIO18_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO19__DRIVE_8h_1ac3b254b3e1fd68df8ac2290d0298445a.html">Function RP2040::to_string(PADS_BANK0_GPIO19_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO1__DRIVE_8h_1aad4a2d752c8afd3a3f3f304488b6f9e6.html">Function RP2040::to_string(PADS_BANK0_GPIO1_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO20__DRIVE_8h_1a1f3e26317746caa734ad5f02fec99a7c.html">Function RP2040::to_string(PADS_BANK0_GPIO20_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO21__DRIVE_8h_1ab0e148a0e73d0f41f53016d4d5bd8920.html">Function RP2040::to_string(PADS_BANK0_GPIO21_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO22__DRIVE_8h_1ae1eaf0ee2a9552b6eaf8f89a514ccad8.html">Function RP2040::to_string(PADS_BANK0_GPIO22_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO23__DRIVE_8h_1a35726aa12388327dbc3378cd5d4448d6.html">Function RP2040::to_string(PADS_BANK0_GPIO23_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO24__DRIVE_8h_1aa4d621259fd5d6820efeee7766c19d91.html">Function RP2040::to_string(PADS_BANK0_GPIO24_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO25__DRIVE_8h_1ae1640ed122c67ae7b91d7a03b0edbf36.html">Function RP2040::to_string(PADS_BANK0_GPIO25_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO26__DRIVE_8h_1a08193d8f3c03d93f9ad2d73a8f69d02a.html">Function RP2040::to_string(PADS_BANK0_GPIO26_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO27__DRIVE_8h_1afe484f5f0434258dd0749cf188bcd7db.html">Function RP2040::to_string(PADS_BANK0_GPIO27_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO28__DRIVE_8h_1acedd99e4e2a363e7bd1b0b249e7c8893.html">Function RP2040::to_string(PADS_BANK0_GPIO28_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO29__DRIVE_8h_1a5e84c6f8639ac5181b2841cf6cc265de.html">Function RP2040::to_string(PADS_BANK0_GPIO29_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO2__DRIVE_8h_1aae0e4d62d451aa59af2a97716f5477fa.html">Function RP2040::to_string(PADS_BANK0_GPIO2_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO3__DRIVE_8h_1ad976e420b927f102fd49f393f395317e.html">Function RP2040::to_string(PADS_BANK0_GPIO3_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO4__DRIVE_8h_1af93dacb85c1b864f24aed04b4f32159e.html">Function RP2040::to_string(PADS_BANK0_GPIO4_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO5__DRIVE_8h_1a40e0bd34fa68f177b46109d225ede0a8.html">Function RP2040::to_string(PADS_BANK0_GPIO5_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO6__DRIVE_8h_1afcb3146e51791845a127dfc36b669c59.html">Function RP2040::to_string(PADS_BANK0_GPIO6_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO7__DRIVE_8h_1a5f5b49eea49c4b3af5ecfe852d5a22de.html">Function RP2040::to_string(PADS_BANK0_GPIO7_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO8__DRIVE_8h_1afd2aefbc974c016963cba382e38171b1.html">Function RP2040::to_string(PADS_BANK0_GPIO8_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__GPIO9__DRIVE_8h_1afcad9459086740af4d3118e494461ef7.html">Function RP2040::to_string(PADS_BANK0_GPIO9_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__SWCLK__DRIVE_8h_1a8cdfb757ef34c02b68e7abe56a02c352.html">Function RP2040::to_string(PADS_BANK0_SWCLK_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__BANK0__SWD__DRIVE_8h_1ad95af9758bf3aededd735795f693218c.html">Function RP2040::to_string(PADS_BANK0_SWD_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__QSPI__GPIO__QSPI__SCLK__DRIVE_8h_1a51779116a81f8f340288805811426fa7.html">Function RP2040::to_string(PADS_QSPI_GPIO_QSPI_SCLK_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__QSPI__GPIO__QSPI__SD0__DRIVE_8h_1af5a1633437094727305e2caccc9ad2a6.html">Function RP2040::to_string(PADS_QSPI_GPIO_QSPI_SD0_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__QSPI__GPIO__QSPI__SD1__DRIVE_8h_1a1d2fe99f38a5791b8672c3ccf32d0868.html">Function RP2040::to_string(PADS_QSPI_GPIO_QSPI_SD1_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__QSPI__GPIO__QSPI__SD2__DRIVE_8h_1af94a9572789550c94c09ae3aa6b398c1.html">Function RP2040::to_string(PADS_QSPI_GPIO_QSPI_SD2_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__QSPI__GPIO__QSPI__SD3__DRIVE_8h_1a8519c6ba831ada70bf51fcf20ed9c51a.html">Function RP2040::to_string(PADS_QSPI_GPIO_QSPI_SD3_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PADS__QSPI__GPIO__QSPI__SS__DRIVE_8h_1a12b93649df9f025fd3104513a75c1451.html">Function RP2040::to_string(PADS_QSPI_GPIO_QSPI_SS_DRIVE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PWM__CH0__CSR__DIVMODE_8h_1a4ef002798e870ae30be0d63dc778963e.html">Function RP2040::to_string(PWM_CH0_CSR_DIVMODE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PWM__CH1__CSR__DIVMODE_8h_1a31526358cce5e7064adc1f1b6d5422c5.html">Function RP2040::to_string(PWM_CH1_CSR_DIVMODE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PWM__CH2__CSR__DIVMODE_8h_1a7de609df86d67646b8aab733c2af325a.html">Function RP2040::to_string(PWM_CH2_CSR_DIVMODE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PWM__CH3__CSR__DIVMODE_8h_1a12296ac9fe00cf96e827344e621f1b64.html">Function RP2040::to_string(PWM_CH3_CSR_DIVMODE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PWM__CH4__CSR__DIVMODE_8h_1ae2e7b7e82ac70dd22031d50c303cecfa.html">Function RP2040::to_string(PWM_CH4_CSR_DIVMODE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PWM__CH5__CSR__DIVMODE_8h_1a40bd0403ed6ef9916841dc5c0d9d0cac.html">Function RP2040::to_string(PWM_CH5_CSR_DIVMODE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PWM__CH6__CSR__DIVMODE_8h_1a1b7df6456d6d55dd99c832af395f7b0e.html">Function RP2040::to_string(PWM_CH6_CSR_DIVMODE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_PWM__CH7__CSR__DIVMODE_8h_1ab0459a5b1a3bfd28fe1a6f263bc33d35.html">Function RP2040::to_string(PWM_CH7_CSR_DIVMODE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_ROSC__CTRL__ENABLE_8h_1a303a1a8ff85995598870000ccfd29c6c.html">Function RP2040::to_string(ROSC_CTRL_ENABLE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_ROSC__CTRL__FREQ__RANGE_8h_1a9f314b39c43cc23d03c84e2538e22b79.html">Function RP2040::to_string(ROSC_CTRL_FREQ_RANGE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_ROSC__DIV__DIV_8h_1abfee971ca95dcd1e9fbc8516bd37cf67.html">Function RP2040::to_string(ROSC_DIV_DIV)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_ROSC__FREQA__PASSWD_8h_1a8b585b2980b8b6025e86ba7151f58791.html">Function RP2040::to_string(ROSC_FREQA_PASSWD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_ROSC__FREQB__PASSWD_8h_1a8b14933c40df91a38dd08439d23b9328.html">Function RP2040::to_string(ROSC_FREQB_PASSWD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP0__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a9bbd09f136b241e6486f223846804d68.html">Function RP2040::to_string(USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP0__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a0f5920223335d9b6c6e168ef239cf863.html">Function RP2040::to_string(USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP10__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a6c94b1a08f6c2cc6f5f2ea11f83c99cf.html">Function RP2040::to_string(USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP10__IN__CONTROL__ENDPOINT__TYPE_8h_1a24983afb3a7deba66758279f7e187330.html">Function RP2040::to_string(USBCTRL_DPRAM_EP10_IN_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP10__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a6394870bf36980b0dd01a211ab5e69ec.html">Function RP2040::to_string(USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP10__OUT__CONTROL__ENDPOINT__TYPE_8h_1a51bc23a3e1c021223a77fb12e062590a.html">Function RP2040::to_string(USBCTRL_DPRAM_EP10_OUT_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP11__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a752a990258b3ffa298ff9a1c1aaadddb.html">Function RP2040::to_string(USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP11__IN__CONTROL__ENDPOINT__TYPE_8h_1ab944e0bdefb0840d8bdb1738fd54291c.html">Function RP2040::to_string(USBCTRL_DPRAM_EP11_IN_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP11__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ab8b0030dd28184bd97dd23ac12355baf.html">Function RP2040::to_string(USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP11__OUT__CONTROL__ENDPOINT__TYPE_8h_1afea14c1232e96d968320a0390f79f38c.html">Function RP2040::to_string(USBCTRL_DPRAM_EP11_OUT_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP12__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a5ab8cf77610a82425e78af26b78eb26d.html">Function RP2040::to_string(USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP12__IN__CONTROL__ENDPOINT__TYPE_8h_1a01f41ac4e65981aafd8dd5843c8916e2.html">Function RP2040::to_string(USBCTRL_DPRAM_EP12_IN_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP12__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ab214650e9f112db3de1a4bd3e28f8918.html">Function RP2040::to_string(USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP12__OUT__CONTROL__ENDPOINT__TYPE_8h_1ad5a451315a446d11aec1fbee90cb5298.html">Function RP2040::to_string(USBCTRL_DPRAM_EP12_OUT_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP13__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ab2c1cf18d7f45ee18ae07731d0614c64.html">Function RP2040::to_string(USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP13__IN__CONTROL__ENDPOINT__TYPE_8h_1a04b546fd29af5eb442fcc0456f192b8b.html">Function RP2040::to_string(USBCTRL_DPRAM_EP13_IN_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP13__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1af66aa260d42db3a43efe7e4a7d33f599.html">Function RP2040::to_string(USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP13__OUT__CONTROL__ENDPOINT__TYPE_8h_1a190c415f86300606158430fe2a869ef8.html">Function RP2040::to_string(USBCTRL_DPRAM_EP13_OUT_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP14__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a7ff5513c875472c9ae7e044f60b3f5f3.html">Function RP2040::to_string(USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP14__IN__CONTROL__ENDPOINT__TYPE_8h_1aec1554a273769f9a0ac59339e9cb40ce.html">Function RP2040::to_string(USBCTRL_DPRAM_EP14_IN_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP14__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ad13c84cde75080c37ac67cffcac79a4d.html">Function RP2040::to_string(USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP14__OUT__CONTROL__ENDPOINT__TYPE_8h_1a47864fefcfdf0598bbea39e8bfd3c8cf.html">Function RP2040::to_string(USBCTRL_DPRAM_EP14_OUT_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP15__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a8d3fbb445ae7cc3db4b9f0a0a924ed6f.html">Function RP2040::to_string(USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP15__IN__CONTROL__ENDPOINT__TYPE_8h_1a134729f19c8facd6078ef0a2f7a5a9f2.html">Function RP2040::to_string(USBCTRL_DPRAM_EP15_IN_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP15__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1aa21cf8b206a114a6a259b33d8a435bb6.html">Function RP2040::to_string(USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP15__OUT__CONTROL__ENDPOINT__TYPE_8h_1aeca4882b21550042243a882e994bbed9.html">Function RP2040::to_string(USBCTRL_DPRAM_EP15_OUT_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP1__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1aa3f39cb0e240e45c273798b646620f21.html">Function RP2040::to_string(USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP1__IN__CONTROL__ENDPOINT__TYPE_8h_1a7e725d7b791aab4fac6e24f0e010777d.html">Function RP2040::to_string(USBCTRL_DPRAM_EP1_IN_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP1__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a521e844971aa60ad6718b819ebb09f28.html">Function RP2040::to_string(USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP1__OUT__CONTROL__ENDPOINT__TYPE_8h_1acac0ba32bdf3c8bafd8700de6b8422e5.html">Function RP2040::to_string(USBCTRL_DPRAM_EP1_OUT_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP2__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a76e1f7b0088a78133e5950b21c3e553f.html">Function RP2040::to_string(USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP2__IN__CONTROL__ENDPOINT__TYPE_8h_1ac356d4f26b749e01d91708e16475ff93.html">Function RP2040::to_string(USBCTRL_DPRAM_EP2_IN_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP2__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a0ec7586a00aba50bd695d79a07a70f46.html">Function RP2040::to_string(USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP2__OUT__CONTROL__ENDPOINT__TYPE_8h_1a76711027a53eaf23e0ddbc1c2da48903.html">Function RP2040::to_string(USBCTRL_DPRAM_EP2_OUT_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP3__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a6c70fc7c4982dc8de1b03b4f8be3d115.html">Function RP2040::to_string(USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP3__IN__CONTROL__ENDPOINT__TYPE_8h_1a812d720ab12c29aa617693a063f2a98f.html">Function RP2040::to_string(USBCTRL_DPRAM_EP3_IN_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP3__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a6eff69013c13a30d118a2bc5d321bedb.html">Function RP2040::to_string(USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP3__OUT__CONTROL__ENDPOINT__TYPE_8h_1a283de7b5a3818c61a0b486325ef05085.html">Function RP2040::to_string(USBCTRL_DPRAM_EP3_OUT_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP4__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1acc827c457bba807de0bd7c4a6a860a3c.html">Function RP2040::to_string(USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP4__IN__CONTROL__ENDPOINT__TYPE_8h_1ad5cf008d83850db235eed26b09f06829.html">Function RP2040::to_string(USBCTRL_DPRAM_EP4_IN_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP4__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ab35fcf9a09632cc30f4238e9a9fa0e31.html">Function RP2040::to_string(USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP4__OUT__CONTROL__ENDPOINT__TYPE_8h_1aa84a2df9b332258cb3446300dfb8d9e6.html">Function RP2040::to_string(USBCTRL_DPRAM_EP4_OUT_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP5__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a776a4a24535f97d56e41c644e6d61151.html">Function RP2040::to_string(USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP5__IN__CONTROL__ENDPOINT__TYPE_8h_1af425f234b94fedf23d380a278bc1f067.html">Function RP2040::to_string(USBCTRL_DPRAM_EP5_IN_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP5__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ae8d024b5e0e294103c8e45fe34f75f42.html">Function RP2040::to_string(USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP5__OUT__CONTROL__ENDPOINT__TYPE_8h_1aba5d0a5068327f80828ed40b6057b8c4.html">Function RP2040::to_string(USBCTRL_DPRAM_EP5_OUT_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP6__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ad760fc3221dbf740d11963335d040526.html">Function RP2040::to_string(USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP6__IN__CONTROL__ENDPOINT__TYPE_8h_1a695adf41639eb4c184930dced618d019.html">Function RP2040::to_string(USBCTRL_DPRAM_EP6_IN_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP6__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a5bf8b3ff947c2f5aa5d4e41d6c714cb0.html">Function RP2040::to_string(USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP6__OUT__CONTROL__ENDPOINT__TYPE_8h_1aeb14c46309ff339dbbf0be77e6171ca3.html">Function RP2040::to_string(USBCTRL_DPRAM_EP6_OUT_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP7__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1aeef48ff6c9efd44b80132032e6fc6765.html">Function RP2040::to_string(USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP7__IN__CONTROL__ENDPOINT__TYPE_8h_1a9d5a1a8c5d0ab2d824596dcec7a5baf4.html">Function RP2040::to_string(USBCTRL_DPRAM_EP7_IN_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP7__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ab40330f0596898fc8cbd6ebb0f34381a.html">Function RP2040::to_string(USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP7__OUT__CONTROL__ENDPOINT__TYPE_8h_1a30d9737dca658b4325f08fa7326fee53.html">Function RP2040::to_string(USBCTRL_DPRAM_EP7_OUT_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP8__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a6c892af7ab6fbb468c713468a867323b.html">Function RP2040::to_string(USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP8__IN__CONTROL__ENDPOINT__TYPE_8h_1a80c9f8dc0b76fd251496afeebae7d9b1.html">Function RP2040::to_string(USBCTRL_DPRAM_EP8_IN_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP8__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1ac7db27ed1b81400f7205d5ee539e427b.html">Function RP2040::to_string(USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP8__OUT__CONTROL__ENDPOINT__TYPE_8h_1aadca9d84c7790fcf95affdb81170825b.html">Function RP2040::to_string(USBCTRL_DPRAM_EP8_OUT_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP9__IN__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1a66a0ffe3a7bade161e40314f0d8aeb86.html">Function RP2040::to_string(USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP9__IN__CONTROL__ENDPOINT__TYPE_8h_1a51bd11add46e4d1365cd8db5843e39d5.html">Function RP2040::to_string(USBCTRL_DPRAM_EP9_IN_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP9__OUT__BUFFER__CONTROL__DOUBLE__BUFFER__ISO__OFFSET_8h_1af78d7d877580401c0bfdb98fb4593d94.html">Function RP2040::to_string(USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_USBCTRL__DPRAM__EP9__OUT__CONTROL__ENDPOINT__TYPE_8h_1adbf5be3bad57ea33a52d79b9e902c5d6.html">Function RP2040::to_string(USBCTRL_DPRAM_EP9_OUT_CONTROL_ENDPOINT_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_XIP__SSI__CTRLR0__SPI__FRF_8h_1a1c1b22432334801a566d0a26432beb7c.html">Function RP2040::to_string(XIP_SSI_CTRLR0_SPI_FRF)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_XIP__SSI__CTRLR0__TMOD_8h_1a209a6676d12f0030abcc3c781d01bb92.html">Function RP2040::to_string(XIP_SSI_CTRLR0_TMOD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_XIP__SSI__SPI__CTRLR0__INST__L_8h_1a4f68d533ece47bc709296d130d9cab58.html">Function RP2040::to_string(XIP_SSI_SPI_CTRLR0_INST_L)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_XIP__SSI__SPI__CTRLR0__TRANS__TYPE_8h_1a8485ac1040e82a75e13eb630e8892a15.html">Function RP2040::to_string(XIP_SSI_SPI_CTRLR0_TRANS_TYPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_XOSC__CTRL__ENABLE_8h_1a77475975061b754567fcd720d4980937.html">Function RP2040::to_string(XOSC_CTRL_ENABLE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_XOSC__CTRL__FREQ__RANGE_8h_1a85ed0a79c46c41eee377af216e32a731.html">Function RP2040::to_string(XOSC_CTRL_FREQ_RANGE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_XOSC__STATUS__FREQ__RANGE_8h_1a7d2f35161e60b8837c0ccfe6b3588a32.html">Function RP2040::to_string(XOSC_STATUS_FREQ_RANGE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_adc_8h_1a1d4de6bda11dc674b3b7d6ade2a32914.html">Variable RP2040::ADC</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_busctrl_8h_1a5a41b954cf1be08b08b1f07519f3c0b0.html">Variable RP2040::BUSCTRL</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_clocks_8h_1abfe36d0db3f02ce8363e425c3b938f6d.html">Variable RP2040::CLOCKS</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_dma_8h_1a9a524d0dc47b597b4cbb3e87f9d7ea7b.html">Variable RP2040::DMA</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_i2c0_8h_1af5eeb86f61c7e29616c45ecfb56bb7fd.html">Variable RP2040::I2C0</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_i2c0_8h_1a53042ce2527d6166a4438ec7bbac5e3d.html">Variable RP2040::I2C1</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_io__bank0_8h_1ae2f90a6ca266de82dadf0691fa714dc6.html">Variable RP2040::IO_BANK0</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_io__qspi_8h_1aed84253c950672b80830eb54707a47e4.html">Variable RP2040::IO_QSPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_pads__bank0_8h_1a285973dfe266fffe0701d41f84d049d8.html">Variable RP2040::PADS_BANK0</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_pads__qspi_8h_1a83ec6aef28f8772c448f2c396e5e6dda.html">Variable RP2040::PADS_QSPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_pio0_8h_1aea963fba5059ce1d7e0cde23daf81c48.html">Variable RP2040::PIO0</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_pio0_8h_1a5dded31cbe3b29ddfd4b706c5e721fea.html">Variable RP2040::PIO1</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_pll__sys_8h_1aa153e8c0d55b5b5c68530af75f80656c.html">Variable RP2040::PLL_SYS</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_pll__sys_8h_1a523b3e17074bcc779d524c90832dfdcf.html">Variable RP2040::PLL_USB</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_ppb_8h_1a3a6b87deb62e990b9fd2ec86f591cf8d.html">Variable RP2040::PPB</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_psm_8h_1a7bab85efe46533f505e53b05424c63a4.html">Variable RP2040::PSM</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_pwm_8h_1aca390d4f6b5076074bd006c3fa1eb69a.html">Variable RP2040::PWM</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_resets_8h_1afd721b2810df1577ff2814f80791d33a.html">Variable RP2040::RESETS</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_rosc_8h_1ac2a09fffd3d1db9fb04c94216a5ca4fe.html">Variable RP2040::ROSC</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_rtc_8h_1a8484a1ea4d64efd9da6c009c834935f5.html">Variable RP2040::RTC</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_sio_8h_1a340dc660911d8373c114eeaaac0903a2.html">Variable RP2040::SIO</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_spi0_8h_1a2129afee86f2a72d21a6a259a2b1c4a0.html">Variable RP2040::SPI0</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_spi0_8h_1a96f1d3514cd3886d4fb013c96510e912.html">Variable RP2040::SPI1</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_syscfg_8h_1a9ff7f1a9fba56cf8980f545c2f76bb38.html">Variable RP2040::SYSCFG</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_sysinfo_8h_1a7100f052e69cfa90b35e9549e1e04ae8.html">Variable RP2040::SYSINFO</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_tbman_8h_1a933ab585dea19f1832e146d4e8dd81de.html">Variable RP2040::TBMAN</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_timer_8h_1a082ac41590c7bc2c77fc24c41c54983d.html">Variable RP2040::TIMER</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_uart0_8h_1aa69c84f31571e585394bb62254b01b96.html">Variable RP2040::UART0</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_uart0_8h_1aca88fe221455091cffdb2bf9bb768559.html">Variable RP2040::UART1</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_usbctrl__dpram_8h_1a91397ada2714c964aa8d61009d5442c1.html">Variable RP2040::USBCTRL_DPRAM</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_usbctrl__regs_8h_1a4f6ff4ecaecd1f719344a5b0d5c02da1.html">Variable RP2040::USBCTRL_REGS</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_vreg__and__chip__reset_8h_1a5d42e304b0365812798df16fe8f8d370.html">Variable RP2040::VREG_AND_CHIP_RESET</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_watchdog_8h_1a0d21fe7c8d57e3c2d75f5f8acff5a2c0.html">Variable RP2040::WATCHDOG</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_xip__ctrl_8h_1aa0d007ea13e7d8a5d9b5ed404e18f603.html">Variable RP2040::XIP_CTRL</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_xip__ssi_8h_1a1c87d50eacd8e8cd31b69d0858e7094b.html">Variable RP2040::XIP_SSI</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable_xosc_8h_1a1501d9bf722d97cef0600a0fd300bab8.html">Variable RP2040::XOSC</a></li>
<li class="toctree-l2"><a class="reference internal" href="typedef_common_8h_1a039b662ae926d72b2114688f6e7b6612.html">Typedef RP2040::byte_array</a></li>
<li class="toctree-l2"><a class="reference internal" href="typedef_common_8h_1ab6003b08f24d1fb81d0d62dcd916fb64.html">Typedef RP2040::byte_istream</a></li>
<li class="toctree-l2"><a class="reference internal" href="typedef_common_8h_1a7da87a6a71a84074bbefc893bb657fe3.html">Typedef RP2040::byte_ostream</a></li>
<li class="toctree-l2"><a class="reference internal" href="typedef_common_8h_1a4258d1f4583893fe90c7b18aa972f3e7.html">Typedef RP2040::byte_span</a></li>
<li class="toctree-l2"><a class="reference internal" href="typedef_common_8h_1acd5068cec5be794f01d3f0d7bec6d0b3.html">Typedef RP2040::byte_spanbuf</a></li>
<li class="toctree-l2"><a class="reference internal" href="typedef_common_8h_1a69a2fa9eb10e155d7f18ceabd0456ab7.html">Typedef RP2040::byte_spanstream</a></li>
</ul>
</li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/generated/structRP2040_1_1i2c0.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Struct i2c0</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#struct-documentation">Struct Documentation</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section id="struct-i2c0">
<span id="exhale-struct-structrp2040-1-1i2c0"></span><h1>Struct i2c0<a class="headerlink" href="#struct-i2c0" title="Permalink to this headline">#</a></h1>
<ul class="simple">
<li><p>Defined in <a class="reference internal" href="file_src_generated_structs_i2c0.h.html#file-src-generated-structs-i2c0-h"><span class="std std-ref">File i2c0.h</span></a></p></li>
</ul>
<section id="struct-documentation">
<h2>Struct Documentation<a class="headerlink" href="#struct-documentation" title="Permalink to this headline">#</a></h2>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c0E">
<span id="_CPPv3N6RP20404i2c0E"></span><span id="_CPPv2N6RP20404i2c0E"></span><span id="RP2040::i2c0"></span><span class="target" id="structRP2040_1_1i2c0"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c0</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c0E" title="Permalink to this definition">#</a><br /></dt>
<dd><p><p>DW_apb_i2c address block</p>
<p>List of configuration constants for the Synopsys I2C hardware (you may see references to these in I2C register header; these are</p>
<em>fixed</em><p>values, set at hardware design time):</p>
<p>IC_ULTRA_FAST_MODE ……………. 0x0</p>
<p>IC_UFM_TBUF_CNT_DEFAULT ……….. 0x8</p>
<p>IC_UFM_SCL_LOW_COUNT ………….. 0x0008</p>
<p>IC_UFM_SCL_HIGH_COUNT …………. 0x0006</p>
<p>IC_TX_TL …………………….. 0x0</p>
<p>IC_TX_CMD_BLOCK ………………. 0x1</p>
<p>IC_HAS_DMA …………………… 0x1</p>
<p>IC_HAS_ASYNC_FIFO …………….. 0x0</p>
<p>IC_SMBUS_ARP …………………. 0x0</p>
<p>IC_FIRST_DATA_BYTE_STATUS ……… 0x1</p>
<p>IC_INTR_IO …………………… 0x1</p>
<p>IC_MASTER_MODE ……………….. 0x1</p>
<p>IC_DEFAULT_ACK_GENERAL_CALL ……. 0x1</p>
<p>IC_INTR_POL ………………….. 0x1</p>
<p>IC_OPTIONAL_SAR ………………. 0x0</p>
<p>IC_DEFAULT_TAR_SLAVE_ADDR ……… 0x055</p>
<p>IC_DEFAULT_SLAVE_ADDR …………. 0x055</p>
<p>IC_DEFAULT_HS_SPKLEN ………….. 0x1</p>
<p>IC_FS_SCL_HIGH_COUNT ………….. 0x0006</p>
<p>IC_HS_SCL_LOW_COUNT …………… 0x0008</p>
<p>IC_DEVICE_ID_VALUE ……………. 0x0</p>
<p>IC_10BITADDR_MASTER …………… 0x0</p>
<p>IC_CLK_FREQ_OPTIMIZATION ………. 0x0</p>
<p>IC_DEFAULT_FS_SPKLEN ………….. 0x7</p>
<p>IC_ADD_ENCODED_PARAMS …………. 0x0</p>
<p>IC_DEFAULT_SDA_HOLD …………… 0x000001</p>
<p>IC_DEFAULT_SDA_SETUP ………….. 0x64</p>
<p>IC_AVOID_RX_FIFO_FLUSH_ON_TX_ABRT . 0x0</p>
<p>IC_CLOCK_PERIOD ………………. 100</p>
<p>IC_EMPTYFIFO_HOLD_MASTER_EN ……. 1</p>
<p>IC_RESTART_EN ………………… 0x1</p>
<p>IC_TX_CMD_BLOCK_DEFAULT ……….. 0x0</p>
<p>IC_BUS_CLEAR_FEATURE ………….. 0x0</p>
<p>IC_CAP_LOADING ……………….. 100</p>
<p>IC_FS_SCL_LOW_COUNT …………… 0x000d</p>
<p>APB_DATA_WIDTH ……………….. 32</p>
<p>IC_SDA_STUCK_TIMEOUT_DEFAULT …… 0xffffffff</p>
<p>IC_SLV_DATA_NACK_ONLY …………. 0x1</p>
<p>IC_10BITADDR_SLAVE ……………. 0x0</p>
<p>IC_CLK_TYPE ………………….. 0x0</p>
<p>IC_SMBUS_UDID_MSB …………….. 0x0</p>
<p>IC_SMBUS_SUSPEND_ALERT ………… 0x0</p>
<p>IC_HS_SCL_HIGH_COUNT ………….. 0x0006</p>
<p>IC_SLV_RESTART_DET_EN …………. 0x1</p>
<p>IC_SMBUS …………………….. 0x0</p>
<p>IC_OPTIONAL_SAR_DEFAULT ……….. 0x0</p>
<p>IC_PERSISTANT_SLV_ADDR_DEFAULT …. 0x0</p>
<p>IC_USE_COUNTS ………………… 0x0</p>
<p>IC_RX_BUFFER_DEPTH ……………. 16</p>
<p>IC_SCL_STUCK_TIMEOUT_DEFAULT …… 0xffffffff</p>
<p>IC_RX_FULL_HLD_BUS_EN …………. 0x1</p>
<p>IC_SLAVE_DISABLE ……………… 0x1</p>
<p>IC_RX_TL …………………….. 0x0</p>
<p>IC_DEVICE_ID …………………. 0x0</p>
<p>IC_HC_COUNT_VALUES ……………. 0x0</p>
<p>I2C_DYNAMIC_TAR_UPDATE ………… 0</p>
<p>IC_SMBUS_CLK_LOW_MEXT_DEFAULT ….. 0xffffffff</p>
<p>IC_SMBUS_CLK_LOW_SEXT_DEFAULT ….. 0xffffffff</p>
<p>IC_HS_MASTER_CODE …………….. 0x1</p>
<p>IC_SMBUS_RST_IDLE_CNT_DEFAULT ….. 0xffff</p>
<p>IC_SMBUS_UDID_LSB_DEFAULT ……… 0xffffffff</p>
<p>IC_SS_SCL_HIGH_COUNT ………….. 0x0028</p>
<p>IC_SS_SCL_LOW_COUNT …………… 0x002f</p>
<p>IC_MAX_SPEED_MODE …………….. 0x2</p>
<p>IC_STAT_FOR_CLK_STRETCH ……….. 0x0</p>
<p>IC_STOP_DET_IF_MASTER_ACTIVE …… 0x0</p>
<p>IC_DEFAULT_UFM_SPKLEN …………. 0x1</p>

 IC_TX_BUFFER_DEPTH ……………. 16 </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c022get_IC_CON_MASTER_MODEEv">
<span id="_CPPv3NV6RP20404i2c022get_IC_CON_MASTER_MODEEv"></span><span id="_CPPv2NV6RP20404i2c022get_IC_CON_MASTER_MODEEv"></span><span id="RP2040::i2c0::get_IC_CON_MASTER_MODEV"></span><span class="target" id="structRP2040_1_1i2c0_1a2c31f5c6e0d3d4f5a923a36fe0e1f408"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CON_MASTER_MODE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c022get_IC_CON_MASTER_MODEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CON’s MASTER_MODE bit.</p>
<p><p>This bit controls whether the DW_apb_i2c master is enabled.</p>
<p>NOTE: Software should ensure that if this bit is written with ‘1’ then bit 6 should also be written with a ‘1’.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c022set_IC_CON_MASTER_MODEEv">
<span id="_CPPv3NV6RP20404i2c022set_IC_CON_MASTER_MODEEv"></span><span id="_CPPv2NV6RP20404i2c022set_IC_CON_MASTER_MODEEv"></span><span id="RP2040::i2c0::set_IC_CON_MASTER_MODEV"></span><span class="target" id="structRP2040_1_1i2c0_1a8dfffadb852d19b7a3fb4cf802638b67"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_CON_MASTER_MODE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c022set_IC_CON_MASTER_MODEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_CON’s MASTER_MODE bit.</p>
<p><p>This bit controls whether the DW_apb_i2c master is enabled.</p>
<p>NOTE: Software should ensure that if this bit is written with ‘1’ then bit 6 should also be written with a ‘1’.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c024clear_IC_CON_MASTER_MODEEv">
<span id="_CPPv3NV6RP20404i2c024clear_IC_CON_MASTER_MODEEv"></span><span id="_CPPv2NV6RP20404i2c024clear_IC_CON_MASTER_MODEEv"></span><span id="RP2040::i2c0::clear_IC_CON_MASTER_MODEV"></span><span class="target" id="structRP2040_1_1i2c0_1ab110e00c53fc7a7d4a84d59e23988968"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_CON_MASTER_MODE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c024clear_IC_CON_MASTER_MODEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_CON’s MASTER_MODE bit.</p>
<p><p>This bit controls whether the DW_apb_i2c master is enabled.</p>
<p>NOTE: Software should ensure that if this bit is written with ‘1’ then bit 6 should also be written with a ‘1’.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c025toggle_IC_CON_MASTER_MODEEv">
<span id="_CPPv3NV6RP20404i2c025toggle_IC_CON_MASTER_MODEEv"></span><span id="_CPPv2NV6RP20404i2c025toggle_IC_CON_MASTER_MODEEv"></span><span id="RP2040::i2c0::toggle_IC_CON_MASTER_MODEV"></span><span class="target" id="structRP2040_1_1i2c0_1a1d4eebb361b0bfc3c0b3ed71653cb2cc"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_CON_MASTER_MODE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c025toggle_IC_CON_MASTER_MODEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_CON’s MASTER_MODE bit.</p>
<p><p>This bit controls whether the DW_apb_i2c master is enabled.</p>
<p>NOTE: Software should ensure that if this bit is written with ‘1’ then bit 6 should also be written with a ‘1’.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c016get_IC_CON_SPEEDEv">
<span id="_CPPv3NV6RP20404i2c016get_IC_CON_SPEEDEv"></span><span id="_CPPv2NV6RP20404i2c016get_IC_CON_SPEEDEv"></span><span id="RP2040::i2c0::get_IC_CON_SPEEDV"></span><span class="target" id="structRP2040_1_1i2c0_1a4b68a549d3995cee629a0de370a56707"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="enum_I2C0__IC__CON__SPEED_8h_1a6c7a1393cd969e5ac462e886b2102f60.html#_CPPv4N6RP204017I2C0_IC_CON_SPEEDE" title="RP2040::I2C0_IC_CON_SPEED"><span class="n"><span class="pre">I2C0_IC_CON_SPEED</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CON_SPEED</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c016get_IC_CON_SPEEDEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CON’s SPEED field.</p>
<p><p>These bits control at which speed the DW_apb_i2c operates; its setting is relevant only if one is operating the DW_apb_i2c in master mode. Hardware protects against illegal values being programmed by software. These bits must be programmed appropriately for slave mode also, as it is used to capture correct value of spike filter as per the speed mode.</p>
<p>This register should be programmed only with a value in the range of 1 to IC_MAX_SPEED_MODE; otherwise, hardware updates this register with the value of IC_MAX_SPEED_MODE.</p>
<p>1: standard mode (100 kbit/s)</p>
<p>2: fast mode (&lt;=400 kbit/s) or fast mode plus (&lt;=1000Kbit/s)</p>
<p>3: high speed mode (3.4 Mbit/s)</p>
<p>Note: This field is not applicable when IC_ULTRA_FAST_MODE=1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c016set_IC_CON_SPEEDE17I2C0_IC_CON_SPEED">
<span id="_CPPv3NV6RP20404i2c016set_IC_CON_SPEEDE17I2C0_IC_CON_SPEED"></span><span id="_CPPv2NV6RP20404i2c016set_IC_CON_SPEEDE17I2C0_IC_CON_SPEED"></span><span id="RP2040::i2c0::set_IC_CON_SPEED__I2C0_IC_CON_SPEEDV"></span><span class="target" id="structRP2040_1_1i2c0_1a5c2e06b51dae79576117a41cb6620f22"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_CON_SPEED</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="enum_I2C0__IC__CON__SPEED_8h_1a6c7a1393cd969e5ac462e886b2102f60.html#_CPPv4N6RP204017I2C0_IC_CON_SPEEDE" title="RP2040::I2C0_IC_CON_SPEED"><span class="n"><span class="pre">I2C0_IC_CON_SPEED</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c016set_IC_CON_SPEEDE17I2C0_IC_CON_SPEED" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_CON’s SPEED field.</p>
<p><p>These bits control at which speed the DW_apb_i2c operates; its setting is relevant only if one is operating the DW_apb_i2c in master mode. Hardware protects against illegal values being programmed by software. These bits must be programmed appropriately for slave mode also, as it is used to capture correct value of spike filter as per the speed mode.</p>
<p>This register should be programmed only with a value in the range of 1 to IC_MAX_SPEED_MODE; otherwise, hardware updates this register with the value of IC_MAX_SPEED_MODE.</p>
<p>1: standard mode (100 kbit/s)</p>
<p>2: fast mode (&lt;=400 kbit/s) or fast mode plus (&lt;=1000Kbit/s)</p>
<p>3: high speed mode (3.4 Mbit/s)</p>
<p>Note: This field is not applicable when IC_ULTRA_FAST_MODE=1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029get_IC_CON_IC_10BITADDR_SLAVEEv">
<span id="_CPPv3NV6RP20404i2c029get_IC_CON_IC_10BITADDR_SLAVEEv"></span><span id="_CPPv2NV6RP20404i2c029get_IC_CON_IC_10BITADDR_SLAVEEv"></span><span id="RP2040::i2c0::get_IC_CON_IC_10BITADDR_SLAVEV"></span><span class="target" id="structRP2040_1_1i2c0_1a5e7b3e7feeccf30f42fe796dfa782159"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CON_IC_10BITADDR_SLAVE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029get_IC_CON_IC_10BITADDR_SLAVEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CON’s IC_10BITADDR_SLAVE bit.</p>
<p>When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit addressing transfers that match the full 10 bits of the IC_SAR register. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029set_IC_CON_IC_10BITADDR_SLAVEEv">
<span id="_CPPv3NV6RP20404i2c029set_IC_CON_IC_10BITADDR_SLAVEEv"></span><span id="_CPPv2NV6RP20404i2c029set_IC_CON_IC_10BITADDR_SLAVEEv"></span><span id="RP2040::i2c0::set_IC_CON_IC_10BITADDR_SLAVEV"></span><span class="target" id="structRP2040_1_1i2c0_1ade31b585f2f2ffa8b06c32a00138dd18"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_CON_IC_10BITADDR_SLAVE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029set_IC_CON_IC_10BITADDR_SLAVEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_CON’s IC_10BITADDR_SLAVE bit.</p>
<p>When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit addressing transfers that match the full 10 bits of the IC_SAR register. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c031clear_IC_CON_IC_10BITADDR_SLAVEEv">
<span id="_CPPv3NV6RP20404i2c031clear_IC_CON_IC_10BITADDR_SLAVEEv"></span><span id="_CPPv2NV6RP20404i2c031clear_IC_CON_IC_10BITADDR_SLAVEEv"></span><span id="RP2040::i2c0::clear_IC_CON_IC_10BITADDR_SLAVEV"></span><span class="target" id="structRP2040_1_1i2c0_1a5717ce431190638464ab4b536a275f91"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_CON_IC_10BITADDR_SLAVE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c031clear_IC_CON_IC_10BITADDR_SLAVEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_CON’s IC_10BITADDR_SLAVE bit.</p>
<p>When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit addressing transfers that match the full 10 bits of the IC_SAR register. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c032toggle_IC_CON_IC_10BITADDR_SLAVEEv">
<span id="_CPPv3NV6RP20404i2c032toggle_IC_CON_IC_10BITADDR_SLAVEEv"></span><span id="_CPPv2NV6RP20404i2c032toggle_IC_CON_IC_10BITADDR_SLAVEEv"></span><span id="RP2040::i2c0::toggle_IC_CON_IC_10BITADDR_SLAVEV"></span><span class="target" id="structRP2040_1_1i2c0_1a7dc490a814f062702acfd19917a08635"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_CON_IC_10BITADDR_SLAVE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c032toggle_IC_CON_IC_10BITADDR_SLAVEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_CON’s IC_10BITADDR_SLAVE bit.</p>
<p>When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit addressing transfers that match the full 10 bits of the IC_SAR register. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030get_IC_CON_IC_10BITADDR_MASTEREv">
<span id="_CPPv3NV6RP20404i2c030get_IC_CON_IC_10BITADDR_MASTEREv"></span><span id="_CPPv2NV6RP20404i2c030get_IC_CON_IC_10BITADDR_MASTEREv"></span><span id="RP2040::i2c0::get_IC_CON_IC_10BITADDR_MASTERV"></span><span class="target" id="structRP2040_1_1i2c0_1a7e1d2620614c729d483886fd5ce5a4a4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CON_IC_10BITADDR_MASTER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030get_IC_CON_IC_10BITADDR_MASTEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CON’s IC_10BITADDR_MASTER bit.</p>
<p>Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030set_IC_CON_IC_10BITADDR_MASTEREv">
<span id="_CPPv3NV6RP20404i2c030set_IC_CON_IC_10BITADDR_MASTEREv"></span><span id="_CPPv2NV6RP20404i2c030set_IC_CON_IC_10BITADDR_MASTEREv"></span><span id="RP2040::i2c0::set_IC_CON_IC_10BITADDR_MASTERV"></span><span class="target" id="structRP2040_1_1i2c0_1a28bf44dbf1b04c92b3e030f727566177"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_CON_IC_10BITADDR_MASTER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030set_IC_CON_IC_10BITADDR_MASTEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_CON’s IC_10BITADDR_MASTER bit.</p>
<p>Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c032clear_IC_CON_IC_10BITADDR_MASTEREv">
<span id="_CPPv3NV6RP20404i2c032clear_IC_CON_IC_10BITADDR_MASTEREv"></span><span id="_CPPv2NV6RP20404i2c032clear_IC_CON_IC_10BITADDR_MASTEREv"></span><span id="RP2040::i2c0::clear_IC_CON_IC_10BITADDR_MASTERV"></span><span class="target" id="structRP2040_1_1i2c0_1a3dc05af90c1759c7e3c621ab99510268"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_CON_IC_10BITADDR_MASTER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c032clear_IC_CON_IC_10BITADDR_MASTEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_CON’s IC_10BITADDR_MASTER bit.</p>
<p>Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c033toggle_IC_CON_IC_10BITADDR_MASTEREv">
<span id="_CPPv3NV6RP20404i2c033toggle_IC_CON_IC_10BITADDR_MASTEREv"></span><span id="_CPPv2NV6RP20404i2c033toggle_IC_CON_IC_10BITADDR_MASTEREv"></span><span id="RP2040::i2c0::toggle_IC_CON_IC_10BITADDR_MASTERV"></span><span class="target" id="structRP2040_1_1i2c0_1a4772213db32dcdaab595ea55e8ce6430"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_CON_IC_10BITADDR_MASTER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c033toggle_IC_CON_IC_10BITADDR_MASTEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_CON’s IC_10BITADDR_MASTER bit.</p>
<p>Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c024get_IC_CON_IC_RESTART_ENEv">
<span id="_CPPv3NV6RP20404i2c024get_IC_CON_IC_RESTART_ENEv"></span><span id="_CPPv2NV6RP20404i2c024get_IC_CON_IC_RESTART_ENEv"></span><span id="RP2040::i2c0::get_IC_CON_IC_RESTART_ENV"></span><span class="target" id="structRP2040_1_1i2c0_1adb2145ceef21949c5bf2f8d343bd2752"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CON_IC_RESTART_EN</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c024get_IC_CON_IC_RESTART_ENEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CON’s IC_RESTART_EN bit.</p>
<p><p>Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several DW_apb_i2c operations. When RESTART is disabled, the master is prohibited from performing the following functions: - Sending a START BYTE - Performing any high-speed mode operation - High-speed mode operation - Performing direction changes in combined format mode - Performing a read operation with a 10-bit address By replacing RESTART condition followed by a STOP and a subsequent START condition, split operations are broken down into multiple DW_apb_i2c transfers. If the above operations are performed, it will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register.</p>
<p>Reset value: ENABLED</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c024set_IC_CON_IC_RESTART_ENEv">
<span id="_CPPv3NV6RP20404i2c024set_IC_CON_IC_RESTART_ENEv"></span><span id="_CPPv2NV6RP20404i2c024set_IC_CON_IC_RESTART_ENEv"></span><span id="RP2040::i2c0::set_IC_CON_IC_RESTART_ENV"></span><span class="target" id="structRP2040_1_1i2c0_1ac0e73a8764762626117feddfad8b9181"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_CON_IC_RESTART_EN</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c024set_IC_CON_IC_RESTART_ENEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_CON’s IC_RESTART_EN bit.</p>
<p><p>Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several DW_apb_i2c operations. When RESTART is disabled, the master is prohibited from performing the following functions: - Sending a START BYTE - Performing any high-speed mode operation - High-speed mode operation - Performing direction changes in combined format mode - Performing a read operation with a 10-bit address By replacing RESTART condition followed by a STOP and a subsequent START condition, split operations are broken down into multiple DW_apb_i2c transfers. If the above operations are performed, it will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register.</p>
<p>Reset value: ENABLED</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026clear_IC_CON_IC_RESTART_ENEv">
<span id="_CPPv3NV6RP20404i2c026clear_IC_CON_IC_RESTART_ENEv"></span><span id="_CPPv2NV6RP20404i2c026clear_IC_CON_IC_RESTART_ENEv"></span><span id="RP2040::i2c0::clear_IC_CON_IC_RESTART_ENV"></span><span class="target" id="structRP2040_1_1i2c0_1ab97e58e6f2a5b1470346d39fc03e4c90"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_CON_IC_RESTART_EN</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026clear_IC_CON_IC_RESTART_ENEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_CON’s IC_RESTART_EN bit.</p>
<p><p>Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several DW_apb_i2c operations. When RESTART is disabled, the master is prohibited from performing the following functions: - Sending a START BYTE - Performing any high-speed mode operation - High-speed mode operation - Performing direction changes in combined format mode - Performing a read operation with a 10-bit address By replacing RESTART condition followed by a STOP and a subsequent START condition, split operations are broken down into multiple DW_apb_i2c transfers. If the above operations are performed, it will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register.</p>
<p>Reset value: ENABLED</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027toggle_IC_CON_IC_RESTART_ENEv">
<span id="_CPPv3NV6RP20404i2c027toggle_IC_CON_IC_RESTART_ENEv"></span><span id="_CPPv2NV6RP20404i2c027toggle_IC_CON_IC_RESTART_ENEv"></span><span id="RP2040::i2c0::toggle_IC_CON_IC_RESTART_ENV"></span><span class="target" id="structRP2040_1_1i2c0_1a9e2072fecb650a297824a307117af7c7"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_CON_IC_RESTART_EN</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027toggle_IC_CON_IC_RESTART_ENEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_CON’s IC_RESTART_EN bit.</p>
<p><p>Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several DW_apb_i2c operations. When RESTART is disabled, the master is prohibited from performing the following functions: - Sending a START BYTE - Performing any high-speed mode operation - High-speed mode operation - Performing direction changes in combined format mode - Performing a read operation with a 10-bit address By replacing RESTART condition followed by a STOP and a subsequent START condition, split operations are broken down into multiple DW_apb_i2c transfers. If the above operations are performed, it will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register.</p>
<p>Reset value: ENABLED</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027get_IC_CON_IC_SLAVE_DISABLEEv">
<span id="_CPPv3NV6RP20404i2c027get_IC_CON_IC_SLAVE_DISABLEEv"></span><span id="_CPPv2NV6RP20404i2c027get_IC_CON_IC_SLAVE_DISABLEEv"></span><span id="RP2040::i2c0::get_IC_CON_IC_SLAVE_DISABLEV"></span><span class="target" id="structRP2040_1_1i2c0_1a279dad594ec12d54e193bc134ddba09f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CON_IC_SLAVE_DISABLE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027get_IC_CON_IC_SLAVE_DISABLEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CON’s IC_SLAVE_DISABLE bit.</p>
<p><p>This bit controls whether I2C has its slave disabled, which means once the presetn signal is applied, then this bit is set and the slave is disabled.</p>
<p>If this bit is set (slave is disabled), DW_apb_i2c functions only as a master and does not perform any action that requires a slave.</p>

 NOTE: Software should ensure that if this bit is written with 0, then bit 0 should also be written with a 0. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027set_IC_CON_IC_SLAVE_DISABLEEv">
<span id="_CPPv3NV6RP20404i2c027set_IC_CON_IC_SLAVE_DISABLEEv"></span><span id="_CPPv2NV6RP20404i2c027set_IC_CON_IC_SLAVE_DISABLEEv"></span><span id="RP2040::i2c0::set_IC_CON_IC_SLAVE_DISABLEV"></span><span class="target" id="structRP2040_1_1i2c0_1adec8c974123ff35796f36075116779dc"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_CON_IC_SLAVE_DISABLE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027set_IC_CON_IC_SLAVE_DISABLEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_CON’s IC_SLAVE_DISABLE bit.</p>
<p><p>This bit controls whether I2C has its slave disabled, which means once the presetn signal is applied, then this bit is set and the slave is disabled.</p>
<p>If this bit is set (slave is disabled), DW_apb_i2c functions only as a master and does not perform any action that requires a slave.</p>

 NOTE: Software should ensure that if this bit is written with 0, then bit 0 should also be written with a 0. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029clear_IC_CON_IC_SLAVE_DISABLEEv">
<span id="_CPPv3NV6RP20404i2c029clear_IC_CON_IC_SLAVE_DISABLEEv"></span><span id="_CPPv2NV6RP20404i2c029clear_IC_CON_IC_SLAVE_DISABLEEv"></span><span id="RP2040::i2c0::clear_IC_CON_IC_SLAVE_DISABLEV"></span><span class="target" id="structRP2040_1_1i2c0_1a437cc5c8d4b115c6f3cb71f6a3611131"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_CON_IC_SLAVE_DISABLE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029clear_IC_CON_IC_SLAVE_DISABLEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_CON’s IC_SLAVE_DISABLE bit.</p>
<p><p>This bit controls whether I2C has its slave disabled, which means once the presetn signal is applied, then this bit is set and the slave is disabled.</p>
<p>If this bit is set (slave is disabled), DW_apb_i2c functions only as a master and does not perform any action that requires a slave.</p>

 NOTE: Software should ensure that if this bit is written with 0, then bit 0 should also be written with a 0. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030toggle_IC_CON_IC_SLAVE_DISABLEEv">
<span id="_CPPv3NV6RP20404i2c030toggle_IC_CON_IC_SLAVE_DISABLEEv"></span><span id="_CPPv2NV6RP20404i2c030toggle_IC_CON_IC_SLAVE_DISABLEEv"></span><span id="RP2040::i2c0::toggle_IC_CON_IC_SLAVE_DISABLEV"></span><span class="target" id="structRP2040_1_1i2c0_1a97048260f312210aeaad6a16f432d4e6"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_CON_IC_SLAVE_DISABLE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030toggle_IC_CON_IC_SLAVE_DISABLEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_CON’s IC_SLAVE_DISABLE bit.</p>
<p><p>This bit controls whether I2C has its slave disabled, which means once the presetn signal is applied, then this bit is set and the slave is disabled.</p>
<p>If this bit is set (slave is disabled), DW_apb_i2c functions only as a master and does not perform any action that requires a slave.</p>

 NOTE: Software should ensure that if this bit is written with 0, then bit 0 should also be written with a 0. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c031get_IC_CON_STOP_DET_IFADDRESSEDEv">
<span id="_CPPv3NV6RP20404i2c031get_IC_CON_STOP_DET_IFADDRESSEDEv"></span><span id="_CPPv2NV6RP20404i2c031get_IC_CON_STOP_DET_IFADDRESSEDEv"></span><span id="RP2040::i2c0::get_IC_CON_STOP_DET_IFADDRESSEDV"></span><span class="target" id="structRP2040_1_1i2c0_1a8d1873180c546fc0df80ee3ba9bddca0"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CON_STOP_DET_IFADDRESSED</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c031get_IC_CON_STOP_DET_IFADDRESSEDEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CON’s STOP_DET_IFADDRESSED bit.</p>
<p><p>In slave mode: - 1’b1: issues the STOP_DET interrupt only when it is addressed. - 1’b0: issues the STOP_DET irrespective of whether it’s addressed or not. Reset value: 0x0</p>
<p>NOTE: During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1’b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR).</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c031set_IC_CON_STOP_DET_IFADDRESSEDEv">
<span id="_CPPv3NV6RP20404i2c031set_IC_CON_STOP_DET_IFADDRESSEDEv"></span><span id="_CPPv2NV6RP20404i2c031set_IC_CON_STOP_DET_IFADDRESSEDEv"></span><span id="RP2040::i2c0::set_IC_CON_STOP_DET_IFADDRESSEDV"></span><span class="target" id="structRP2040_1_1i2c0_1ae961dec352a5b3876fa8707aa80af967"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_CON_STOP_DET_IFADDRESSED</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c031set_IC_CON_STOP_DET_IFADDRESSEDEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_CON’s STOP_DET_IFADDRESSED bit.</p>
<p><p>In slave mode: - 1’b1: issues the STOP_DET interrupt only when it is addressed. - 1’b0: issues the STOP_DET irrespective of whether it’s addressed or not. Reset value: 0x0</p>
<p>NOTE: During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1’b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR).</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c033clear_IC_CON_STOP_DET_IFADDRESSEDEv">
<span id="_CPPv3NV6RP20404i2c033clear_IC_CON_STOP_DET_IFADDRESSEDEv"></span><span id="_CPPv2NV6RP20404i2c033clear_IC_CON_STOP_DET_IFADDRESSEDEv"></span><span id="RP2040::i2c0::clear_IC_CON_STOP_DET_IFADDRESSEDV"></span><span class="target" id="structRP2040_1_1i2c0_1a3ee1dd3ea7ac9c7e2d7e1b6770068892"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_CON_STOP_DET_IFADDRESSED</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c033clear_IC_CON_STOP_DET_IFADDRESSEDEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_CON’s STOP_DET_IFADDRESSED bit.</p>
<p><p>In slave mode: - 1’b1: issues the STOP_DET interrupt only when it is addressed. - 1’b0: issues the STOP_DET irrespective of whether it’s addressed or not. Reset value: 0x0</p>
<p>NOTE: During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1’b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR).</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c034toggle_IC_CON_STOP_DET_IFADDRESSEDEv">
<span id="_CPPv3NV6RP20404i2c034toggle_IC_CON_STOP_DET_IFADDRESSEDEv"></span><span id="_CPPv2NV6RP20404i2c034toggle_IC_CON_STOP_DET_IFADDRESSEDEv"></span><span id="RP2040::i2c0::toggle_IC_CON_STOP_DET_IFADDRESSEDV"></span><span class="target" id="structRP2040_1_1i2c0_1a148d9c0b67e1ee5edffe6ae0597aa0b9"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_CON_STOP_DET_IFADDRESSED</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c034toggle_IC_CON_STOP_DET_IFADDRESSEDEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_CON’s STOP_DET_IFADDRESSED bit.</p>
<p><p>In slave mode: - 1’b1: issues the STOP_DET interrupt only when it is addressed. - 1’b0: issues the STOP_DET irrespective of whether it’s addressed or not. Reset value: 0x0</p>
<p>NOTE: During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1’b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR).</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c024get_IC_CON_TX_EMPTY_CTRLEv">
<span id="_CPPv3NV6RP20404i2c024get_IC_CON_TX_EMPTY_CTRLEv"></span><span id="_CPPv2NV6RP20404i2c024get_IC_CON_TX_EMPTY_CTRLEv"></span><span id="RP2040::i2c0::get_IC_CON_TX_EMPTY_CTRLV"></span><span class="target" id="structRP2040_1_1i2c0_1a0e197b0665e835f7d9e7963b857a1a89"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CON_TX_EMPTY_CTRL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c024get_IC_CON_TX_EMPTY_CTRLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CON’s TX_EMPTY_CTRL bit.</p>
<p><p>This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.</p>
<p>Reset value: 0x0.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c024set_IC_CON_TX_EMPTY_CTRLEv">
<span id="_CPPv3NV6RP20404i2c024set_IC_CON_TX_EMPTY_CTRLEv"></span><span id="_CPPv2NV6RP20404i2c024set_IC_CON_TX_EMPTY_CTRLEv"></span><span id="RP2040::i2c0::set_IC_CON_TX_EMPTY_CTRLV"></span><span class="target" id="structRP2040_1_1i2c0_1abe795f88186893f73d778f614ad198f2"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_CON_TX_EMPTY_CTRL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c024set_IC_CON_TX_EMPTY_CTRLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_CON’s TX_EMPTY_CTRL bit.</p>
<p><p>This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.</p>
<p>Reset value: 0x0.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026clear_IC_CON_TX_EMPTY_CTRLEv">
<span id="_CPPv3NV6RP20404i2c026clear_IC_CON_TX_EMPTY_CTRLEv"></span><span id="_CPPv2NV6RP20404i2c026clear_IC_CON_TX_EMPTY_CTRLEv"></span><span id="RP2040::i2c0::clear_IC_CON_TX_EMPTY_CTRLV"></span><span class="target" id="structRP2040_1_1i2c0_1a64e60b0a11d68c7f616d48dbb289f55e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_CON_TX_EMPTY_CTRL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026clear_IC_CON_TX_EMPTY_CTRLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_CON’s TX_EMPTY_CTRL bit.</p>
<p><p>This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.</p>
<p>Reset value: 0x0.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027toggle_IC_CON_TX_EMPTY_CTRLEv">
<span id="_CPPv3NV6RP20404i2c027toggle_IC_CON_TX_EMPTY_CTRLEv"></span><span id="_CPPv2NV6RP20404i2c027toggle_IC_CON_TX_EMPTY_CTRLEv"></span><span id="RP2040::i2c0::toggle_IC_CON_TX_EMPTY_CTRLV"></span><span class="target" id="structRP2040_1_1i2c0_1aa2acf66f7b4cafb03f6b1f37819968e3"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_CON_TX_EMPTY_CTRL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027toggle_IC_CON_TX_EMPTY_CTRLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_CON’s TX_EMPTY_CTRL bit.</p>
<p><p>This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.</p>
<p>Reset value: 0x0.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c032get_IC_CON_RX_FIFO_FULL_HLD_CTRLEv">
<span id="_CPPv3NV6RP20404i2c032get_IC_CON_RX_FIFO_FULL_HLD_CTRLEv"></span><span id="_CPPv2NV6RP20404i2c032get_IC_CON_RX_FIFO_FULL_HLD_CTRLEv"></span><span id="RP2040::i2c0::get_IC_CON_RX_FIFO_FULL_HLD_CTRLV"></span><span class="target" id="structRP2040_1_1i2c0_1a5ff5f38610216854b018221daf6e957e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CON_RX_FIFO_FULL_HLD_CTRL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c032get_IC_CON_RX_FIFO_FULL_HLD_CTRLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CON’s RX_FIFO_FULL_HLD_CTRL bit.</p>
<p><p>This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH, as described in the IC_RX_FULL_HLD_BUS_EN parameter.</p>
<p>Reset value: 0x0.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c032set_IC_CON_RX_FIFO_FULL_HLD_CTRLEv">
<span id="_CPPv3NV6RP20404i2c032set_IC_CON_RX_FIFO_FULL_HLD_CTRLEv"></span><span id="_CPPv2NV6RP20404i2c032set_IC_CON_RX_FIFO_FULL_HLD_CTRLEv"></span><span id="RP2040::i2c0::set_IC_CON_RX_FIFO_FULL_HLD_CTRLV"></span><span class="target" id="structRP2040_1_1i2c0_1ad253689ad6fbc5bd72763837f468d0ff"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_CON_RX_FIFO_FULL_HLD_CTRL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c032set_IC_CON_RX_FIFO_FULL_HLD_CTRLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_CON’s RX_FIFO_FULL_HLD_CTRL bit.</p>
<p><p>This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH, as described in the IC_RX_FULL_HLD_BUS_EN parameter.</p>
<p>Reset value: 0x0.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c034clear_IC_CON_RX_FIFO_FULL_HLD_CTRLEv">
<span id="_CPPv3NV6RP20404i2c034clear_IC_CON_RX_FIFO_FULL_HLD_CTRLEv"></span><span id="_CPPv2NV6RP20404i2c034clear_IC_CON_RX_FIFO_FULL_HLD_CTRLEv"></span><span id="RP2040::i2c0::clear_IC_CON_RX_FIFO_FULL_HLD_CTRLV"></span><span class="target" id="structRP2040_1_1i2c0_1ab31d8781407ef423ab3b47f378bac314"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_CON_RX_FIFO_FULL_HLD_CTRL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c034clear_IC_CON_RX_FIFO_FULL_HLD_CTRLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_CON’s RX_FIFO_FULL_HLD_CTRL bit.</p>
<p><p>This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH, as described in the IC_RX_FULL_HLD_BUS_EN parameter.</p>
<p>Reset value: 0x0.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c035toggle_IC_CON_RX_FIFO_FULL_HLD_CTRLEv">
<span id="_CPPv3NV6RP20404i2c035toggle_IC_CON_RX_FIFO_FULL_HLD_CTRLEv"></span><span id="_CPPv2NV6RP20404i2c035toggle_IC_CON_RX_FIFO_FULL_HLD_CTRLEv"></span><span id="RP2040::i2c0::toggle_IC_CON_RX_FIFO_FULL_HLD_CTRLV"></span><span class="target" id="structRP2040_1_1i2c0_1a810b631dec60f70990ca2dd681ff1dfb"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_CON_RX_FIFO_FULL_HLD_CTRL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c035toggle_IC_CON_RX_FIFO_FULL_HLD_CTRLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_CON’s RX_FIFO_FULL_HLD_CTRL bit.</p>
<p><p>This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH, as described in the IC_RX_FULL_HLD_BUS_EN parameter.</p>
<p>Reset value: 0x0.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c036get_IC_CON_STOP_DET_IF_MASTER_ACTIVEEv">
<span id="_CPPv3NV6RP20404i2c036get_IC_CON_STOP_DET_IF_MASTER_ACTIVEEv"></span><span id="_CPPv2NV6RP20404i2c036get_IC_CON_STOP_DET_IF_MASTER_ACTIVEEv"></span><span id="RP2040::i2c0::get_IC_CON_STOP_DET_IF_MASTER_ACTIVEV"></span><span class="target" id="structRP2040_1_1i2c0_1ae55cf77e2716015d0107ae8c14b00def"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CON_STOP_DET_IF_MASTER_ACTIVE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c036get_IC_CON_STOP_DET_IF_MASTER_ACTIVEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CON’s STOP_DET_IF_MASTER_ACTIVE bit.</p>
<p>Master issues the STOP_DET interrupt irrespective of whether master is active or not </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c010get_IC_CONERbR17I2C0_IC_CON_SPEEDRbRbRbRbRbRbRbRb">
<span id="_CPPv3NV6RP20404i2c010get_IC_CONERbR17I2C0_IC_CON_SPEEDRbRbRbRbRbRbRbRb"></span><span id="_CPPv2NV6RP20404i2c010get_IC_CONERbR17I2C0_IC_CON_SPEEDRbRbRbRbRbRbRbRb"></span><span id="RP2040::i2c0::get_IC_CON__bR.I2C0_IC_CON_SPEEDR.bR.bR.bR.bR.bR.bR.bR.bRV"></span><span class="target" id="structRP2040_1_1i2c0_1a4aa87a4198ddbf47b484f412b7534d9c"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CON</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">MASTER_MODE</span></span>, <a class="reference internal" href="enum_I2C0__IC__CON__SPEED_8h_1a6c7a1393cd969e5ac462e886b2102f60.html#_CPPv4N6RP204017I2C0_IC_CON_SPEEDE" title="RP2040::I2C0_IC_CON_SPEED"><span class="n"><span class="pre">I2C0_IC_CON_SPEED</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">SPEED</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">IC_10BITADDR_SLAVE</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">IC_10BITADDR_MASTER</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">IC_RESTART_EN</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">IC_SLAVE_DISABLE</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">STOP_DET_IFADDRESSED</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">TX_EMPTY_CTRL</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">RX_FIFO_FULL_HLD_CTRL</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">STOP_DET_IF_MASTER_ACTIVE</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c010get_IC_CONERbR17I2C0_IC_CON_SPEEDRbRbRbRbRbRbRbRb" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get all of IC_CON’s bit fields.</p>
<p><p>(read-write) I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</p>
<p>Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are read only.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c010set_IC_CONEb17I2C0_IC_CON_SPEEDbbbbbbb">
<span id="_CPPv3NV6RP20404i2c010set_IC_CONEb17I2C0_IC_CON_SPEEDbbbbbbb"></span><span id="_CPPv2NV6RP20404i2c010set_IC_CONEb17I2C0_IC_CON_SPEEDbbbbbbb"></span><span id="RP2040::i2c0::set_IC_CON__b.I2C0_IC_CON_SPEED.b.b.b.b.b.b.bV"></span><span class="target" id="structRP2040_1_1i2c0_1abcc38a6b463f352512795f7faceb3e95"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_CON</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">MASTER_MODE</span></span>, <a class="reference internal" href="enum_I2C0__IC__CON__SPEED_8h_1a6c7a1393cd969e5ac462e886b2102f60.html#_CPPv4N6RP204017I2C0_IC_CON_SPEEDE" title="RP2040::I2C0_IC_CON_SPEED"><span class="n"><span class="pre">I2C0_IC_CON_SPEED</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">SPEED</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">IC_10BITADDR_SLAVE</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">IC_10BITADDR_MASTER</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">IC_RESTART_EN</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">IC_SLAVE_DISABLE</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">STOP_DET_IFADDRESSED</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">TX_EMPTY_CTRL</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">RX_FIFO_FULL_HLD_CTRL</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c010set_IC_CONEb17I2C0_IC_CON_SPEEDbbbbbbb" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set all of IC_CON’s bit fields.</p>
<p><p>(read-write) I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</p>
<p>Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are read only.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c017get_IC_TAR_IC_TAREv">
<span id="_CPPv3NV6RP20404i2c017get_IC_TAR_IC_TAREv"></span><span id="_CPPv2NV6RP20404i2c017get_IC_TAR_IC_TAREv"></span><span id="RP2040::i2c0::get_IC_TAR_IC_TARV"></span><span class="target" id="structRP2040_1_1i2c0_1ab7685aa124320ef0544070c2389e9a77"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TAR_IC_TAR</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c017get_IC_TAR_IC_TAREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TAR’s IC_TAR field.</p>
<p><p>This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.</p>
<p>If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c017set_IC_TAR_IC_TARE8uint16_t">
<span id="_CPPv3NV6RP20404i2c017set_IC_TAR_IC_TARE8uint16_t"></span><span id="_CPPv2NV6RP20404i2c017set_IC_TAR_IC_TARE8uint16_t"></span><span id="RP2040::i2c0::set_IC_TAR_IC_TAR__uint16_tV"></span><span class="target" id="structRP2040_1_1i2c0_1aa4f81cc361ed68dc7bc76a4fb5e75386"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_TAR_IC_TAR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c017set_IC_TAR_IC_TARE8uint16_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_TAR’s IC_TAR field.</p>
<p><p>This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.</p>
<p>If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c022get_IC_TAR_GC_OR_STARTEv">
<span id="_CPPv3NV6RP20404i2c022get_IC_TAR_GC_OR_STARTEv"></span><span id="_CPPv2NV6RP20404i2c022get_IC_TAR_GC_OR_STARTEv"></span><span id="RP2040::i2c0::get_IC_TAR_GC_OR_STARTV"></span><span class="target" id="structRP2040_1_1i2c0_1a9690c21bae463780bbe171b21a176f78"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TAR_GC_OR_START</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c022get_IC_TAR_GC_OR_STARTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TAR’s GC_OR_START bit.</p>
<p>If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit indicates whether a General Call or START byte command is to be performed by the DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c022set_IC_TAR_GC_OR_STARTEv">
<span id="_CPPv3NV6RP20404i2c022set_IC_TAR_GC_OR_STARTEv"></span><span id="_CPPv2NV6RP20404i2c022set_IC_TAR_GC_OR_STARTEv"></span><span id="RP2040::i2c0::set_IC_TAR_GC_OR_STARTV"></span><span class="target" id="structRP2040_1_1i2c0_1ae8d05d0837e159f3fd6b6839b5d478c7"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_TAR_GC_OR_START</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c022set_IC_TAR_GC_OR_STARTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_TAR’s GC_OR_START bit.</p>
<p>If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit indicates whether a General Call or START byte command is to be performed by the DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c024clear_IC_TAR_GC_OR_STARTEv">
<span id="_CPPv3NV6RP20404i2c024clear_IC_TAR_GC_OR_STARTEv"></span><span id="_CPPv2NV6RP20404i2c024clear_IC_TAR_GC_OR_STARTEv"></span><span id="RP2040::i2c0::clear_IC_TAR_GC_OR_STARTV"></span><span class="target" id="structRP2040_1_1i2c0_1a67f8a4a584ef4b3740ab9faf5bea2767"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_TAR_GC_OR_START</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c024clear_IC_TAR_GC_OR_STARTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_TAR’s GC_OR_START bit.</p>
<p>If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit indicates whether a General Call or START byte command is to be performed by the DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c025toggle_IC_TAR_GC_OR_STARTEv">
<span id="_CPPv3NV6RP20404i2c025toggle_IC_TAR_GC_OR_STARTEv"></span><span id="_CPPv2NV6RP20404i2c025toggle_IC_TAR_GC_OR_STARTEv"></span><span id="RP2040::i2c0::toggle_IC_TAR_GC_OR_STARTV"></span><span class="target" id="structRP2040_1_1i2c0_1a001cc401ea69f81586bbf6737dfcf934"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_TAR_GC_OR_START</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c025toggle_IC_TAR_GC_OR_STARTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_TAR’s GC_OR_START bit.</p>
<p>If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit indicates whether a General Call or START byte command is to be performed by the DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c018get_IC_TAR_SPECIALEv">
<span id="_CPPv3NV6RP20404i2c018get_IC_TAR_SPECIALEv"></span><span id="_CPPv2NV6RP20404i2c018get_IC_TAR_SPECIALEv"></span><span id="RP2040::i2c0::get_IC_TAR_SPECIALV"></span><span class="target" id="structRP2040_1_1i2c0_1ac623b4b03e7c68bb80a156ef2f5322c3"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TAR_SPECIAL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c018get_IC_TAR_SPECIALEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TAR’s SPECIAL bit.</p>
<p>This bit indicates whether software performs a Device-ID or General Call or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1: perform special I2C command as specified in Device_ID or GC_OR_START bit Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c018set_IC_TAR_SPECIALEv">
<span id="_CPPv3NV6RP20404i2c018set_IC_TAR_SPECIALEv"></span><span id="_CPPv2NV6RP20404i2c018set_IC_TAR_SPECIALEv"></span><span id="RP2040::i2c0::set_IC_TAR_SPECIALV"></span><span class="target" id="structRP2040_1_1i2c0_1acc1fe0f24b1582f96679a7ee1a197bad"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_TAR_SPECIAL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c018set_IC_TAR_SPECIALEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_TAR’s SPECIAL bit.</p>
<p>This bit indicates whether software performs a Device-ID or General Call or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1: perform special I2C command as specified in Device_ID or GC_OR_START bit Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c020clear_IC_TAR_SPECIALEv">
<span id="_CPPv3NV6RP20404i2c020clear_IC_TAR_SPECIALEv"></span><span id="_CPPv2NV6RP20404i2c020clear_IC_TAR_SPECIALEv"></span><span id="RP2040::i2c0::clear_IC_TAR_SPECIALV"></span><span class="target" id="structRP2040_1_1i2c0_1a1da75e77d1cc6e1b66019461628111b6"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_TAR_SPECIAL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c020clear_IC_TAR_SPECIALEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_TAR’s SPECIAL bit.</p>
<p>This bit indicates whether software performs a Device-ID or General Call or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1: perform special I2C command as specified in Device_ID or GC_OR_START bit Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c021toggle_IC_TAR_SPECIALEv">
<span id="_CPPv3NV6RP20404i2c021toggle_IC_TAR_SPECIALEv"></span><span id="_CPPv2NV6RP20404i2c021toggle_IC_TAR_SPECIALEv"></span><span id="RP2040::i2c0::toggle_IC_TAR_SPECIALV"></span><span class="target" id="structRP2040_1_1i2c0_1a5ecc9b91972908aefe0cdf954a99f116"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_TAR_SPECIAL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c021toggle_IC_TAR_SPECIALEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_TAR’s SPECIAL bit.</p>
<p>This bit indicates whether software performs a Device-ID or General Call or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1: perform special I2C command as specified in Device_ID or GC_OR_START bit Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c010get_IC_TARER8uint16_tRbRb">
<span id="_CPPv3NV6RP20404i2c010get_IC_TARER8uint16_tRbRb"></span><span id="_CPPv2NV6RP20404i2c010get_IC_TARER8uint16_tRbRb"></span><span id="RP2040::i2c0::get_IC_TAR__uint16_tR.bR.bRV"></span><span class="target" id="structRP2040_1_1i2c0_1ae2208deed1e4a08dcd4f15ff43821206"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TAR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">IC_TAR</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">GC_OR_START</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">SPECIAL</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c010get_IC_TARER8uint16_tRbRb" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get all of IC_TAR’s bit fields.</p>
<p><p>(read-write) I2C Target Address Register</p>
<p>This register is 12 bits wide, and bits 31:12 are reserved. This register can be written to only when IC_ENABLE[0] is set to 0.</p>

 Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any write to this register if DW_apb_i2c is enabled as an I2C slave only. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c010set_IC_TARE8uint16_tbb">
<span id="_CPPv3NV6RP20404i2c010set_IC_TARE8uint16_tbb"></span><span id="_CPPv2NV6RP20404i2c010set_IC_TARE8uint16_tbb"></span><span id="RP2040::i2c0::set_IC_TAR__uint16_t.b.bV"></span><span class="target" id="structRP2040_1_1i2c0_1a4172243faacdf2fbc3644e97b39c775e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_TAR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">IC_TAR</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">GC_OR_START</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">SPECIAL</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c010set_IC_TARE8uint16_tbb" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set all of IC_TAR’s bit fields.</p>
<p><p>(read-write) I2C Target Address Register</p>
<p>This register is 12 bits wide, and bits 31:12 are reserved. This register can be written to only when IC_ENABLE[0] is set to 0.</p>

 Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any write to this register if DW_apb_i2c is enabled as an I2C slave only. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c017get_IC_SAR_IC_SAREv">
<span id="_CPPv3NV6RP20404i2c017get_IC_SAR_IC_SAREv"></span><span id="_CPPv2NV6RP20404i2c017get_IC_SAR_IC_SAREv"></span><span id="RP2040::i2c0::get_IC_SAR_IC_SARV"></span><span class="target" id="structRP2040_1_1i2c0_1a61b6c5d5b047ac126b2132c7c45541c6"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_SAR_IC_SAR</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c017get_IC_SAR_IC_SAREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_SAR’s IC_SAR field.</p>
<p><p>The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used.</p>
<p>This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</p>

 Note: The default values cannot be any of the reserved address locations: that is, 0x00 to 0x07, or 0x78 to 0x7f. The correct operation of the device is not guaranteed if you program the IC_SAR or IC_TAR to a reserved value. Refer to &lt;&lt;table_I2C_firstbyte_bit_defs&gt;&gt; for a complete list of these reserved values. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c017set_IC_SAR_IC_SARE8uint16_t">
<span id="_CPPv3NV6RP20404i2c017set_IC_SAR_IC_SARE8uint16_t"></span><span id="_CPPv2NV6RP20404i2c017set_IC_SAR_IC_SARE8uint16_t"></span><span id="RP2040::i2c0::set_IC_SAR_IC_SAR__uint16_tV"></span><span class="target" id="structRP2040_1_1i2c0_1aa9fcdaeef9c5ab37e814e85f0beb76b1"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_SAR_IC_SAR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c017set_IC_SAR_IC_SARE8uint16_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_SAR’s IC_SAR field.</p>
<p><p>The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used.</p>
<p>This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</p>

 Note: The default values cannot be any of the reserved address locations: that is, 0x00 to 0x07, or 0x78 to 0x7f. The correct operation of the device is not guaranteed if you program the IC_SAR or IC_TAR to a reserved value. Refer to &lt;&lt;table_I2C_firstbyte_bit_defs&gt;&gt; for a complete list of these reserved values. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c019get_IC_DATA_CMD_DATEv">
<span id="_CPPv3NV6RP20404i2c019get_IC_DATA_CMD_DATEv"></span><span id="_CPPv2NV6RP20404i2c019get_IC_DATA_CMD_DATEv"></span><span id="RP2040::i2c0::get_IC_DATA_CMD_DATV"></span><span class="target" id="structRP2040_1_1i2c0_1af8ef92f4ad9bb3f1052f07ea20ef02a5"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_DATA_CMD_DAT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c019get_IC_DATA_CMD_DATEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_DATA_CMD’s DAT field.</p>
<p><p>This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the DW_apb_i2c. However, when you read this register, these bits return the value of data received on the DW_apb_i2c interface.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c019set_IC_DATA_CMD_DATE7uint8_t">
<span id="_CPPv3NV6RP20404i2c019set_IC_DATA_CMD_DATE7uint8_t"></span><span id="_CPPv2NV6RP20404i2c019set_IC_DATA_CMD_DATE7uint8_t"></span><span id="RP2040::i2c0::set_IC_DATA_CMD_DAT__uint8_tV"></span><span class="target" id="structRP2040_1_1i2c0_1a95c15b0d62f817c86a84adb3cb459333"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_DATA_CMD_DAT</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c019set_IC_DATA_CMD_DATE7uint8_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_DATA_CMD’s DAT field.</p>
<p><p>This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the DW_apb_i2c. However, when you read this register, these bits return the value of data received on the DW_apb_i2c interface.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c019get_IC_DATA_CMD_CMDEv">
<span id="_CPPv3NV6RP20404i2c019get_IC_DATA_CMD_CMDEv"></span><span id="_CPPv2NV6RP20404i2c019get_IC_DATA_CMD_CMDEv"></span><span id="RP2040::i2c0::get_IC_DATA_CMD_CMDV"></span><span class="target" id="structRP2040_1_1i2c0_1a2797771b6af84685793e1a8c477f44c7"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_DATA_CMD_CMD</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c019get_IC_DATA_CMD_CMDEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_DATA_CMD’s CMD bit.</p>
<p><p>This bit controls whether a read or a write is performed. This bit does not control the direction when the DW_apb_i2con acts as a slave. It controls only the direction when it acts as a master.</p>
<p>When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a ‘don’t care’ because writes to this register are not required. In slave-transmitter mode, a ‘0’ indicates that the data in IC_DATA_CMD is to be transmitted.</p>
<p>When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the IC_RAW_INTR_STAT register), unless bit 11 (SPECIAL) in the IC_TAR register has been cleared. If a ‘1’ is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c019set_IC_DATA_CMD_CMDEv">
<span id="_CPPv3NV6RP20404i2c019set_IC_DATA_CMD_CMDEv"></span><span id="_CPPv2NV6RP20404i2c019set_IC_DATA_CMD_CMDEv"></span><span id="RP2040::i2c0::set_IC_DATA_CMD_CMDV"></span><span class="target" id="structRP2040_1_1i2c0_1aabc49a42bcab6cdede5c69173e0340c2"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_DATA_CMD_CMD</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c019set_IC_DATA_CMD_CMDEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_DATA_CMD’s CMD bit.</p>
<p><p>This bit controls whether a read or a write is performed. This bit does not control the direction when the DW_apb_i2con acts as a slave. It controls only the direction when it acts as a master.</p>
<p>When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a ‘don’t care’ because writes to this register are not required. In slave-transmitter mode, a ‘0’ indicates that the data in IC_DATA_CMD is to be transmitted.</p>
<p>When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the IC_RAW_INTR_STAT register), unless bit 11 (SPECIAL) in the IC_TAR register has been cleared. If a ‘1’ is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c021clear_IC_DATA_CMD_CMDEv">
<span id="_CPPv3NV6RP20404i2c021clear_IC_DATA_CMD_CMDEv"></span><span id="_CPPv2NV6RP20404i2c021clear_IC_DATA_CMD_CMDEv"></span><span id="RP2040::i2c0::clear_IC_DATA_CMD_CMDV"></span><span class="target" id="structRP2040_1_1i2c0_1a1994f54a4b2b9ef38b502562fcbb27a3"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_DATA_CMD_CMD</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c021clear_IC_DATA_CMD_CMDEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_DATA_CMD’s CMD bit.</p>
<p><p>This bit controls whether a read or a write is performed. This bit does not control the direction when the DW_apb_i2con acts as a slave. It controls only the direction when it acts as a master.</p>
<p>When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a ‘don’t care’ because writes to this register are not required. In slave-transmitter mode, a ‘0’ indicates that the data in IC_DATA_CMD is to be transmitted.</p>
<p>When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the IC_RAW_INTR_STAT register), unless bit 11 (SPECIAL) in the IC_TAR register has been cleared. If a ‘1’ is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c022toggle_IC_DATA_CMD_CMDEv">
<span id="_CPPv3NV6RP20404i2c022toggle_IC_DATA_CMD_CMDEv"></span><span id="_CPPv2NV6RP20404i2c022toggle_IC_DATA_CMD_CMDEv"></span><span id="RP2040::i2c0::toggle_IC_DATA_CMD_CMDV"></span><span class="target" id="structRP2040_1_1i2c0_1a9b967c7622f1ce3dc97401324dee5b52"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_DATA_CMD_CMD</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c022toggle_IC_DATA_CMD_CMDEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_DATA_CMD’s CMD bit.</p>
<p><p>This bit controls whether a read or a write is performed. This bit does not control the direction when the DW_apb_i2con acts as a slave. It controls only the direction when it acts as a master.</p>
<p>When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a ‘don’t care’ because writes to this register are not required. In slave-transmitter mode, a ‘0’ indicates that the data in IC_DATA_CMD is to be transmitted.</p>
<p>When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the IC_RAW_INTR_STAT register), unless bit 11 (SPECIAL) in the IC_TAR register has been cleared. If a ‘1’ is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c020get_IC_DATA_CMD_STOPEv">
<span id="_CPPv3NV6RP20404i2c020get_IC_DATA_CMD_STOPEv"></span><span id="_CPPv2NV6RP20404i2c020get_IC_DATA_CMD_STOPEv"></span><span id="RP2040::i2c0::get_IC_DATA_CMD_STOPV"></span><span class="target" id="structRP2040_1_1i2c0_1ab55b2fcff9d07ae92ec550630eaab4dc"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_DATA_CMD_STOP</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c020get_IC_DATA_CMD_STOPEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_DATA_CMD’s STOP bit.</p>
<p>This bit controls whether a STOP is issued after the byte is sent or received.<ul class="simple">
<li><p>1 - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. - 0 - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. Reset value: 0x0 </p></li>
</ul>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c020set_IC_DATA_CMD_STOPEv">
<span id="_CPPv3NV6RP20404i2c020set_IC_DATA_CMD_STOPEv"></span><span id="_CPPv2NV6RP20404i2c020set_IC_DATA_CMD_STOPEv"></span><span id="RP2040::i2c0::set_IC_DATA_CMD_STOPV"></span><span class="target" id="structRP2040_1_1i2c0_1a8d6ea42abbc24d163f26ba341fab923b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_DATA_CMD_STOP</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c020set_IC_DATA_CMD_STOPEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_DATA_CMD’s STOP bit.</p>
<p>This bit controls whether a STOP is issued after the byte is sent or received.<ul class="simple">
<li><p>1 - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. - 0 - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. Reset value: 0x0 </p></li>
</ul>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c022clear_IC_DATA_CMD_STOPEv">
<span id="_CPPv3NV6RP20404i2c022clear_IC_DATA_CMD_STOPEv"></span><span id="_CPPv2NV6RP20404i2c022clear_IC_DATA_CMD_STOPEv"></span><span id="RP2040::i2c0::clear_IC_DATA_CMD_STOPV"></span><span class="target" id="structRP2040_1_1i2c0_1a20f917d6a4a4bc2bbf5bbd218a8df266"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_DATA_CMD_STOP</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c022clear_IC_DATA_CMD_STOPEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_DATA_CMD’s STOP bit.</p>
<p>This bit controls whether a STOP is issued after the byte is sent or received.<ul class="simple">
<li><p>1 - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. - 0 - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. Reset value: 0x0 </p></li>
</ul>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c023toggle_IC_DATA_CMD_STOPEv">
<span id="_CPPv3NV6RP20404i2c023toggle_IC_DATA_CMD_STOPEv"></span><span id="_CPPv2NV6RP20404i2c023toggle_IC_DATA_CMD_STOPEv"></span><span id="RP2040::i2c0::toggle_IC_DATA_CMD_STOPV"></span><span class="target" id="structRP2040_1_1i2c0_1a3b01226b09d8414953f9a8ad96dcf6ef"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_DATA_CMD_STOP</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c023toggle_IC_DATA_CMD_STOPEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_DATA_CMD’s STOP bit.</p>
<p>This bit controls whether a STOP is issued after the byte is sent or received.<ul class="simple">
<li><p>1 - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. - 0 - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. Reset value: 0x0 </p></li>
</ul>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c023get_IC_DATA_CMD_RESTARTEv">
<span id="_CPPv3NV6RP20404i2c023get_IC_DATA_CMD_RESTARTEv"></span><span id="_CPPv2NV6RP20404i2c023get_IC_DATA_CMD_RESTARTEv"></span><span id="RP2040::i2c0::get_IC_DATA_CMD_RESTARTV"></span><span class="target" id="structRP2040_1_1i2c0_1a2ced674b670e64c3fcd7668b20c27f1f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_DATA_CMD_RESTART</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c023get_IC_DATA_CMD_RESTARTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_DATA_CMD’s RESTART bit.</p>
<p><p>This bit controls whether a RESTART is issued before the byte is sent or received.</p>
<p>1 - If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.</p>
<p>0 - If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c023set_IC_DATA_CMD_RESTARTEv">
<span id="_CPPv3NV6RP20404i2c023set_IC_DATA_CMD_RESTARTEv"></span><span id="_CPPv2NV6RP20404i2c023set_IC_DATA_CMD_RESTARTEv"></span><span id="RP2040::i2c0::set_IC_DATA_CMD_RESTARTV"></span><span class="target" id="structRP2040_1_1i2c0_1a268a1cad1f23e3b7fb6045c3806f45c0"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_DATA_CMD_RESTART</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c023set_IC_DATA_CMD_RESTARTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_DATA_CMD’s RESTART bit.</p>
<p><p>This bit controls whether a RESTART is issued before the byte is sent or received.</p>
<p>1 - If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.</p>
<p>0 - If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c025clear_IC_DATA_CMD_RESTARTEv">
<span id="_CPPv3NV6RP20404i2c025clear_IC_DATA_CMD_RESTARTEv"></span><span id="_CPPv2NV6RP20404i2c025clear_IC_DATA_CMD_RESTARTEv"></span><span id="RP2040::i2c0::clear_IC_DATA_CMD_RESTARTV"></span><span class="target" id="structRP2040_1_1i2c0_1ad784b344ffeb48252e801db9a50d99c4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_DATA_CMD_RESTART</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c025clear_IC_DATA_CMD_RESTARTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_DATA_CMD’s RESTART bit.</p>
<p><p>This bit controls whether a RESTART is issued before the byte is sent or received.</p>
<p>1 - If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.</p>
<p>0 - If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026toggle_IC_DATA_CMD_RESTARTEv">
<span id="_CPPv3NV6RP20404i2c026toggle_IC_DATA_CMD_RESTARTEv"></span><span id="_CPPv2NV6RP20404i2c026toggle_IC_DATA_CMD_RESTARTEv"></span><span id="RP2040::i2c0::toggle_IC_DATA_CMD_RESTARTV"></span><span class="target" id="structRP2040_1_1i2c0_1a5118a1b4db701579ddee44c06b81ba5e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_DATA_CMD_RESTART</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026toggle_IC_DATA_CMD_RESTARTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_DATA_CMD’s RESTART bit.</p>
<p><p>This bit controls whether a RESTART is issued before the byte is sent or received.</p>
<p>1 - If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.</p>
<p>0 - If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c031get_IC_DATA_CMD_FIRST_DATA_BYTEEv">
<span id="_CPPv3NV6RP20404i2c031get_IC_DATA_CMD_FIRST_DATA_BYTEEv"></span><span id="_CPPv2NV6RP20404i2c031get_IC_DATA_CMD_FIRST_DATA_BYTEEv"></span><span id="RP2040::i2c0::get_IC_DATA_CMD_FIRST_DATA_BYTEV"></span><span class="target" id="structRP2040_1_1i2c0_1a145f29cfacd9f105bea762a4b4d242cb"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_DATA_CMD_FIRST_DATA_BYTE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c031get_IC_DATA_CMD_FIRST_DATA_BYTEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_DATA_CMD’s FIRST_DATA_BYTE bit.</p>
<p><p>Indicates the first data byte received after the address phase for receive transfer in Master receiver or Slave receiver mode.</p>
<p>Reset value : 0x0</p>

 NOTE: In case of APB_DATA_WIDTH=8,<ol class="lowerroman simple">
<li><p>The user has to perform two APB Reads to IC_DATA_CMD in order to get status on 11 bit.</p></li>
<li><p>In order to read the 11 bit, the user has to perform the first data byte read [7:0] (offset 0x10) and then perform the second read [15:8] (offset 0x11) in order to know the status of 11 bit (whether the data received in previous read is a first data byte or not).</p></li>
<li><p>The 11th bit is an optional read field, user can ignore 2nd byte read [15:8] (offset 0x11) if not interested in FIRST_DATA_BYTE status. </p></li>
</ol>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c015get_IC_DATA_CMDER7uint8_tRbRbRbRb">
<span id="_CPPv3NV6RP20404i2c015get_IC_DATA_CMDER7uint8_tRbRbRbRb"></span><span id="_CPPv2NV6RP20404i2c015get_IC_DATA_CMDER7uint8_tRbRbRbRb"></span><span id="RP2040::i2c0::get_IC_DATA_CMD__uint8_tR.bR.bR.bR.bRV"></span><span class="target" id="structRP2040_1_1i2c0_1af53c5df7e8de530b521f8862aff1cf66"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_DATA_CMD</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">DAT</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">CMD</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">STOP</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">RESTART</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">FIRST_DATA_BYTE</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c015get_IC_DATA_CMDER7uint8_tRbRbRbRb" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get all of IC_DATA_CMD’s bit fields.</p>
<p><p>(read-write) I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO.</p>
<p>The size of the register changes as follows:</p>

 Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a read command should be written for every byte that is to be received; otherwise the DW_apb_i2c will stop acknowledging. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c015set_IC_DATA_CMDE7uint8_tbbb">
<span id="_CPPv3NV6RP20404i2c015set_IC_DATA_CMDE7uint8_tbbb"></span><span id="_CPPv2NV6RP20404i2c015set_IC_DATA_CMDE7uint8_tbbb"></span><span id="RP2040::i2c0::set_IC_DATA_CMD__uint8_t.b.b.bV"></span><span class="target" id="structRP2040_1_1i2c0_1afb797b2f09c6143f5dff584021326746"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_DATA_CMD</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">DAT</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">CMD</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">STOP</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">RESTART</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c015set_IC_DATA_CMDE7uint8_tbbb" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set all of IC_DATA_CMD’s bit fields.</p>
<p><p>(read-write) I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO.</p>
<p>The size of the register changes as follows:</p>

 Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a read command should be written for every byte that is to be received; otherwise the DW_apb_i2c will stop acknowledging. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c033get_IC_SS_SCL_HCNT_IC_SS_SCL_HCNTEv">
<span id="_CPPv3NV6RP20404i2c033get_IC_SS_SCL_HCNT_IC_SS_SCL_HCNTEv"></span><span id="_CPPv2NV6RP20404i2c033get_IC_SS_SCL_HCNT_IC_SS_SCL_HCNTEv"></span><span id="RP2040::i2c0::get_IC_SS_SCL_HCNT_IC_SS_SCL_HCNTV"></span><span class="target" id="structRP2040_1_1i2c0_1ac19bb8df814014d053db6d0eb6a47564"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c033get_IC_SS_SCL_HCNT_IC_SS_SCL_HCNTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_SS_SCL_HCNT’s IC_SS_SCL_HCNT field.</p>
<p><p>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. For more information, refer to ‘IC_CLK Frequency Configuration’.</p>
<p>This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</p>
<p>The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed.</p>
<p>NOTE: This register must not be programmed to a value higher than 65525, because DW_apb_i2c uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c033set_IC_SS_SCL_HCNT_IC_SS_SCL_HCNTE8uint16_t">
<span id="_CPPv3NV6RP20404i2c033set_IC_SS_SCL_HCNT_IC_SS_SCL_HCNTE8uint16_t"></span><span id="_CPPv2NV6RP20404i2c033set_IC_SS_SCL_HCNT_IC_SS_SCL_HCNTE8uint16_t"></span><span id="RP2040::i2c0::set_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT__uint16_tV"></span><span class="target" id="structRP2040_1_1i2c0_1a17c6503af054c43ff8e7615605aef926"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c033set_IC_SS_SCL_HCNT_IC_SS_SCL_HCNTE8uint16_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_SS_SCL_HCNT’s IC_SS_SCL_HCNT field.</p>
<p><p>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. For more information, refer to ‘IC_CLK Frequency Configuration’.</p>
<p>This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</p>
<p>The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed.</p>
<p>NOTE: This register must not be programmed to a value higher than 65525, because DW_apb_i2c uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c033get_IC_SS_SCL_LCNT_IC_SS_SCL_LCNTEv">
<span id="_CPPv3NV6RP20404i2c033get_IC_SS_SCL_LCNT_IC_SS_SCL_LCNTEv"></span><span id="_CPPv2NV6RP20404i2c033get_IC_SS_SCL_LCNT_IC_SS_SCL_LCNTEv"></span><span id="RP2040::i2c0::get_IC_SS_SCL_LCNT_IC_SS_SCL_LCNTV"></span><span class="target" id="structRP2040_1_1i2c0_1a8db656600db7bf85dc2a3a3d6bdcef5f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c033get_IC_SS_SCL_LCNT_IC_SS_SCL_LCNTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_SS_SCL_LCNT’s IC_SS_SCL_LCNT field.</p>
<p><p>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed. For more information, refer to ‘IC_CLK Frequency Configuration’</p>
<p>This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</p>

 The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of DW_apb_i2c. The lower byte must be programmed first, and then the upper byte is programmed. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c033set_IC_SS_SCL_LCNT_IC_SS_SCL_LCNTE8uint16_t">
<span id="_CPPv3NV6RP20404i2c033set_IC_SS_SCL_LCNT_IC_SS_SCL_LCNTE8uint16_t"></span><span id="_CPPv2NV6RP20404i2c033set_IC_SS_SCL_LCNT_IC_SS_SCL_LCNTE8uint16_t"></span><span id="RP2040::i2c0::set_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT__uint16_tV"></span><span class="target" id="structRP2040_1_1i2c0_1a406a44369f6dc572874b256f0f676cad"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c033set_IC_SS_SCL_LCNT_IC_SS_SCL_LCNTE8uint16_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_SS_SCL_LCNT’s IC_SS_SCL_LCNT field.</p>
<p><p>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed. For more information, refer to ‘IC_CLK Frequency Configuration’</p>
<p>This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</p>

 The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of DW_apb_i2c. The lower byte must be programmed first, and then the upper byte is programmed. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c033get_IC_FS_SCL_HCNT_IC_FS_SCL_HCNTEv">
<span id="_CPPv3NV6RP20404i2c033get_IC_FS_SCL_HCNT_IC_FS_SCL_HCNTEv"></span><span id="_CPPv2NV6RP20404i2c033get_IC_FS_SCL_HCNT_IC_FS_SCL_HCNTEv"></span><span id="RP2040::i2c0::get_IC_FS_SCL_HCNT_IC_FS_SCL_HCNTV"></span><span class="target" id="structRP2040_1_1i2c0_1a6e1b206a31203e1af8e94396644a8e19"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c033get_IC_FS_SCL_HCNT_IC_FS_SCL_HCNTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_FS_SCL_HCNT’s IC_FS_SCL_HCNT field.</p>
<p><p>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast mode or fast mode plus. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to ‘IC_CLK Frequency Configuration’.</p>
<p>This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</p>

 The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c033set_IC_FS_SCL_HCNT_IC_FS_SCL_HCNTE8uint16_t">
<span id="_CPPv3NV6RP20404i2c033set_IC_FS_SCL_HCNT_IC_FS_SCL_HCNTE8uint16_t"></span><span id="_CPPv2NV6RP20404i2c033set_IC_FS_SCL_HCNT_IC_FS_SCL_HCNTE8uint16_t"></span><span id="RP2040::i2c0::set_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT__uint16_tV"></span><span class="target" id="structRP2040_1_1i2c0_1a757aed9ad129d79775bc6bc8385b83e0"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c033set_IC_FS_SCL_HCNT_IC_FS_SCL_HCNTE8uint16_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_FS_SCL_HCNT’s IC_FS_SCL_HCNT field.</p>
<p><p>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast mode or fast mode plus. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to ‘IC_CLK Frequency Configuration’.</p>
<p>This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</p>

 The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c033get_IC_FS_SCL_LCNT_IC_FS_SCL_LCNTEv">
<span id="_CPPv3NV6RP20404i2c033get_IC_FS_SCL_LCNT_IC_FS_SCL_LCNTEv"></span><span id="_CPPv2NV6RP20404i2c033get_IC_FS_SCL_LCNT_IC_FS_SCL_LCNTEv"></span><span id="RP2040::i2c0::get_IC_FS_SCL_LCNT_IC_FS_SCL_LCNTV"></span><span class="target" id="structRP2040_1_1i2c0_1a02178cb3d039a1320970c6dd19f22759"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c033get_IC_FS_SCL_LCNT_IC_FS_SCL_LCNTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_FS_SCL_LCNT’s IC_FS_SCL_LCNT field.</p>
<p><p>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to ‘IC_CLK Frequency Configuration’.</p>
<p>This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard.</p>
<p>This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</p>
<p>The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c033set_IC_FS_SCL_LCNT_IC_FS_SCL_LCNTE8uint16_t">
<span id="_CPPv3NV6RP20404i2c033set_IC_FS_SCL_LCNT_IC_FS_SCL_LCNTE8uint16_t"></span><span id="_CPPv2NV6RP20404i2c033set_IC_FS_SCL_LCNT_IC_FS_SCL_LCNTE8uint16_t"></span><span id="RP2040::i2c0::set_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT__uint16_tV"></span><span class="target" id="structRP2040_1_1i2c0_1a6793dfbe5554cc4ef2b6e18084e301f4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c033set_IC_FS_SCL_LCNT_IC_FS_SCL_LCNTE8uint16_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_FS_SCL_LCNT’s IC_FS_SCL_LCNT field.</p>
<p><p>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to ‘IC_CLK Frequency Configuration’.</p>
<p>This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard.</p>
<p>This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</p>
<p>The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027get_IC_INTR_STAT_R_RX_UNDEREv">
<span id="_CPPv3NV6RP20404i2c027get_IC_INTR_STAT_R_RX_UNDEREv"></span><span id="_CPPv2NV6RP20404i2c027get_IC_INTR_STAT_R_RX_UNDEREv"></span><span id="RP2040::i2c0::get_IC_INTR_STAT_R_RX_UNDERV"></span><span class="target" id="structRP2040_1_1i2c0_1a25fb9b4727fd9a10e42c2752cc4b9503"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_STAT_R_RX_UNDER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027get_IC_INTR_STAT_R_RX_UNDEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_STAT’s R_RX_UNDER bit.</p>
<p><p>See IC_RAW_INTR_STAT for a detailed description of R_RX_UNDER bit.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026get_IC_INTR_STAT_R_RX_OVEREv">
<span id="_CPPv3NV6RP20404i2c026get_IC_INTR_STAT_R_RX_OVEREv"></span><span id="_CPPv2NV6RP20404i2c026get_IC_INTR_STAT_R_RX_OVEREv"></span><span id="RP2040::i2c0::get_IC_INTR_STAT_R_RX_OVERV"></span><span class="target" id="structRP2040_1_1i2c0_1a6310885c5e7de32395b6493b32fd6b55"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_STAT_R_RX_OVER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026get_IC_INTR_STAT_R_RX_OVEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_STAT’s R_RX_OVER bit.</p>
<p><p>See IC_RAW_INTR_STAT for a detailed description of R_RX_OVER bit.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026get_IC_INTR_STAT_R_RX_FULLEv">
<span id="_CPPv3NV6RP20404i2c026get_IC_INTR_STAT_R_RX_FULLEv"></span><span id="_CPPv2NV6RP20404i2c026get_IC_INTR_STAT_R_RX_FULLEv"></span><span id="RP2040::i2c0::get_IC_INTR_STAT_R_RX_FULLV"></span><span class="target" id="structRP2040_1_1i2c0_1acb894175beba6ea4f3c67ad254d52695"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_STAT_R_RX_FULL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026get_IC_INTR_STAT_R_RX_FULLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_STAT’s R_RX_FULL bit.</p>
<p><p>See IC_RAW_INTR_STAT for a detailed description of R_RX_FULL bit.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026get_IC_INTR_STAT_R_TX_OVEREv">
<span id="_CPPv3NV6RP20404i2c026get_IC_INTR_STAT_R_TX_OVEREv"></span><span id="_CPPv2NV6RP20404i2c026get_IC_INTR_STAT_R_TX_OVEREv"></span><span id="RP2040::i2c0::get_IC_INTR_STAT_R_TX_OVERV"></span><span class="target" id="structRP2040_1_1i2c0_1a4f30b8926184d54fb0c516c0934a59c1"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_STAT_R_TX_OVER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026get_IC_INTR_STAT_R_TX_OVEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_STAT’s R_TX_OVER bit.</p>
<p><p>See IC_RAW_INTR_STAT for a detailed description of R_TX_OVER bit.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027get_IC_INTR_STAT_R_TX_EMPTYEv">
<span id="_CPPv3NV6RP20404i2c027get_IC_INTR_STAT_R_TX_EMPTYEv"></span><span id="_CPPv2NV6RP20404i2c027get_IC_INTR_STAT_R_TX_EMPTYEv"></span><span id="RP2040::i2c0::get_IC_INTR_STAT_R_TX_EMPTYV"></span><span class="target" id="structRP2040_1_1i2c0_1ad5268a3a00504784e65cd7df6207d786"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_STAT_R_TX_EMPTY</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027get_IC_INTR_STAT_R_TX_EMPTYEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_STAT’s R_TX_EMPTY bit.</p>
<p><p>See IC_RAW_INTR_STAT for a detailed description of R_TX_EMPTY bit.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c025get_IC_INTR_STAT_R_RD_REQEv">
<span id="_CPPv3NV6RP20404i2c025get_IC_INTR_STAT_R_RD_REQEv"></span><span id="_CPPv2NV6RP20404i2c025get_IC_INTR_STAT_R_RD_REQEv"></span><span id="RP2040::i2c0::get_IC_INTR_STAT_R_RD_REQV"></span><span class="target" id="structRP2040_1_1i2c0_1a9461d956cf303b7c8d86339081620b97"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_STAT_R_RD_REQ</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c025get_IC_INTR_STAT_R_RD_REQEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_STAT’s R_RD_REQ bit.</p>
<p><p>See IC_RAW_INTR_STAT for a detailed description of R_RD_REQ bit.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026get_IC_INTR_STAT_R_TX_ABRTEv">
<span id="_CPPv3NV6RP20404i2c026get_IC_INTR_STAT_R_TX_ABRTEv"></span><span id="_CPPv2NV6RP20404i2c026get_IC_INTR_STAT_R_TX_ABRTEv"></span><span id="RP2040::i2c0::get_IC_INTR_STAT_R_TX_ABRTV"></span><span class="target" id="structRP2040_1_1i2c0_1a2b0d08dcd8abf9acc539c2a0a2733300"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_STAT_R_TX_ABRT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026get_IC_INTR_STAT_R_TX_ABRTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_STAT’s R_TX_ABRT bit.</p>
<p><p>See IC_RAW_INTR_STAT for a detailed description of R_TX_ABRT bit.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026get_IC_INTR_STAT_R_RX_DONEEv">
<span id="_CPPv3NV6RP20404i2c026get_IC_INTR_STAT_R_RX_DONEEv"></span><span id="_CPPv2NV6RP20404i2c026get_IC_INTR_STAT_R_RX_DONEEv"></span><span id="RP2040::i2c0::get_IC_INTR_STAT_R_RX_DONEV"></span><span class="target" id="structRP2040_1_1i2c0_1a9797071480896ed0fc87f0faf5d1e7b0"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_STAT_R_RX_DONE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026get_IC_INTR_STAT_R_RX_DONEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_STAT’s R_RX_DONE bit.</p>
<p><p>See IC_RAW_INTR_STAT for a detailed description of R_RX_DONE bit.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027get_IC_INTR_STAT_R_ACTIVITYEv">
<span id="_CPPv3NV6RP20404i2c027get_IC_INTR_STAT_R_ACTIVITYEv"></span><span id="_CPPv2NV6RP20404i2c027get_IC_INTR_STAT_R_ACTIVITYEv"></span><span id="RP2040::i2c0::get_IC_INTR_STAT_R_ACTIVITYV"></span><span class="target" id="structRP2040_1_1i2c0_1ac658376d710212efde086b1ca9a92a05"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_STAT_R_ACTIVITY</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027get_IC_INTR_STAT_R_ACTIVITYEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_STAT’s R_ACTIVITY bit.</p>
<p><p>See IC_RAW_INTR_STAT for a detailed description of R_ACTIVITY bit.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027get_IC_INTR_STAT_R_STOP_DETEv">
<span id="_CPPv3NV6RP20404i2c027get_IC_INTR_STAT_R_STOP_DETEv"></span><span id="_CPPv2NV6RP20404i2c027get_IC_INTR_STAT_R_STOP_DETEv"></span><span id="RP2040::i2c0::get_IC_INTR_STAT_R_STOP_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1a98dc5995ad4aee272111b8bbf0329f8c"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_STAT_R_STOP_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027get_IC_INTR_STAT_R_STOP_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_STAT’s R_STOP_DET bit.</p>
<p><p>See IC_RAW_INTR_STAT for a detailed description of R_STOP_DET bit.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c028get_IC_INTR_STAT_R_START_DETEv">
<span id="_CPPv3NV6RP20404i2c028get_IC_INTR_STAT_R_START_DETEv"></span><span id="_CPPv2NV6RP20404i2c028get_IC_INTR_STAT_R_START_DETEv"></span><span id="RP2040::i2c0::get_IC_INTR_STAT_R_START_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1a12451693a1af5616220372151be3442a"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_STAT_R_START_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c028get_IC_INTR_STAT_R_START_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_STAT’s R_START_DET bit.</p>
<p><p>See IC_RAW_INTR_STAT for a detailed description of R_START_DET bit.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027get_IC_INTR_STAT_R_GEN_CALLEv">
<span id="_CPPv3NV6RP20404i2c027get_IC_INTR_STAT_R_GEN_CALLEv"></span><span id="_CPPv2NV6RP20404i2c027get_IC_INTR_STAT_R_GEN_CALLEv"></span><span id="RP2040::i2c0::get_IC_INTR_STAT_R_GEN_CALLV"></span><span class="target" id="structRP2040_1_1i2c0_1a036fb4b8bb349862159ba3e780106eed"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_STAT_R_GEN_CALL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027get_IC_INTR_STAT_R_GEN_CALLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_STAT’s R_GEN_CALL bit.</p>
<p><p>See IC_RAW_INTR_STAT for a detailed description of R_GEN_CALL bit.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030get_IC_INTR_STAT_R_RESTART_DETEv">
<span id="_CPPv3NV6RP20404i2c030get_IC_INTR_STAT_R_RESTART_DETEv"></span><span id="_CPPv2NV6RP20404i2c030get_IC_INTR_STAT_R_RESTART_DETEv"></span><span id="RP2040::i2c0::get_IC_INTR_STAT_R_RESTART_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1acb37ba3a4711ff73316ee97b4aa80901"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_STAT_R_RESTART_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030get_IC_INTR_STAT_R_RESTART_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_STAT’s R_RESTART_DET bit.</p>
<p><p>See IC_RAW_INTR_STAT for a detailed description of R_RESTART_DET bit.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c016get_IC_INTR_STATERbRbRbRbRbRbRbRbRbRbRbRbRb">
<span id="_CPPv3NV6RP20404i2c016get_IC_INTR_STATERbRbRbRbRbRbRbRbRbRbRbRbRb"></span><span id="_CPPv2NV6RP20404i2c016get_IC_INTR_STATERbRbRbRbRbRbRbRbRbRbRbRbRb"></span><span id="RP2040::i2c0::get_IC_INTR_STAT__bR.bR.bR.bR.bR.bR.bR.bR.bR.bR.bR.bR.bRV"></span><span class="target" id="structRP2040_1_1i2c0_1a90cd3300e9ef0c130402ad5ea77a098b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_STAT</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">R_RX_UNDER</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">R_RX_OVER</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">R_RX_FULL</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">R_TX_OVER</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">R_TX_EMPTY</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">R_RD_REQ</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">R_TX_ABRT</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">R_RX_DONE</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">R_ACTIVITY</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">R_STOP_DET</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">R_START_DET</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">R_GEN_CALL</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">R_RESTART_DET</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c016get_IC_INTR_STATERbRbRbRbRbRbRbRbRbRbRbRbRb" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get all of IC_INTR_STAT’s bit fields.</p>
<p><p>(read-only) I2C Interrupt Status Register</p>
<p>Each bit in this register has a corresponding mask bit in the IC_INTR_MASK register. These bits are cleared by reading the matching interrupt clear register. The unmasked raw versions of these bits are available in the IC_RAW_INTR_STAT register.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027get_IC_INTR_MASK_M_RX_UNDEREv">
<span id="_CPPv3NV6RP20404i2c027get_IC_INTR_MASK_M_RX_UNDEREv"></span><span id="_CPPv2NV6RP20404i2c027get_IC_INTR_MASK_M_RX_UNDEREv"></span><span id="RP2040::i2c0::get_IC_INTR_MASK_M_RX_UNDERV"></span><span class="target" id="structRP2040_1_1i2c0_1a282f61f7eebce50b56b33d5774b5ca03"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_MASK_M_RX_UNDER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027get_IC_INTR_MASK_M_RX_UNDEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_MASK’s M_RX_UNDER bit.</p>
<p><p>This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027set_IC_INTR_MASK_M_RX_UNDEREv">
<span id="_CPPv3NV6RP20404i2c027set_IC_INTR_MASK_M_RX_UNDEREv"></span><span id="_CPPv2NV6RP20404i2c027set_IC_INTR_MASK_M_RX_UNDEREv"></span><span id="RP2040::i2c0::set_IC_INTR_MASK_M_RX_UNDERV"></span><span class="target" id="structRP2040_1_1i2c0_1af199968d6ebb644b0a517cd094edbe18"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_INTR_MASK_M_RX_UNDER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027set_IC_INTR_MASK_M_RX_UNDEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_INTR_MASK’s M_RX_UNDER bit.</p>
<p><p>This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029clear_IC_INTR_MASK_M_RX_UNDEREv">
<span id="_CPPv3NV6RP20404i2c029clear_IC_INTR_MASK_M_RX_UNDEREv"></span><span id="_CPPv2NV6RP20404i2c029clear_IC_INTR_MASK_M_RX_UNDEREv"></span><span id="RP2040::i2c0::clear_IC_INTR_MASK_M_RX_UNDERV"></span><span class="target" id="structRP2040_1_1i2c0_1ae87dc5af6508bfdc87f7e5273620feae"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_INTR_MASK_M_RX_UNDER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029clear_IC_INTR_MASK_M_RX_UNDEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_INTR_MASK’s M_RX_UNDER bit.</p>
<p><p>This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030toggle_IC_INTR_MASK_M_RX_UNDEREv">
<span id="_CPPv3NV6RP20404i2c030toggle_IC_INTR_MASK_M_RX_UNDEREv"></span><span id="_CPPv2NV6RP20404i2c030toggle_IC_INTR_MASK_M_RX_UNDEREv"></span><span id="RP2040::i2c0::toggle_IC_INTR_MASK_M_RX_UNDERV"></span><span class="target" id="structRP2040_1_1i2c0_1af18bf72da5e79e4ddada7ce2f11256ac"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_INTR_MASK_M_RX_UNDER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030toggle_IC_INTR_MASK_M_RX_UNDEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_INTR_MASK’s M_RX_UNDER bit.</p>
<p><p>This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026get_IC_INTR_MASK_M_RX_OVEREv">
<span id="_CPPv3NV6RP20404i2c026get_IC_INTR_MASK_M_RX_OVEREv"></span><span id="_CPPv2NV6RP20404i2c026get_IC_INTR_MASK_M_RX_OVEREv"></span><span id="RP2040::i2c0::get_IC_INTR_MASK_M_RX_OVERV"></span><span class="target" id="structRP2040_1_1i2c0_1a38710d00fcdad13a7ffa805c95cde660"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_MASK_M_RX_OVER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026get_IC_INTR_MASK_M_RX_OVEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_MASK’s M_RX_OVER bit.</p>
<p><p>This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026set_IC_INTR_MASK_M_RX_OVEREv">
<span id="_CPPv3NV6RP20404i2c026set_IC_INTR_MASK_M_RX_OVEREv"></span><span id="_CPPv2NV6RP20404i2c026set_IC_INTR_MASK_M_RX_OVEREv"></span><span id="RP2040::i2c0::set_IC_INTR_MASK_M_RX_OVERV"></span><span class="target" id="structRP2040_1_1i2c0_1ab21203091da602b59fb4621280f235a8"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_INTR_MASK_M_RX_OVER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026set_IC_INTR_MASK_M_RX_OVEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_INTR_MASK’s M_RX_OVER bit.</p>
<p><p>This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c028clear_IC_INTR_MASK_M_RX_OVEREv">
<span id="_CPPv3NV6RP20404i2c028clear_IC_INTR_MASK_M_RX_OVEREv"></span><span id="_CPPv2NV6RP20404i2c028clear_IC_INTR_MASK_M_RX_OVEREv"></span><span id="RP2040::i2c0::clear_IC_INTR_MASK_M_RX_OVERV"></span><span class="target" id="structRP2040_1_1i2c0_1ac9b1fe47e2738d3b6be9363fdf7c1b1a"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_INTR_MASK_M_RX_OVER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c028clear_IC_INTR_MASK_M_RX_OVEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_INTR_MASK’s M_RX_OVER bit.</p>
<p><p>This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029toggle_IC_INTR_MASK_M_RX_OVEREv">
<span id="_CPPv3NV6RP20404i2c029toggle_IC_INTR_MASK_M_RX_OVEREv"></span><span id="_CPPv2NV6RP20404i2c029toggle_IC_INTR_MASK_M_RX_OVEREv"></span><span id="RP2040::i2c0::toggle_IC_INTR_MASK_M_RX_OVERV"></span><span class="target" id="structRP2040_1_1i2c0_1a7d927197f20161d5652dd4e76d0ea929"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_INTR_MASK_M_RX_OVER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029toggle_IC_INTR_MASK_M_RX_OVEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_INTR_MASK’s M_RX_OVER bit.</p>
<p><p>This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026get_IC_INTR_MASK_M_RX_FULLEv">
<span id="_CPPv3NV6RP20404i2c026get_IC_INTR_MASK_M_RX_FULLEv"></span><span id="_CPPv2NV6RP20404i2c026get_IC_INTR_MASK_M_RX_FULLEv"></span><span id="RP2040::i2c0::get_IC_INTR_MASK_M_RX_FULLV"></span><span class="target" id="structRP2040_1_1i2c0_1addfdfbda1190a9bfc9f98e9f3b13bbb2"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_MASK_M_RX_FULL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026get_IC_INTR_MASK_M_RX_FULLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_MASK’s M_RX_FULL bit.</p>
<p><p>This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026set_IC_INTR_MASK_M_RX_FULLEv">
<span id="_CPPv3NV6RP20404i2c026set_IC_INTR_MASK_M_RX_FULLEv"></span><span id="_CPPv2NV6RP20404i2c026set_IC_INTR_MASK_M_RX_FULLEv"></span><span id="RP2040::i2c0::set_IC_INTR_MASK_M_RX_FULLV"></span><span class="target" id="structRP2040_1_1i2c0_1a0c80bd8e6aa7b608a0c67a5b3284a399"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_INTR_MASK_M_RX_FULL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026set_IC_INTR_MASK_M_RX_FULLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_INTR_MASK’s M_RX_FULL bit.</p>
<p><p>This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c028clear_IC_INTR_MASK_M_RX_FULLEv">
<span id="_CPPv3NV6RP20404i2c028clear_IC_INTR_MASK_M_RX_FULLEv"></span><span id="_CPPv2NV6RP20404i2c028clear_IC_INTR_MASK_M_RX_FULLEv"></span><span id="RP2040::i2c0::clear_IC_INTR_MASK_M_RX_FULLV"></span><span class="target" id="structRP2040_1_1i2c0_1ac81dc0c445c2e1c8de483bc4ce32ea83"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_INTR_MASK_M_RX_FULL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c028clear_IC_INTR_MASK_M_RX_FULLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_INTR_MASK’s M_RX_FULL bit.</p>
<p><p>This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029toggle_IC_INTR_MASK_M_RX_FULLEv">
<span id="_CPPv3NV6RP20404i2c029toggle_IC_INTR_MASK_M_RX_FULLEv"></span><span id="_CPPv2NV6RP20404i2c029toggle_IC_INTR_MASK_M_RX_FULLEv"></span><span id="RP2040::i2c0::toggle_IC_INTR_MASK_M_RX_FULLV"></span><span class="target" id="structRP2040_1_1i2c0_1a5d5565b0f35d937cc65a18a001d78da6"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_INTR_MASK_M_RX_FULL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029toggle_IC_INTR_MASK_M_RX_FULLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_INTR_MASK’s M_RX_FULL bit.</p>
<p><p>This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026get_IC_INTR_MASK_M_TX_OVEREv">
<span id="_CPPv3NV6RP20404i2c026get_IC_INTR_MASK_M_TX_OVEREv"></span><span id="_CPPv2NV6RP20404i2c026get_IC_INTR_MASK_M_TX_OVEREv"></span><span id="RP2040::i2c0::get_IC_INTR_MASK_M_TX_OVERV"></span><span class="target" id="structRP2040_1_1i2c0_1a239201c746b42fab8d644c714c7ff208"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_MASK_M_TX_OVER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026get_IC_INTR_MASK_M_TX_OVEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_MASK’s M_TX_OVER bit.</p>
<p><p>This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026set_IC_INTR_MASK_M_TX_OVEREv">
<span id="_CPPv3NV6RP20404i2c026set_IC_INTR_MASK_M_TX_OVEREv"></span><span id="_CPPv2NV6RP20404i2c026set_IC_INTR_MASK_M_TX_OVEREv"></span><span id="RP2040::i2c0::set_IC_INTR_MASK_M_TX_OVERV"></span><span class="target" id="structRP2040_1_1i2c0_1ae7fe0a2f558f5cc1ca256b99e7d57e1f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_INTR_MASK_M_TX_OVER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026set_IC_INTR_MASK_M_TX_OVEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_INTR_MASK’s M_TX_OVER bit.</p>
<p><p>This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c028clear_IC_INTR_MASK_M_TX_OVEREv">
<span id="_CPPv3NV6RP20404i2c028clear_IC_INTR_MASK_M_TX_OVEREv"></span><span id="_CPPv2NV6RP20404i2c028clear_IC_INTR_MASK_M_TX_OVEREv"></span><span id="RP2040::i2c0::clear_IC_INTR_MASK_M_TX_OVERV"></span><span class="target" id="structRP2040_1_1i2c0_1a1a37309163440b280e6b413e0148255b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_INTR_MASK_M_TX_OVER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c028clear_IC_INTR_MASK_M_TX_OVEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_INTR_MASK’s M_TX_OVER bit.</p>
<p><p>This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029toggle_IC_INTR_MASK_M_TX_OVEREv">
<span id="_CPPv3NV6RP20404i2c029toggle_IC_INTR_MASK_M_TX_OVEREv"></span><span id="_CPPv2NV6RP20404i2c029toggle_IC_INTR_MASK_M_TX_OVEREv"></span><span id="RP2040::i2c0::toggle_IC_INTR_MASK_M_TX_OVERV"></span><span class="target" id="structRP2040_1_1i2c0_1a8f71b5175b53ae650ef99dfbd54ee8ba"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_INTR_MASK_M_TX_OVER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029toggle_IC_INTR_MASK_M_TX_OVEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_INTR_MASK’s M_TX_OVER bit.</p>
<p><p>This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027get_IC_INTR_MASK_M_TX_EMPTYEv">
<span id="_CPPv3NV6RP20404i2c027get_IC_INTR_MASK_M_TX_EMPTYEv"></span><span id="_CPPv2NV6RP20404i2c027get_IC_INTR_MASK_M_TX_EMPTYEv"></span><span id="RP2040::i2c0::get_IC_INTR_MASK_M_TX_EMPTYV"></span><span class="target" id="structRP2040_1_1i2c0_1abfb64b93be166aa9a11a52c82875ee4a"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_MASK_M_TX_EMPTY</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027get_IC_INTR_MASK_M_TX_EMPTYEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_MASK’s M_TX_EMPTY bit.</p>
<p><p>This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027set_IC_INTR_MASK_M_TX_EMPTYEv">
<span id="_CPPv3NV6RP20404i2c027set_IC_INTR_MASK_M_TX_EMPTYEv"></span><span id="_CPPv2NV6RP20404i2c027set_IC_INTR_MASK_M_TX_EMPTYEv"></span><span id="RP2040::i2c0::set_IC_INTR_MASK_M_TX_EMPTYV"></span><span class="target" id="structRP2040_1_1i2c0_1a0c2b2afe570040be05e835362637ae82"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_INTR_MASK_M_TX_EMPTY</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027set_IC_INTR_MASK_M_TX_EMPTYEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_INTR_MASK’s M_TX_EMPTY bit.</p>
<p><p>This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029clear_IC_INTR_MASK_M_TX_EMPTYEv">
<span id="_CPPv3NV6RP20404i2c029clear_IC_INTR_MASK_M_TX_EMPTYEv"></span><span id="_CPPv2NV6RP20404i2c029clear_IC_INTR_MASK_M_TX_EMPTYEv"></span><span id="RP2040::i2c0::clear_IC_INTR_MASK_M_TX_EMPTYV"></span><span class="target" id="structRP2040_1_1i2c0_1a64e167c7540e840d3eef7791f6ca6e05"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_INTR_MASK_M_TX_EMPTY</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029clear_IC_INTR_MASK_M_TX_EMPTYEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_INTR_MASK’s M_TX_EMPTY bit.</p>
<p><p>This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030toggle_IC_INTR_MASK_M_TX_EMPTYEv">
<span id="_CPPv3NV6RP20404i2c030toggle_IC_INTR_MASK_M_TX_EMPTYEv"></span><span id="_CPPv2NV6RP20404i2c030toggle_IC_INTR_MASK_M_TX_EMPTYEv"></span><span id="RP2040::i2c0::toggle_IC_INTR_MASK_M_TX_EMPTYV"></span><span class="target" id="structRP2040_1_1i2c0_1a0f2d7a53051b4110ea712d833c912cf7"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_INTR_MASK_M_TX_EMPTY</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030toggle_IC_INTR_MASK_M_TX_EMPTYEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_INTR_MASK’s M_TX_EMPTY bit.</p>
<p><p>This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c025get_IC_INTR_MASK_M_RD_REQEv">
<span id="_CPPv3NV6RP20404i2c025get_IC_INTR_MASK_M_RD_REQEv"></span><span id="_CPPv2NV6RP20404i2c025get_IC_INTR_MASK_M_RD_REQEv"></span><span id="RP2040::i2c0::get_IC_INTR_MASK_M_RD_REQV"></span><span class="target" id="structRP2040_1_1i2c0_1a950ed74693062897304a43d32feb4346"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_MASK_M_RD_REQ</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c025get_IC_INTR_MASK_M_RD_REQEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_MASK’s M_RD_REQ bit.</p>
<p><p>This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c025set_IC_INTR_MASK_M_RD_REQEv">
<span id="_CPPv3NV6RP20404i2c025set_IC_INTR_MASK_M_RD_REQEv"></span><span id="_CPPv2NV6RP20404i2c025set_IC_INTR_MASK_M_RD_REQEv"></span><span id="RP2040::i2c0::set_IC_INTR_MASK_M_RD_REQV"></span><span class="target" id="structRP2040_1_1i2c0_1af82f49af336dec6ec2f56bc84368068d"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_INTR_MASK_M_RD_REQ</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c025set_IC_INTR_MASK_M_RD_REQEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_INTR_MASK’s M_RD_REQ bit.</p>
<p><p>This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027clear_IC_INTR_MASK_M_RD_REQEv">
<span id="_CPPv3NV6RP20404i2c027clear_IC_INTR_MASK_M_RD_REQEv"></span><span id="_CPPv2NV6RP20404i2c027clear_IC_INTR_MASK_M_RD_REQEv"></span><span id="RP2040::i2c0::clear_IC_INTR_MASK_M_RD_REQV"></span><span class="target" id="structRP2040_1_1i2c0_1a62f3c06651e42b1a6635719b9bec7ae0"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_INTR_MASK_M_RD_REQ</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027clear_IC_INTR_MASK_M_RD_REQEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_INTR_MASK’s M_RD_REQ bit.</p>
<p><p>This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c028toggle_IC_INTR_MASK_M_RD_REQEv">
<span id="_CPPv3NV6RP20404i2c028toggle_IC_INTR_MASK_M_RD_REQEv"></span><span id="_CPPv2NV6RP20404i2c028toggle_IC_INTR_MASK_M_RD_REQEv"></span><span id="RP2040::i2c0::toggle_IC_INTR_MASK_M_RD_REQV"></span><span class="target" id="structRP2040_1_1i2c0_1af9cd38d388dcca8bcfe6bc7b2b96936f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_INTR_MASK_M_RD_REQ</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c028toggle_IC_INTR_MASK_M_RD_REQEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_INTR_MASK’s M_RD_REQ bit.</p>
<p><p>This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026get_IC_INTR_MASK_M_TX_ABRTEv">
<span id="_CPPv3NV6RP20404i2c026get_IC_INTR_MASK_M_TX_ABRTEv"></span><span id="_CPPv2NV6RP20404i2c026get_IC_INTR_MASK_M_TX_ABRTEv"></span><span id="RP2040::i2c0::get_IC_INTR_MASK_M_TX_ABRTV"></span><span class="target" id="structRP2040_1_1i2c0_1acb50ea5216bd8b088b197b41310e8ed6"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_MASK_M_TX_ABRT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026get_IC_INTR_MASK_M_TX_ABRTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_MASK’s M_TX_ABRT bit.</p>
<p><p>This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026set_IC_INTR_MASK_M_TX_ABRTEv">
<span id="_CPPv3NV6RP20404i2c026set_IC_INTR_MASK_M_TX_ABRTEv"></span><span id="_CPPv2NV6RP20404i2c026set_IC_INTR_MASK_M_TX_ABRTEv"></span><span id="RP2040::i2c0::set_IC_INTR_MASK_M_TX_ABRTV"></span><span class="target" id="structRP2040_1_1i2c0_1a1b2301c09c343cd6d59d9aa8c71f1741"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_INTR_MASK_M_TX_ABRT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026set_IC_INTR_MASK_M_TX_ABRTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_INTR_MASK’s M_TX_ABRT bit.</p>
<p><p>This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c028clear_IC_INTR_MASK_M_TX_ABRTEv">
<span id="_CPPv3NV6RP20404i2c028clear_IC_INTR_MASK_M_TX_ABRTEv"></span><span id="_CPPv2NV6RP20404i2c028clear_IC_INTR_MASK_M_TX_ABRTEv"></span><span id="RP2040::i2c0::clear_IC_INTR_MASK_M_TX_ABRTV"></span><span class="target" id="structRP2040_1_1i2c0_1a35c250207acbdf324993563676771c8b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_INTR_MASK_M_TX_ABRT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c028clear_IC_INTR_MASK_M_TX_ABRTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_INTR_MASK’s M_TX_ABRT bit.</p>
<p><p>This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029toggle_IC_INTR_MASK_M_TX_ABRTEv">
<span id="_CPPv3NV6RP20404i2c029toggle_IC_INTR_MASK_M_TX_ABRTEv"></span><span id="_CPPv2NV6RP20404i2c029toggle_IC_INTR_MASK_M_TX_ABRTEv"></span><span id="RP2040::i2c0::toggle_IC_INTR_MASK_M_TX_ABRTV"></span><span class="target" id="structRP2040_1_1i2c0_1acebe5b238cc2393235f31c2698fe2d2c"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_INTR_MASK_M_TX_ABRT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029toggle_IC_INTR_MASK_M_TX_ABRTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_INTR_MASK’s M_TX_ABRT bit.</p>
<p><p>This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026get_IC_INTR_MASK_M_RX_DONEEv">
<span id="_CPPv3NV6RP20404i2c026get_IC_INTR_MASK_M_RX_DONEEv"></span><span id="_CPPv2NV6RP20404i2c026get_IC_INTR_MASK_M_RX_DONEEv"></span><span id="RP2040::i2c0::get_IC_INTR_MASK_M_RX_DONEV"></span><span class="target" id="structRP2040_1_1i2c0_1a5815b7eedc138ef11dd14b51457a189e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_MASK_M_RX_DONE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026get_IC_INTR_MASK_M_RX_DONEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_MASK’s M_RX_DONE bit.</p>
<p><p>This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026set_IC_INTR_MASK_M_RX_DONEEv">
<span id="_CPPv3NV6RP20404i2c026set_IC_INTR_MASK_M_RX_DONEEv"></span><span id="_CPPv2NV6RP20404i2c026set_IC_INTR_MASK_M_RX_DONEEv"></span><span id="RP2040::i2c0::set_IC_INTR_MASK_M_RX_DONEV"></span><span class="target" id="structRP2040_1_1i2c0_1a858dc57894996874fbc029162f4ce0e5"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_INTR_MASK_M_RX_DONE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026set_IC_INTR_MASK_M_RX_DONEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_INTR_MASK’s M_RX_DONE bit.</p>
<p><p>This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c028clear_IC_INTR_MASK_M_RX_DONEEv">
<span id="_CPPv3NV6RP20404i2c028clear_IC_INTR_MASK_M_RX_DONEEv"></span><span id="_CPPv2NV6RP20404i2c028clear_IC_INTR_MASK_M_RX_DONEEv"></span><span id="RP2040::i2c0::clear_IC_INTR_MASK_M_RX_DONEV"></span><span class="target" id="structRP2040_1_1i2c0_1a3f0e6751e71dfeb9873458cd69b53a79"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_INTR_MASK_M_RX_DONE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c028clear_IC_INTR_MASK_M_RX_DONEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_INTR_MASK’s M_RX_DONE bit.</p>
<p><p>This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029toggle_IC_INTR_MASK_M_RX_DONEEv">
<span id="_CPPv3NV6RP20404i2c029toggle_IC_INTR_MASK_M_RX_DONEEv"></span><span id="_CPPv2NV6RP20404i2c029toggle_IC_INTR_MASK_M_RX_DONEEv"></span><span id="RP2040::i2c0::toggle_IC_INTR_MASK_M_RX_DONEV"></span><span class="target" id="structRP2040_1_1i2c0_1a2352b288e148fe9033b0df02a27c7f8c"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_INTR_MASK_M_RX_DONE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029toggle_IC_INTR_MASK_M_RX_DONEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_INTR_MASK’s M_RX_DONE bit.</p>
<p><p>This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027get_IC_INTR_MASK_M_ACTIVITYEv">
<span id="_CPPv3NV6RP20404i2c027get_IC_INTR_MASK_M_ACTIVITYEv"></span><span id="_CPPv2NV6RP20404i2c027get_IC_INTR_MASK_M_ACTIVITYEv"></span><span id="RP2040::i2c0::get_IC_INTR_MASK_M_ACTIVITYV"></span><span class="target" id="structRP2040_1_1i2c0_1a3d6663e0b0a010864be39b30a1cc2417"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_MASK_M_ACTIVITY</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027get_IC_INTR_MASK_M_ACTIVITYEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_MASK’s M_ACTIVITY bit.</p>
<p><p>This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027set_IC_INTR_MASK_M_ACTIVITYEv">
<span id="_CPPv3NV6RP20404i2c027set_IC_INTR_MASK_M_ACTIVITYEv"></span><span id="_CPPv2NV6RP20404i2c027set_IC_INTR_MASK_M_ACTIVITYEv"></span><span id="RP2040::i2c0::set_IC_INTR_MASK_M_ACTIVITYV"></span><span class="target" id="structRP2040_1_1i2c0_1aae2806cc53b125fa3f618cdd11f7bf34"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_INTR_MASK_M_ACTIVITY</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027set_IC_INTR_MASK_M_ACTIVITYEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_INTR_MASK’s M_ACTIVITY bit.</p>
<p><p>This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029clear_IC_INTR_MASK_M_ACTIVITYEv">
<span id="_CPPv3NV6RP20404i2c029clear_IC_INTR_MASK_M_ACTIVITYEv"></span><span id="_CPPv2NV6RP20404i2c029clear_IC_INTR_MASK_M_ACTIVITYEv"></span><span id="RP2040::i2c0::clear_IC_INTR_MASK_M_ACTIVITYV"></span><span class="target" id="structRP2040_1_1i2c0_1aa023d6539a932e01a5e9d96bc8b7d536"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_INTR_MASK_M_ACTIVITY</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029clear_IC_INTR_MASK_M_ACTIVITYEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_INTR_MASK’s M_ACTIVITY bit.</p>
<p><p>This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030toggle_IC_INTR_MASK_M_ACTIVITYEv">
<span id="_CPPv3NV6RP20404i2c030toggle_IC_INTR_MASK_M_ACTIVITYEv"></span><span id="_CPPv2NV6RP20404i2c030toggle_IC_INTR_MASK_M_ACTIVITYEv"></span><span id="RP2040::i2c0::toggle_IC_INTR_MASK_M_ACTIVITYV"></span><span class="target" id="structRP2040_1_1i2c0_1a96e3ba0ace54f2f587202b805fcd147b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_INTR_MASK_M_ACTIVITY</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030toggle_IC_INTR_MASK_M_ACTIVITYEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_INTR_MASK’s M_ACTIVITY bit.</p>
<p><p>This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027get_IC_INTR_MASK_M_STOP_DETEv">
<span id="_CPPv3NV6RP20404i2c027get_IC_INTR_MASK_M_STOP_DETEv"></span><span id="_CPPv2NV6RP20404i2c027get_IC_INTR_MASK_M_STOP_DETEv"></span><span id="RP2040::i2c0::get_IC_INTR_MASK_M_STOP_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1a4334f329b1d7b107eac9bb825f547428"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_MASK_M_STOP_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027get_IC_INTR_MASK_M_STOP_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_MASK’s M_STOP_DET bit.</p>
<p><p>This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027set_IC_INTR_MASK_M_STOP_DETEv">
<span id="_CPPv3NV6RP20404i2c027set_IC_INTR_MASK_M_STOP_DETEv"></span><span id="_CPPv2NV6RP20404i2c027set_IC_INTR_MASK_M_STOP_DETEv"></span><span id="RP2040::i2c0::set_IC_INTR_MASK_M_STOP_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1ad8a43a979fbe172c694dd43a84ed404a"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_INTR_MASK_M_STOP_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027set_IC_INTR_MASK_M_STOP_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_INTR_MASK’s M_STOP_DET bit.</p>
<p><p>This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029clear_IC_INTR_MASK_M_STOP_DETEv">
<span id="_CPPv3NV6RP20404i2c029clear_IC_INTR_MASK_M_STOP_DETEv"></span><span id="_CPPv2NV6RP20404i2c029clear_IC_INTR_MASK_M_STOP_DETEv"></span><span id="RP2040::i2c0::clear_IC_INTR_MASK_M_STOP_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1ab12b813ffd41e552e830b7acbf73b1dc"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_INTR_MASK_M_STOP_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029clear_IC_INTR_MASK_M_STOP_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_INTR_MASK’s M_STOP_DET bit.</p>
<p><p>This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030toggle_IC_INTR_MASK_M_STOP_DETEv">
<span id="_CPPv3NV6RP20404i2c030toggle_IC_INTR_MASK_M_STOP_DETEv"></span><span id="_CPPv2NV6RP20404i2c030toggle_IC_INTR_MASK_M_STOP_DETEv"></span><span id="RP2040::i2c0::toggle_IC_INTR_MASK_M_STOP_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1a3fc57bb1a80f791f9e88f456a9230dd4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_INTR_MASK_M_STOP_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030toggle_IC_INTR_MASK_M_STOP_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_INTR_MASK’s M_STOP_DET bit.</p>
<p><p>This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c028get_IC_INTR_MASK_M_START_DETEv">
<span id="_CPPv3NV6RP20404i2c028get_IC_INTR_MASK_M_START_DETEv"></span><span id="_CPPv2NV6RP20404i2c028get_IC_INTR_MASK_M_START_DETEv"></span><span id="RP2040::i2c0::get_IC_INTR_MASK_M_START_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1a29e70f5b5945c26e7aa2cb2deea4af68"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_MASK_M_START_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c028get_IC_INTR_MASK_M_START_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_MASK’s M_START_DET bit.</p>
<p><p>This bit masks the R_START_DET interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c028set_IC_INTR_MASK_M_START_DETEv">
<span id="_CPPv3NV6RP20404i2c028set_IC_INTR_MASK_M_START_DETEv"></span><span id="_CPPv2NV6RP20404i2c028set_IC_INTR_MASK_M_START_DETEv"></span><span id="RP2040::i2c0::set_IC_INTR_MASK_M_START_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1aecd18b04e59e2fddf398344c9962ebcc"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_INTR_MASK_M_START_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c028set_IC_INTR_MASK_M_START_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_INTR_MASK’s M_START_DET bit.</p>
<p><p>This bit masks the R_START_DET interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030clear_IC_INTR_MASK_M_START_DETEv">
<span id="_CPPv3NV6RP20404i2c030clear_IC_INTR_MASK_M_START_DETEv"></span><span id="_CPPv2NV6RP20404i2c030clear_IC_INTR_MASK_M_START_DETEv"></span><span id="RP2040::i2c0::clear_IC_INTR_MASK_M_START_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1afefd62d38b2a3734499ccd60344f027c"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_INTR_MASK_M_START_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030clear_IC_INTR_MASK_M_START_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_INTR_MASK’s M_START_DET bit.</p>
<p><p>This bit masks the R_START_DET interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c031toggle_IC_INTR_MASK_M_START_DETEv">
<span id="_CPPv3NV6RP20404i2c031toggle_IC_INTR_MASK_M_START_DETEv"></span><span id="_CPPv2NV6RP20404i2c031toggle_IC_INTR_MASK_M_START_DETEv"></span><span id="RP2040::i2c0::toggle_IC_INTR_MASK_M_START_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1acc02f699dd96c55328af34a72438d73b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_INTR_MASK_M_START_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c031toggle_IC_INTR_MASK_M_START_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_INTR_MASK’s M_START_DET bit.</p>
<p><p>This bit masks the R_START_DET interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027get_IC_INTR_MASK_M_GEN_CALLEv">
<span id="_CPPv3NV6RP20404i2c027get_IC_INTR_MASK_M_GEN_CALLEv"></span><span id="_CPPv2NV6RP20404i2c027get_IC_INTR_MASK_M_GEN_CALLEv"></span><span id="RP2040::i2c0::get_IC_INTR_MASK_M_GEN_CALLV"></span><span class="target" id="structRP2040_1_1i2c0_1a8ff862657c6d281b61b3364ee77f2bf1"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_MASK_M_GEN_CALL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027get_IC_INTR_MASK_M_GEN_CALLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_MASK’s M_GEN_CALL bit.</p>
<p><p>This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027set_IC_INTR_MASK_M_GEN_CALLEv">
<span id="_CPPv3NV6RP20404i2c027set_IC_INTR_MASK_M_GEN_CALLEv"></span><span id="_CPPv2NV6RP20404i2c027set_IC_INTR_MASK_M_GEN_CALLEv"></span><span id="RP2040::i2c0::set_IC_INTR_MASK_M_GEN_CALLV"></span><span class="target" id="structRP2040_1_1i2c0_1aef7239e98f66b828a8ab7fe0d39ef770"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_INTR_MASK_M_GEN_CALL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027set_IC_INTR_MASK_M_GEN_CALLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_INTR_MASK’s M_GEN_CALL bit.</p>
<p><p>This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029clear_IC_INTR_MASK_M_GEN_CALLEv">
<span id="_CPPv3NV6RP20404i2c029clear_IC_INTR_MASK_M_GEN_CALLEv"></span><span id="_CPPv2NV6RP20404i2c029clear_IC_INTR_MASK_M_GEN_CALLEv"></span><span id="RP2040::i2c0::clear_IC_INTR_MASK_M_GEN_CALLV"></span><span class="target" id="structRP2040_1_1i2c0_1a3d1394d6f8766e6159f5b6aa8c4f5a24"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_INTR_MASK_M_GEN_CALL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029clear_IC_INTR_MASK_M_GEN_CALLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_INTR_MASK’s M_GEN_CALL bit.</p>
<p><p>This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030toggle_IC_INTR_MASK_M_GEN_CALLEv">
<span id="_CPPv3NV6RP20404i2c030toggle_IC_INTR_MASK_M_GEN_CALLEv"></span><span id="_CPPv2NV6RP20404i2c030toggle_IC_INTR_MASK_M_GEN_CALLEv"></span><span id="RP2040::i2c0::toggle_IC_INTR_MASK_M_GEN_CALLV"></span><span class="target" id="structRP2040_1_1i2c0_1ad40a8a4d864c4148e22c6f21cccc1262"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_INTR_MASK_M_GEN_CALL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030toggle_IC_INTR_MASK_M_GEN_CALLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_INTR_MASK’s M_GEN_CALL bit.</p>
<p><p>This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x1</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030get_IC_INTR_MASK_M_RESTART_DETEv">
<span id="_CPPv3NV6RP20404i2c030get_IC_INTR_MASK_M_RESTART_DETEv"></span><span id="_CPPv2NV6RP20404i2c030get_IC_INTR_MASK_M_RESTART_DETEv"></span><span id="RP2040::i2c0::get_IC_INTR_MASK_M_RESTART_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1a161fce7e9767746c042ca971c55e9566"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_MASK_M_RESTART_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030get_IC_INTR_MASK_M_RESTART_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_INTR_MASK’s M_RESTART_DET bit.</p>
<p><p>This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030set_IC_INTR_MASK_M_RESTART_DETEv">
<span id="_CPPv3NV6RP20404i2c030set_IC_INTR_MASK_M_RESTART_DETEv"></span><span id="_CPPv2NV6RP20404i2c030set_IC_INTR_MASK_M_RESTART_DETEv"></span><span id="RP2040::i2c0::set_IC_INTR_MASK_M_RESTART_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1a41bd6a726ae1ead7c0bd89e327a3302f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_INTR_MASK_M_RESTART_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030set_IC_INTR_MASK_M_RESTART_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_INTR_MASK’s M_RESTART_DET bit.</p>
<p><p>This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c032clear_IC_INTR_MASK_M_RESTART_DETEv">
<span id="_CPPv3NV6RP20404i2c032clear_IC_INTR_MASK_M_RESTART_DETEv"></span><span id="_CPPv2NV6RP20404i2c032clear_IC_INTR_MASK_M_RESTART_DETEv"></span><span id="RP2040::i2c0::clear_IC_INTR_MASK_M_RESTART_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1a69b0d0806904f43c70b196d591826153"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_INTR_MASK_M_RESTART_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c032clear_IC_INTR_MASK_M_RESTART_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_INTR_MASK’s M_RESTART_DET bit.</p>
<p><p>This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c033toggle_IC_INTR_MASK_M_RESTART_DETEv">
<span id="_CPPv3NV6RP20404i2c033toggle_IC_INTR_MASK_M_RESTART_DETEv"></span><span id="_CPPv2NV6RP20404i2c033toggle_IC_INTR_MASK_M_RESTART_DETEv"></span><span id="RP2040::i2c0::toggle_IC_INTR_MASK_M_RESTART_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1ae543c3c5f6ecf7abcd90ed05be6f6fe9"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_INTR_MASK_M_RESTART_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c033toggle_IC_INTR_MASK_M_RESTART_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_INTR_MASK’s M_RESTART_DET bit.</p>
<p><p>This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c016get_IC_INTR_MASKERbRbRbRbRbRbRbRbRbRbRbRbRb">
<span id="_CPPv3NV6RP20404i2c016get_IC_INTR_MASKERbRbRbRbRbRbRbRbRbRbRbRbRb"></span><span id="_CPPv2NV6RP20404i2c016get_IC_INTR_MASKERbRbRbRbRbRbRbRbRbRbRbRbRb"></span><span id="RP2040::i2c0::get_IC_INTR_MASK__bR.bR.bR.bR.bR.bR.bR.bR.bR.bR.bR.bR.bRV"></span><span class="target" id="structRP2040_1_1i2c0_1a1d1edca4b671d076c5f746930565042d"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_INTR_MASK</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">M_RX_UNDER</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">M_RX_OVER</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">M_RX_FULL</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">M_TX_OVER</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">M_TX_EMPTY</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">M_RD_REQ</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">M_TX_ABRT</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">M_RX_DONE</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">M_ACTIVITY</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">M_STOP_DET</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">M_START_DET</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">M_GEN_CALL</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">M_RESTART_DET</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c016get_IC_INTR_MASKERbRbRbRbRbRbRbRbRbRbRbRbRb" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get all of IC_INTR_MASK’s bit fields.</p>
<p><p>(read-write) I2C Interrupt Mask Register.</p>
<p>These bits mask their corresponding interrupt status bits. This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c016set_IC_INTR_MASKEbbbbbbbbbbbbb">
<span id="_CPPv3NV6RP20404i2c016set_IC_INTR_MASKEbbbbbbbbbbbbb"></span><span id="_CPPv2NV6RP20404i2c016set_IC_INTR_MASKEbbbbbbbbbbbbb"></span><span id="RP2040::i2c0::set_IC_INTR_MASK__b.b.b.b.b.b.b.b.b.b.b.b.bV"></span><span class="target" id="structRP2040_1_1i2c0_1ac30ca02d26c46819be94aebeaa86cac0"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_INTR_MASK</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">M_RX_UNDER</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">M_RX_OVER</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">M_RX_FULL</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">M_TX_OVER</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">M_TX_EMPTY</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">M_RD_REQ</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">M_TX_ABRT</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">M_RX_DONE</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">M_ACTIVITY</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">M_STOP_DET</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">M_START_DET</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">M_GEN_CALL</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">M_RESTART_DET</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c016set_IC_INTR_MASKEbbbbbbbbbbbbb" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set all of IC_INTR_MASK’s bit fields.</p>
<p><p>(read-write) I2C Interrupt Mask Register.</p>
<p>These bits mask their corresponding interrupt status bits. This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029get_IC_RAW_INTR_STAT_RX_UNDEREv">
<span id="_CPPv3NV6RP20404i2c029get_IC_RAW_INTR_STAT_RX_UNDEREv"></span><span id="_CPPv2NV6RP20404i2c029get_IC_RAW_INTR_STAT_RX_UNDEREv"></span><span id="RP2040::i2c0::get_IC_RAW_INTR_STAT_RX_UNDERV"></span><span class="target" id="structRP2040_1_1i2c0_1a70348e9fd59592f6e3f83556a7e566ac"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_RAW_INTR_STAT_RX_UNDER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029get_IC_RAW_INTR_STAT_RX_UNDEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_RAW_INTR_STAT’s RX_UNDER bit.</p>
<p><p>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c028get_IC_RAW_INTR_STAT_RX_OVEREv">
<span id="_CPPv3NV6RP20404i2c028get_IC_RAW_INTR_STAT_RX_OVEREv"></span><span id="_CPPv2NV6RP20404i2c028get_IC_RAW_INTR_STAT_RX_OVEREv"></span><span id="RP2040::i2c0::get_IC_RAW_INTR_STAT_RX_OVERV"></span><span class="target" id="structRP2040_1_1i2c0_1aba11c28cdcdeeb4c5f55f49fa18d8b04"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_RAW_INTR_STAT_RX_OVER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c028get_IC_RAW_INTR_STAT_RX_OVEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_RAW_INTR_STAT’s RX_OVER bit.</p>
<p><p>Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and an additional byte is received from an external I2C device. The DW_apb_i2c acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.</p>
<p>Note: If bit 9 of the IC_CON register (RX_FIFO_FULL_HLD_CTRL) is programmed to HIGH, then the RX_OVER interrupt never occurs, because the Rx FIFO never overflows.</p>

 Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c028get_IC_RAW_INTR_STAT_RX_FULLEv">
<span id="_CPPv3NV6RP20404i2c028get_IC_RAW_INTR_STAT_RX_FULLEv"></span><span id="_CPPv2NV6RP20404i2c028get_IC_RAW_INTR_STAT_RX_FULLEv"></span><span id="RP2040::i2c0::get_IC_RAW_INTR_STAT_RX_FULLV"></span><span class="target" id="structRP2040_1_1i2c0_1a08a071140bdf0488476957a81aa97403"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_RAW_INTR_STAT_RX_FULL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c028get_IC_RAW_INTR_STAT_RX_FULLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_RAW_INTR_STAT’s RX_FULL bit.</p>
<p><p>Set when the receive buffer reaches or goes above the RX_TL threshold in the IC_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (IC_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the IC_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c028get_IC_RAW_INTR_STAT_TX_OVEREv">
<span id="_CPPv3NV6RP20404i2c028get_IC_RAW_INTR_STAT_TX_OVEREv"></span><span id="_CPPv2NV6RP20404i2c028get_IC_RAW_INTR_STAT_TX_OVEREv"></span><span id="RP2040::i2c0::get_IC_RAW_INTR_STAT_TX_OVERV"></span><span class="target" id="structRP2040_1_1i2c0_1a1a7c5634c8302dfcb92b699ce9639d5b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_RAW_INTR_STAT_TX_OVER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c028get_IC_RAW_INTR_STAT_TX_OVEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_RAW_INTR_STAT’s TX_OVER bit.</p>
<p><p>Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029get_IC_RAW_INTR_STAT_TX_EMPTYEv">
<span id="_CPPv3NV6RP20404i2c029get_IC_RAW_INTR_STAT_TX_EMPTYEv"></span><span id="_CPPv2NV6RP20404i2c029get_IC_RAW_INTR_STAT_TX_EMPTYEv"></span><span id="RP2040::i2c0::get_IC_RAW_INTR_STAT_TX_EMPTYV"></span><span class="target" id="structRP2040_1_1i2c0_1a5b232fb99bbdbe786ac28e5dd3f7ea0f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_RAW_INTR_STAT_TX_EMPTY</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029get_IC_RAW_INTR_STAT_TX_EMPTYEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_RAW_INTR_STAT’s TX_EMPTY bit.</p>
<p><p>The behavior of the TX_EMPTY interrupt status differs based on the TX_EMPTY_CTRL selection in the IC_CON register. - When TX_EMPTY_CTRL = 0: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register. - When TX_EMPTY_CTRL = 1: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register and the transmission of the address/data from the internal shift register for the most recently popped command is completed. It is automatically cleared by hardware when the buffer level goes above the threshold. When IC_ENABLE[0] is set to 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer any activity, then with ic_en=0, this bit is set to 0.</p>
<p>Reset value: 0x0.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027get_IC_RAW_INTR_STAT_RD_REQEv">
<span id="_CPPv3NV6RP20404i2c027get_IC_RAW_INTR_STAT_RD_REQEv"></span><span id="_CPPv2NV6RP20404i2c027get_IC_RAW_INTR_STAT_RD_REQEv"></span><span id="RP2040::i2c0::get_IC_RAW_INTR_STAT_RD_REQV"></span><span class="target" id="structRP2040_1_1i2c0_1a568c60d332c5bf7ea16680768728984b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_RAW_INTR_STAT_RD_REQ</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027get_IC_RAW_INTR_STAT_RD_REQEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_RAW_INTR_STAT’s RD_REQ bit.</p>
<p><p>This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C master is attempting to read data from DW_apb_i2c. The DW_apb_i2c holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the IC_DATA_CMD register. This bit is set to 0 just after the processor reads the IC_CLR_RD_REQ register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c028get_IC_RAW_INTR_STAT_TX_ABRTEv">
<span id="_CPPv3NV6RP20404i2c028get_IC_RAW_INTR_STAT_TX_ABRTEv"></span><span id="_CPPv2NV6RP20404i2c028get_IC_RAW_INTR_STAT_TX_ABRTEv"></span><span id="RP2040::i2c0::get_IC_RAW_INTR_STAT_TX_ABRTV"></span><span class="target" id="structRP2040_1_1i2c0_1a47afd7aedb4ee1b12156e0b1670eb8d9"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_RAW_INTR_STAT_TX_ABRT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c028get_IC_RAW_INTR_STAT_TX_ABRTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_RAW_INTR_STAT’s TX_ABRT bit.</p>
<p><p>This bit indicates if DW_apb_i2c, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a ‘transmit abort’. When this bit is set to 1, the IC_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.</p>
<p>Note: The DW_apb_i2c flushes/resets/empties the TX_FIFO and RX_FIFO whenever there is a transmit abort caused by any of the events tracked by the IC_TX_ABRT_SOURCE register. The FIFOs remains in this flushed state until the register IC_CLR_TX_ABRT is read. Once this read is performed, the Tx FIFO is then ready to accept more data bytes from the APB interface.</p>

 Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c028get_IC_RAW_INTR_STAT_RX_DONEEv">
<span id="_CPPv3NV6RP20404i2c028get_IC_RAW_INTR_STAT_RX_DONEEv"></span><span id="_CPPv2NV6RP20404i2c028get_IC_RAW_INTR_STAT_RX_DONEEv"></span><span id="RP2040::i2c0::get_IC_RAW_INTR_STAT_RX_DONEV"></span><span class="target" id="structRP2040_1_1i2c0_1a23db2670255bd84b4673743ff3fbf4a0"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_RAW_INTR_STAT_RX_DONE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c028get_IC_RAW_INTR_STAT_RX_DONEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_RAW_INTR_STAT’s RX_DONE bit.</p>
<p><p>When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029get_IC_RAW_INTR_STAT_ACTIVITYEv">
<span id="_CPPv3NV6RP20404i2c029get_IC_RAW_INTR_STAT_ACTIVITYEv"></span><span id="_CPPv2NV6RP20404i2c029get_IC_RAW_INTR_STAT_ACTIVITYEv"></span><span id="RP2040::i2c0::get_IC_RAW_INTR_STAT_ACTIVITYV"></span><span class="target" id="structRP2040_1_1i2c0_1ac5dbafb15d11fdd9d59666dc0243334b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_RAW_INTR_STAT_ACTIVITY</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029get_IC_RAW_INTR_STAT_ACTIVITYEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_RAW_INTR_STAT’s ACTIVITY bit.</p>
<p><p>This bit captures DW_apb_i2c activity and stays set until it is cleared. There are four ways to clear it: - Disabling the DW_apb_i2c - Reading the IC_CLR_ACTIVITY register - Reading the IC_CLR_INTR register - System reset Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the DW_apb_i2c module is idle, this bit remains set until cleared, indicating that there was activity on the bus.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029get_IC_RAW_INTR_STAT_STOP_DETEv">
<span id="_CPPv3NV6RP20404i2c029get_IC_RAW_INTR_STAT_STOP_DETEv"></span><span id="_CPPv2NV6RP20404i2c029get_IC_RAW_INTR_STAT_STOP_DETEv"></span><span id="RP2040::i2c0::get_IC_RAW_INTR_STAT_STOP_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1a0ee964bf4316244b8e2e321c0d803135"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_RAW_INTR_STAT_STOP_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029get_IC_RAW_INTR_STAT_STOP_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_RAW_INTR_STAT’s STOP_DET bit.</p>
<p><p>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.</p>
<p>In Slave Mode: - If IC_CON[7]=1’b1 (STOP_DET_IFADDRESSED), the STOP_DET interrupt will be issued only if slave is addressed. Note: During a general call address, this slave does not issue a STOP_DET interrupt if STOP_DET_IF_ADDRESSED=1’b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR). - If IC_CON[7]=1’b0 (STOP_DET_IFADDRESSED), the STOP_DET interrupt is issued irrespective of whether it is being addressed. In Master Mode: - If IC_CON[10]=1’b1 (STOP_DET_IF_MASTER_ACTIVE),the STOP_DET interrupt will be issued only if Master is active. - If IC_CON[10]=1’b0 (STOP_DET_IFADDRESSED),the STOP_DET interrupt will be issued irrespective of whether master is active or not. Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030get_IC_RAW_INTR_STAT_START_DETEv">
<span id="_CPPv3NV6RP20404i2c030get_IC_RAW_INTR_STAT_START_DETEv"></span><span id="_CPPv2NV6RP20404i2c030get_IC_RAW_INTR_STAT_START_DETEv"></span><span id="RP2040::i2c0::get_IC_RAW_INTR_STAT_START_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1a1ef9234a5d258a630bc4bff39220f70f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_RAW_INTR_STAT_START_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030get_IC_RAW_INTR_STAT_START_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_RAW_INTR_STAT’s START_DET bit.</p>
<p><p>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029get_IC_RAW_INTR_STAT_GEN_CALLEv">
<span id="_CPPv3NV6RP20404i2c029get_IC_RAW_INTR_STAT_GEN_CALLEv"></span><span id="_CPPv2NV6RP20404i2c029get_IC_RAW_INTR_STAT_GEN_CALLEv"></span><span id="RP2040::i2c0::get_IC_RAW_INTR_STAT_GEN_CALLV"></span><span class="target" id="structRP2040_1_1i2c0_1aeec92ada4ac469f2ad765eaf3196ff34"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_RAW_INTR_STAT_GEN_CALL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029get_IC_RAW_INTR_STAT_GEN_CALLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_RAW_INTR_STAT’s GEN_CALL bit.</p>
<p><p>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling DW_apb_i2c or when the CPU reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores the received data in the Rx buffer.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c032get_IC_RAW_INTR_STAT_RESTART_DETEv">
<span id="_CPPv3NV6RP20404i2c032get_IC_RAW_INTR_STAT_RESTART_DETEv"></span><span id="_CPPv2NV6RP20404i2c032get_IC_RAW_INTR_STAT_RESTART_DETEv"></span><span id="RP2040::i2c0::get_IC_RAW_INTR_STAT_RESTART_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1a033ef797ecc78d09e3079b7cbdd6940f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_RAW_INTR_STAT_RESTART_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c032get_IC_RAW_INTR_STAT_RESTART_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_RAW_INTR_STAT’s RESTART_DET bit.</p>
<p><p>Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed. Enabled only when IC_SLV_RESTART_DET_EN=1.</p>
<p>Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt.</p>

 Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c020get_IC_RAW_INTR_STATERbRbRbRbRbRbRbRbRbRbRbRbRb">
<span id="_CPPv3NV6RP20404i2c020get_IC_RAW_INTR_STATERbRbRbRbRbRbRbRbRbRbRbRbRb"></span><span id="_CPPv2NV6RP20404i2c020get_IC_RAW_INTR_STATERbRbRbRbRbRbRbRbRbRbRbRbRb"></span><span id="RP2040::i2c0::get_IC_RAW_INTR_STAT__bR.bR.bR.bR.bR.bR.bR.bR.bR.bR.bR.bR.bRV"></span><span class="target" id="structRP2040_1_1i2c0_1a4bc26aec685bbc9136da5390e7167d1f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_RAW_INTR_STAT</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">RX_UNDER</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">RX_OVER</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">RX_FULL</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">TX_OVER</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">TX_EMPTY</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">RD_REQ</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">TX_ABRT</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">RX_DONE</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ACTIVITY</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">STOP_DET</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">START_DET</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">GEN_CALL</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">RESTART_DET</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c020get_IC_RAW_INTR_STATERbRbRbRbRbRbRbRbRbRbRbRbRb" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get all of IC_RAW_INTR_STAT’s bit fields.</p>
<p><p>(read-only) I2C Raw Interrupt Status Register</p>
<p>Unlike the IC_INTR_STAT register, these bits are not masked so they always show the true status of the DW_apb_i2c.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c018get_IC_RX_TL_RX_TLEv">
<span id="_CPPv3NV6RP20404i2c018get_IC_RX_TL_RX_TLEv"></span><span id="_CPPv2NV6RP20404i2c018get_IC_RX_TL_RX_TLEv"></span><span id="RP2040::i2c0::get_IC_RX_TL_RX_TLV"></span><span class="target" id="structRP2040_1_1i2c0_1afb7f45f879761bd1e3ebe5834210cbc0"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_RX_TL_RX_TL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c018get_IC_RX_TL_RX_TLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_RX_TL’s RX_TL field.</p>
<p><p>Receive FIFO Threshold Level.</p>
<p>Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 255 sets the threshold for 256 entries.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c018set_IC_RX_TL_RX_TLE7uint8_t">
<span id="_CPPv3NV6RP20404i2c018set_IC_RX_TL_RX_TLE7uint8_t"></span><span id="_CPPv2NV6RP20404i2c018set_IC_RX_TL_RX_TLE7uint8_t"></span><span id="RP2040::i2c0::set_IC_RX_TL_RX_TL__uint8_tV"></span><span class="target" id="structRP2040_1_1i2c0_1a040f0df6747b8d7d0ec030f201cc0f24"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_RX_TL_RX_TL</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c018set_IC_RX_TL_RX_TLE7uint8_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_RX_TL’s RX_TL field.</p>
<p><p>Receive FIFO Threshold Level.</p>
<p>Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 255 sets the threshold for 256 entries.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c018get_IC_TX_TL_TX_TLEv">
<span id="_CPPv3NV6RP20404i2c018get_IC_TX_TL_TX_TLEv"></span><span id="_CPPv2NV6RP20404i2c018get_IC_TX_TL_TX_TLEv"></span><span id="RP2040::i2c0::get_IC_TX_TL_TX_TLV"></span><span class="target" id="structRP2040_1_1i2c0_1aa36d8e365352fb210b5f18d3383e9095"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_TL_TX_TL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c018get_IC_TX_TL_TX_TLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_TL’s TX_TL field.</p>
<p><p>Transmit FIFO Threshold Level.</p>
<p>Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 255 sets the threshold for 255 entries.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c018set_IC_TX_TL_TX_TLE7uint8_t">
<span id="_CPPv3NV6RP20404i2c018set_IC_TX_TL_TX_TLE7uint8_t"></span><span id="_CPPv2NV6RP20404i2c018set_IC_TX_TL_TX_TLE7uint8_t"></span><span id="RP2040::i2c0::set_IC_TX_TL_TX_TL__uint8_tV"></span><span class="target" id="structRP2040_1_1i2c0_1a1ed3496b08b61ac6150d92221c77e2fe"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_TX_TL_TX_TL</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c018set_IC_TX_TL_TX_TLE7uint8_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_TX_TL’s TX_TL field.</p>
<p><p>Transmit FIFO Threshold Level.</p>
<p>Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 255 sets the threshold for 255 entries.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c024get_IC_CLR_INTR_CLR_INTREv">
<span id="_CPPv3NV6RP20404i2c024get_IC_CLR_INTR_CLR_INTREv"></span><span id="_CPPv2NV6RP20404i2c024get_IC_CLR_INTR_CLR_INTREv"></span><span id="RP2040::i2c0::get_IC_CLR_INTR_CLR_INTRV"></span><span class="target" id="structRP2040_1_1i2c0_1ad7892469b1d58cb6b55e125388d4df49"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CLR_INTR_CLR_INTR</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c024get_IC_CLR_INTR_CLR_INTREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CLR_INTR’s CLR_INTR bit.</p>
<p><p>Read this register to clear the combined interrupt, all individual interrupts, and the IC_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c032get_IC_CLR_RX_UNDER_CLR_RX_UNDEREv">
<span id="_CPPv3NV6RP20404i2c032get_IC_CLR_RX_UNDER_CLR_RX_UNDEREv"></span><span id="_CPPv2NV6RP20404i2c032get_IC_CLR_RX_UNDER_CLR_RX_UNDEREv"></span><span id="RP2040::i2c0::get_IC_CLR_RX_UNDER_CLR_RX_UNDERV"></span><span class="target" id="structRP2040_1_1i2c0_1a739d4959576ebc5ee6adc419fe61f7f7"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CLR_RX_UNDER_CLR_RX_UNDER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c032get_IC_CLR_RX_UNDER_CLR_RX_UNDEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CLR_RX_UNDER’s CLR_RX_UNDER bit.</p>
<p><p>Read this register to clear the RX_UNDER interrupt (bit 0) of the IC_RAW_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030get_IC_CLR_RX_OVER_CLR_RX_OVEREv">
<span id="_CPPv3NV6RP20404i2c030get_IC_CLR_RX_OVER_CLR_RX_OVEREv"></span><span id="_CPPv2NV6RP20404i2c030get_IC_CLR_RX_OVER_CLR_RX_OVEREv"></span><span id="RP2040::i2c0::get_IC_CLR_RX_OVER_CLR_RX_OVERV"></span><span class="target" id="structRP2040_1_1i2c0_1af3afb303b44d823279cab6f2bce47739"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CLR_RX_OVER_CLR_RX_OVER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030get_IC_CLR_RX_OVER_CLR_RX_OVEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CLR_RX_OVER’s CLR_RX_OVER bit.</p>
<p><p>Read this register to clear the RX_OVER interrupt (bit 1) of the IC_RAW_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030get_IC_CLR_TX_OVER_CLR_TX_OVEREv">
<span id="_CPPv3NV6RP20404i2c030get_IC_CLR_TX_OVER_CLR_TX_OVEREv"></span><span id="_CPPv2NV6RP20404i2c030get_IC_CLR_TX_OVER_CLR_TX_OVEREv"></span><span id="RP2040::i2c0::get_IC_CLR_TX_OVER_CLR_TX_OVERV"></span><span class="target" id="structRP2040_1_1i2c0_1a292d7a0e111c44816f30eee608712f56"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CLR_TX_OVER_CLR_TX_OVER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030get_IC_CLR_TX_OVER_CLR_TX_OVEREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CLR_TX_OVER’s CLR_TX_OVER bit.</p>
<p><p>Read this register to clear the TX_OVER interrupt (bit 3) of the IC_RAW_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c028get_IC_CLR_RD_REQ_CLR_RD_REQEv">
<span id="_CPPv3NV6RP20404i2c028get_IC_CLR_RD_REQ_CLR_RD_REQEv"></span><span id="_CPPv2NV6RP20404i2c028get_IC_CLR_RD_REQ_CLR_RD_REQEv"></span><span id="RP2040::i2c0::get_IC_CLR_RD_REQ_CLR_RD_REQV"></span><span class="target" id="structRP2040_1_1i2c0_1ae23d02fba436dda5ec4fdef74de21891"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CLR_RD_REQ_CLR_RD_REQ</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c028get_IC_CLR_RD_REQ_CLR_RD_REQEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CLR_RD_REQ’s CLR_RD_REQ bit.</p>
<p><p>Read this register to clear the RD_REQ interrupt (bit 5) of the IC_RAW_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030get_IC_CLR_TX_ABRT_CLR_TX_ABRTEv">
<span id="_CPPv3NV6RP20404i2c030get_IC_CLR_TX_ABRT_CLR_TX_ABRTEv"></span><span id="_CPPv2NV6RP20404i2c030get_IC_CLR_TX_ABRT_CLR_TX_ABRTEv"></span><span id="RP2040::i2c0::get_IC_CLR_TX_ABRT_CLR_TX_ABRTV"></span><span class="target" id="structRP2040_1_1i2c0_1ad5c07c0e4355dece557bd3bae468f4e6"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CLR_TX_ABRT_CLR_TX_ABRT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030get_IC_CLR_TX_ABRT_CLR_TX_ABRTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CLR_TX_ABRT’s CLR_TX_ABRT bit.</p>
<p><p>Read this register to clear the TX_ABRT interrupt (bit 6) of the IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030get_IC_CLR_RX_DONE_CLR_RX_DONEEv">
<span id="_CPPv3NV6RP20404i2c030get_IC_CLR_RX_DONE_CLR_RX_DONEEv"></span><span id="_CPPv2NV6RP20404i2c030get_IC_CLR_RX_DONE_CLR_RX_DONEEv"></span><span id="RP2040::i2c0::get_IC_CLR_RX_DONE_CLR_RX_DONEV"></span><span class="target" id="structRP2040_1_1i2c0_1a6b52fc83244b256582307e76c820454b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CLR_RX_DONE_CLR_RX_DONE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030get_IC_CLR_RX_DONE_CLR_RX_DONEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CLR_RX_DONE’s CLR_RX_DONE bit.</p>
<p><p>Read this register to clear the RX_DONE interrupt (bit 7) of the IC_RAW_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c032get_IC_CLR_ACTIVITY_CLR_ACTIVITYEv">
<span id="_CPPv3NV6RP20404i2c032get_IC_CLR_ACTIVITY_CLR_ACTIVITYEv"></span><span id="_CPPv2NV6RP20404i2c032get_IC_CLR_ACTIVITY_CLR_ACTIVITYEv"></span><span id="RP2040::i2c0::get_IC_CLR_ACTIVITY_CLR_ACTIVITYV"></span><span class="target" id="structRP2040_1_1i2c0_1a12d20c34690732a1e124df17908d89e5"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CLR_ACTIVITY_CLR_ACTIVITY</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c032get_IC_CLR_ACTIVITY_CLR_ACTIVITYEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CLR_ACTIVITY’s CLR_ACTIVITY bit.</p>
<p><p>Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c032get_IC_CLR_STOP_DET_CLR_STOP_DETEv">
<span id="_CPPv3NV6RP20404i2c032get_IC_CLR_STOP_DET_CLR_STOP_DETEv"></span><span id="_CPPv2NV6RP20404i2c032get_IC_CLR_STOP_DET_CLR_STOP_DETEv"></span><span id="RP2040::i2c0::get_IC_CLR_STOP_DET_CLR_STOP_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1a30840b71b0022d35a1218f47a69616b7"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CLR_STOP_DET_CLR_STOP_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c032get_IC_CLR_STOP_DET_CLR_STOP_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CLR_STOP_DET’s CLR_STOP_DET bit.</p>
<p><p>Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c034get_IC_CLR_START_DET_CLR_START_DETEv">
<span id="_CPPv3NV6RP20404i2c034get_IC_CLR_START_DET_CLR_START_DETEv"></span><span id="_CPPv2NV6RP20404i2c034get_IC_CLR_START_DET_CLR_START_DETEv"></span><span id="RP2040::i2c0::get_IC_CLR_START_DET_CLR_START_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1a32f691bcd63cdc0dc5ab79659cd2fab3"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CLR_START_DET_CLR_START_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c034get_IC_CLR_START_DET_CLR_START_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CLR_START_DET’s CLR_START_DET bit.</p>
<p><p>Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c032get_IC_CLR_GEN_CALL_CLR_GEN_CALLEv">
<span id="_CPPv3NV6RP20404i2c032get_IC_CLR_GEN_CALL_CLR_GEN_CALLEv"></span><span id="_CPPv2NV6RP20404i2c032get_IC_CLR_GEN_CALL_CLR_GEN_CALLEv"></span><span id="RP2040::i2c0::get_IC_CLR_GEN_CALL_CLR_GEN_CALLV"></span><span class="target" id="structRP2040_1_1i2c0_1aaaf966e7ea28969f3334861b2bd02854"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CLR_GEN_CALL_CLR_GEN_CALL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c032get_IC_CLR_GEN_CALL_CLR_GEN_CALLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CLR_GEN_CALL’s CLR_GEN_CALL bit.</p>
<p><p>Read this register to clear the GEN_CALL interrupt (bit 11) of IC_RAW_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c020get_IC_ENABLE_ENABLEEv">
<span id="_CPPv3NV6RP20404i2c020get_IC_ENABLE_ENABLEEv"></span><span id="_CPPv2NV6RP20404i2c020get_IC_ENABLE_ENABLEEv"></span><span id="RP2040::i2c0::get_IC_ENABLE_ENABLEV"></span><span class="target" id="structRP2040_1_1i2c0_1ac7e39b9ab2ac92d19e0f5cee845d80c9"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_ENABLE_ENABLE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c020get_IC_ENABLE_ENABLEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_ENABLE’s ENABLE bit.</p>
<p><p>Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable DW_apb_i2c while it is active. However, it is important that care be taken to ensure that DW_apb_i2c is disabled properly. A recommended procedure is described in ‘Disabling DW_apb_i2c’.</p>
<p>When DW_apb_i2c is disabled, the following occurs: - The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT register are still active until DW_apb_i2c goes into IDLE state. If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the DW_apb_i2c stops the current transfer at the end of the current byte and does not acknowledge the transfer.</p>
<p>In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to asynchronous (1), there is a two ic_clk delay when enabling or disabling the DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c, refer to ‘Disabling DW_apb_i2c’</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c020set_IC_ENABLE_ENABLEEv">
<span id="_CPPv3NV6RP20404i2c020set_IC_ENABLE_ENABLEEv"></span><span id="_CPPv2NV6RP20404i2c020set_IC_ENABLE_ENABLEEv"></span><span id="RP2040::i2c0::set_IC_ENABLE_ENABLEV"></span><span class="target" id="structRP2040_1_1i2c0_1acc0304504ae7efb9e5ee4bb88f2e7758"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_ENABLE_ENABLE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c020set_IC_ENABLE_ENABLEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_ENABLE’s ENABLE bit.</p>
<p><p>Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable DW_apb_i2c while it is active. However, it is important that care be taken to ensure that DW_apb_i2c is disabled properly. A recommended procedure is described in ‘Disabling DW_apb_i2c’.</p>
<p>When DW_apb_i2c is disabled, the following occurs: - The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT register are still active until DW_apb_i2c goes into IDLE state. If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the DW_apb_i2c stops the current transfer at the end of the current byte and does not acknowledge the transfer.</p>
<p>In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to asynchronous (1), there is a two ic_clk delay when enabling or disabling the DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c, refer to ‘Disabling DW_apb_i2c’</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c022clear_IC_ENABLE_ENABLEEv">
<span id="_CPPv3NV6RP20404i2c022clear_IC_ENABLE_ENABLEEv"></span><span id="_CPPv2NV6RP20404i2c022clear_IC_ENABLE_ENABLEEv"></span><span id="RP2040::i2c0::clear_IC_ENABLE_ENABLEV"></span><span class="target" id="structRP2040_1_1i2c0_1a411448dd7bbc1207cb36eebba2f7f5f7"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_ENABLE_ENABLE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c022clear_IC_ENABLE_ENABLEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_ENABLE’s ENABLE bit.</p>
<p><p>Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable DW_apb_i2c while it is active. However, it is important that care be taken to ensure that DW_apb_i2c is disabled properly. A recommended procedure is described in ‘Disabling DW_apb_i2c’.</p>
<p>When DW_apb_i2c is disabled, the following occurs: - The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT register are still active until DW_apb_i2c goes into IDLE state. If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the DW_apb_i2c stops the current transfer at the end of the current byte and does not acknowledge the transfer.</p>
<p>In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to asynchronous (1), there is a two ic_clk delay when enabling or disabling the DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c, refer to ‘Disabling DW_apb_i2c’</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c023toggle_IC_ENABLE_ENABLEEv">
<span id="_CPPv3NV6RP20404i2c023toggle_IC_ENABLE_ENABLEEv"></span><span id="_CPPv2NV6RP20404i2c023toggle_IC_ENABLE_ENABLEEv"></span><span id="RP2040::i2c0::toggle_IC_ENABLE_ENABLEV"></span><span class="target" id="structRP2040_1_1i2c0_1ae286fef7f4f2791b81b248d14e393a85"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_ENABLE_ENABLE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c023toggle_IC_ENABLE_ENABLEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_ENABLE’s ENABLE bit.</p>
<p><p>Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable DW_apb_i2c while it is active. However, it is important that care be taken to ensure that DW_apb_i2c is disabled properly. A recommended procedure is described in ‘Disabling DW_apb_i2c’.</p>
<p>When DW_apb_i2c is disabled, the following occurs: - The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT register are still active until DW_apb_i2c goes into IDLE state. If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the DW_apb_i2c stops the current transfer at the end of the current byte and does not acknowledge the transfer.</p>
<p>In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to asynchronous (1), there is a two ic_clk delay when enabling or disabling the DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c, refer to ‘Disabling DW_apb_i2c’</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c019get_IC_ENABLE_ABORTEv">
<span id="_CPPv3NV6RP20404i2c019get_IC_ENABLE_ABORTEv"></span><span id="_CPPv2NV6RP20404i2c019get_IC_ENABLE_ABORTEv"></span><span id="RP2040::i2c0::get_IC_ENABLE_ABORTV"></span><span class="target" id="structRP2040_1_1i2c0_1a9dff460e108a571d405aab74193e8047"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_ENABLE_ABORT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c019get_IC_ENABLE_ABORTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_ENABLE’s ABORT bit.</p>
<p><p>When set, the controller initiates the transfer abort. - 0: ABORT not initiated or ABORT done - 1: ABORT operation in progress The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation.</p>
<p>For a detailed description on how to abort I2C transfers, refer to ‘Aborting I2C Transfers’.</p>

 Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c019set_IC_ENABLE_ABORTEv">
<span id="_CPPv3NV6RP20404i2c019set_IC_ENABLE_ABORTEv"></span><span id="_CPPv2NV6RP20404i2c019set_IC_ENABLE_ABORTEv"></span><span id="RP2040::i2c0::set_IC_ENABLE_ABORTV"></span><span class="target" id="structRP2040_1_1i2c0_1a923202fb2a5dd76fb7714ef2d2d7adde"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_ENABLE_ABORT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c019set_IC_ENABLE_ABORTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_ENABLE’s ABORT bit.</p>
<p><p>When set, the controller initiates the transfer abort. - 0: ABORT not initiated or ABORT done - 1: ABORT operation in progress The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation.</p>
<p>For a detailed description on how to abort I2C transfers, refer to ‘Aborting I2C Transfers’.</p>

 Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c021clear_IC_ENABLE_ABORTEv">
<span id="_CPPv3NV6RP20404i2c021clear_IC_ENABLE_ABORTEv"></span><span id="_CPPv2NV6RP20404i2c021clear_IC_ENABLE_ABORTEv"></span><span id="RP2040::i2c0::clear_IC_ENABLE_ABORTV"></span><span class="target" id="structRP2040_1_1i2c0_1adbfc87552fa09aded03878c739670a45"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_ENABLE_ABORT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c021clear_IC_ENABLE_ABORTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_ENABLE’s ABORT bit.</p>
<p><p>When set, the controller initiates the transfer abort. - 0: ABORT not initiated or ABORT done - 1: ABORT operation in progress The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation.</p>
<p>For a detailed description on how to abort I2C transfers, refer to ‘Aborting I2C Transfers’.</p>

 Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c022toggle_IC_ENABLE_ABORTEv">
<span id="_CPPv3NV6RP20404i2c022toggle_IC_ENABLE_ABORTEv"></span><span id="_CPPv2NV6RP20404i2c022toggle_IC_ENABLE_ABORTEv"></span><span id="RP2040::i2c0::toggle_IC_ENABLE_ABORTV"></span><span class="target" id="structRP2040_1_1i2c0_1a1743037269ed8445d7f86fea60135a6e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_ENABLE_ABORT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c022toggle_IC_ENABLE_ABORTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_ENABLE’s ABORT bit.</p>
<p><p>When set, the controller initiates the transfer abort. - 0: ABORT not initiated or ABORT done - 1: ABORT operation in progress The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation.</p>
<p>For a detailed description on how to abort I2C transfers, refer to ‘Aborting I2C Transfers’.</p>

 Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026get_IC_ENABLE_TX_CMD_BLOCKEv">
<span id="_CPPv3NV6RP20404i2c026get_IC_ENABLE_TX_CMD_BLOCKEv"></span><span id="_CPPv2NV6RP20404i2c026get_IC_ENABLE_TX_CMD_BLOCKEv"></span><span id="RP2040::i2c0::get_IC_ENABLE_TX_CMD_BLOCKV"></span><span class="target" id="structRP2040_1_1i2c0_1a535b96f442403e5b3b3d48178e6b4bdd"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_ENABLE_TX_CMD_BLOCK</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026get_IC_ENABLE_TX_CMD_BLOCKEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_ENABLE’s TX_CMD_BLOCK bit.</p>
<p>In Master mode: - 1’b1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit. - 1’b0: The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. Note: To block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value: IC_TX_CMD_BLOCK_DEFAULT </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026set_IC_ENABLE_TX_CMD_BLOCKEv">
<span id="_CPPv3NV6RP20404i2c026set_IC_ENABLE_TX_CMD_BLOCKEv"></span><span id="_CPPv2NV6RP20404i2c026set_IC_ENABLE_TX_CMD_BLOCKEv"></span><span id="RP2040::i2c0::set_IC_ENABLE_TX_CMD_BLOCKV"></span><span class="target" id="structRP2040_1_1i2c0_1a9c1e2d7f9fe3d84802acda1cc8237250"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_ENABLE_TX_CMD_BLOCK</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026set_IC_ENABLE_TX_CMD_BLOCKEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_ENABLE’s TX_CMD_BLOCK bit.</p>
<p>In Master mode: - 1’b1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit. - 1’b0: The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. Note: To block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value: IC_TX_CMD_BLOCK_DEFAULT </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c028clear_IC_ENABLE_TX_CMD_BLOCKEv">
<span id="_CPPv3NV6RP20404i2c028clear_IC_ENABLE_TX_CMD_BLOCKEv"></span><span id="_CPPv2NV6RP20404i2c028clear_IC_ENABLE_TX_CMD_BLOCKEv"></span><span id="RP2040::i2c0::clear_IC_ENABLE_TX_CMD_BLOCKV"></span><span class="target" id="structRP2040_1_1i2c0_1a5c21be25094fc3df11aada4f9beba67b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_ENABLE_TX_CMD_BLOCK</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c028clear_IC_ENABLE_TX_CMD_BLOCKEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_ENABLE’s TX_CMD_BLOCK bit.</p>
<p>In Master mode: - 1’b1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit. - 1’b0: The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. Note: To block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value: IC_TX_CMD_BLOCK_DEFAULT </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029toggle_IC_ENABLE_TX_CMD_BLOCKEv">
<span id="_CPPv3NV6RP20404i2c029toggle_IC_ENABLE_TX_CMD_BLOCKEv"></span><span id="_CPPv2NV6RP20404i2c029toggle_IC_ENABLE_TX_CMD_BLOCKEv"></span><span id="RP2040::i2c0::toggle_IC_ENABLE_TX_CMD_BLOCKV"></span><span class="target" id="structRP2040_1_1i2c0_1a8f945e0fa9ed8e2850f36ec9bbd15b06"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_ENABLE_TX_CMD_BLOCK</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029toggle_IC_ENABLE_TX_CMD_BLOCKEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_ENABLE’s TX_CMD_BLOCK bit.</p>
<p>In Master mode: - 1’b1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit. - 1’b0: The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. Note: To block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value: IC_TX_CMD_BLOCK_DEFAULT </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c013get_IC_ENABLEERbRbRb">
<span id="_CPPv3NV6RP20404i2c013get_IC_ENABLEERbRbRb"></span><span id="_CPPv2NV6RP20404i2c013get_IC_ENABLEERbRbRb"></span><span id="RP2040::i2c0::get_IC_ENABLE__bR.bR.bRV"></span><span class="target" id="structRP2040_1_1i2c0_1aa811d45178f9ad598752b54e5ee87721"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_ENABLE</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ENABLE</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ABORT</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">TX_CMD_BLOCK</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c013get_IC_ENABLEERbRbRb" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get all of IC_ENABLE’s bit fields.</p>
<p>(read-write) I2C Enable Register </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c013set_IC_ENABLEEbbb">
<span id="_CPPv3NV6RP20404i2c013set_IC_ENABLEEbbb"></span><span id="_CPPv2NV6RP20404i2c013set_IC_ENABLEEbbb"></span><span id="RP2040::i2c0::set_IC_ENABLE__b.b.bV"></span><span class="target" id="structRP2040_1_1i2c0_1aa63eed2b00ef9c8e16a09055f628c60e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_ENABLE</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ENABLE</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ABORT</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">TX_CMD_BLOCK</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c013set_IC_ENABLEEbbb" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set all of IC_ENABLE’s bit fields.</p>
<p>(read-write) I2C Enable Register </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c022get_IC_STATUS_ACTIVITYEv">
<span id="_CPPv3NV6RP20404i2c022get_IC_STATUS_ACTIVITYEv"></span><span id="_CPPv2NV6RP20404i2c022get_IC_STATUS_ACTIVITYEv"></span><span id="RP2040::i2c0::get_IC_STATUS_ACTIVITYV"></span><span class="target" id="structRP2040_1_1i2c0_1ab05ccc1c567ca220b9314d5c31fa9d6e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_STATUS_ACTIVITY</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c022get_IC_STATUS_ACTIVITYEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_STATUS’s ACTIVITY bit.</p>
<p>I2C Activity Status. Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c018get_IC_STATUS_TFNFEv">
<span id="_CPPv3NV6RP20404i2c018get_IC_STATUS_TFNFEv"></span><span id="_CPPv2NV6RP20404i2c018get_IC_STATUS_TFNFEv"></span><span id="RP2040::i2c0::get_IC_STATUS_TFNFV"></span><span class="target" id="structRP2040_1_1i2c0_1a5ca4149109a88a10ad74d93a1ca2f0aa"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_STATUS_TFNF</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c018get_IC_STATUS_TFNFEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_STATUS’s TFNF bit.</p>
<p>Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full. - 0: Transmit FIFO is full - 1: Transmit FIFO is not full Reset value: 0x1 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c017get_IC_STATUS_TFEEv">
<span id="_CPPv3NV6RP20404i2c017get_IC_STATUS_TFEEv"></span><span id="_CPPv2NV6RP20404i2c017get_IC_STATUS_TFEEv"></span><span id="RP2040::i2c0::get_IC_STATUS_TFEV"></span><span class="target" id="structRP2040_1_1i2c0_1a07c0dc9993244888674c4ec059a1eae4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_STATUS_TFE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c017get_IC_STATUS_TFEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_STATUS’s TFE bit.</p>
<p>Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt. - 0: Transmit FIFO is not empty - 1: Transmit FIFO is empty Reset value: 0x1 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c018get_IC_STATUS_RFNEEv">
<span id="_CPPv3NV6RP20404i2c018get_IC_STATUS_RFNEEv"></span><span id="_CPPv2NV6RP20404i2c018get_IC_STATUS_RFNEEv"></span><span id="RP2040::i2c0::get_IC_STATUS_RFNEV"></span><span class="target" id="structRP2040_1_1i2c0_1abe36312ba110e78e8bee71a8b683eab4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_STATUS_RFNE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c018get_IC_STATUS_RFNEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_STATUS’s RFNE bit.</p>
<p>Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty. - 0: Receive FIFO is empty - 1: Receive FIFO is not empty Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c017get_IC_STATUS_RFFEv">
<span id="_CPPv3NV6RP20404i2c017get_IC_STATUS_RFFEv"></span><span id="_CPPv2NV6RP20404i2c017get_IC_STATUS_RFFEv"></span><span id="RP2040::i2c0::get_IC_STATUS_RFFV"></span><span class="target" id="structRP2040_1_1i2c0_1adcb16f300e97ec5b01d7c1f1338328bd"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_STATUS_RFF</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c017get_IC_STATUS_RFFEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_STATUS’s RFF bit.</p>
<p>Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared. - 0: Receive FIFO is not full - 1: Receive FIFO is full Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026get_IC_STATUS_MST_ACTIVITYEv">
<span id="_CPPv3NV6RP20404i2c026get_IC_STATUS_MST_ACTIVITYEv"></span><span id="_CPPv2NV6RP20404i2c026get_IC_STATUS_MST_ACTIVITYEv"></span><span id="RP2040::i2c0::get_IC_STATUS_MST_ACTIVITYV"></span><span class="target" id="structRP2040_1_1i2c0_1a1509e34e9fd738caaa3dc56813840eec"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_STATUS_MST_ACTIVITY</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026get_IC_STATUS_MST_ACTIVITYEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_STATUS’s MST_ACTIVITY bit.</p>
<p><p>Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Master FSM is in IDLE state so the Master part of DW_apb_i2c is not Active - 1: Master FSM is not in IDLE state so the Master part of DW_apb_i2c is Active Note: IC_STATUS[0]-that is, ACTIVITY bit-is the OR of SLV_ACTIVITY and MST_ACTIVITY bits.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026get_IC_STATUS_SLV_ACTIVITYEv">
<span id="_CPPv3NV6RP20404i2c026get_IC_STATUS_SLV_ACTIVITYEv"></span><span id="_CPPv2NV6RP20404i2c026get_IC_STATUS_SLV_ACTIVITYEv"></span><span id="RP2040::i2c0::get_IC_STATUS_SLV_ACTIVITYV"></span><span class="target" id="structRP2040_1_1i2c0_1af5c4f1ca34ac67a2e17daf14b4b89af8"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_STATUS_SLV_ACTIVITY</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026get_IC_STATUS_SLV_ACTIVITYEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_STATUS’s SLV_ACTIVITY bit.</p>
<p>Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Slave FSM is in IDLE state so the Slave part of DW_apb_i2c is not Active - 1: Slave FSM is not in IDLE state so the Slave part of DW_apb_i2c is Active Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c013get_IC_STATUSERbRbRbRbRbRbRb">
<span id="_CPPv3NV6RP20404i2c013get_IC_STATUSERbRbRbRbRbRbRb"></span><span id="_CPPv2NV6RP20404i2c013get_IC_STATUSERbRbRbRbRbRbRb"></span><span id="RP2040::i2c0::get_IC_STATUS__bR.bR.bR.bR.bR.bR.bRV"></span><span class="target" id="structRP2040_1_1i2c0_1a5ad27e249008b046580e6b3c1f298794"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_STATUS</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ACTIVITY</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">TFNF</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">TFE</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">RFNE</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">RFF</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">MST_ACTIVITY</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">SLV_ACTIVITY</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c013get_IC_STATUSERbRbRbRbRbRbRb" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get all of IC_STATUS’s bit fields.</p>
<p><p>(read-only) I2C Status Register</p>
<p>This is a read-only register used to indicate the current transfer status and FIFO status. The status register may be read at any time. None of the bits in this register request an interrupt.</p>

 When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state machines goes to idle and ic_en=0: - Bits 5 and 6 are set to 0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c018get_IC_TXFLR_TXFLREv">
<span id="_CPPv3NV6RP20404i2c018get_IC_TXFLR_TXFLREv"></span><span id="_CPPv2NV6RP20404i2c018get_IC_TXFLR_TXFLREv"></span><span id="RP2040::i2c0::get_IC_TXFLR_TXFLRV"></span><span class="target" id="structRP2040_1_1i2c0_1a32cf6e2759e190b822106d942b3d7eae"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TXFLR_TXFLR</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c018get_IC_TXFLR_TXFLREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TXFLR’s TXFLR field.</p>
<p><p>Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c018get_IC_RXFLR_RXFLREv">
<span id="_CPPv3NV6RP20404i2c018get_IC_RXFLR_RXFLREv"></span><span id="_CPPv2NV6RP20404i2c018get_IC_RXFLR_RXFLREv"></span><span id="RP2040::i2c0::get_IC_RXFLR_RXFLRV"></span><span class="target" id="structRP2040_1_1i2c0_1adfa1b305386284be18ad1a1684b76bc2"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_RXFLR_RXFLR</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c018get_IC_RXFLR_RXFLREv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_RXFLR’s RXFLR field.</p>
<p><p>Receive FIFO Level. Contains the number of valid data entries in the receive FIFO.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030get_IC_SDA_HOLD_IC_SDA_TX_HOLDEv">
<span id="_CPPv3NV6RP20404i2c030get_IC_SDA_HOLD_IC_SDA_TX_HOLDEv"></span><span id="_CPPv2NV6RP20404i2c030get_IC_SDA_HOLD_IC_SDA_TX_HOLDEv"></span><span id="RP2040::i2c0::get_IC_SDA_HOLD_IC_SDA_TX_HOLDV"></span><span class="target" id="structRP2040_1_1i2c0_1a245098bac8626628bd3b4a023c23a6d2"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_SDA_HOLD_IC_SDA_TX_HOLD</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030get_IC_SDA_HOLD_IC_SDA_TX_HOLDEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_SDA_HOLD’s IC_SDA_TX_HOLD field.</p>
<p><p>Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a transmitter.</p>
<p>Reset value: IC_DEFAULT_SDA_HOLD[15:0].</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030set_IC_SDA_HOLD_IC_SDA_TX_HOLDE8uint16_t">
<span id="_CPPv3NV6RP20404i2c030set_IC_SDA_HOLD_IC_SDA_TX_HOLDE8uint16_t"></span><span id="_CPPv2NV6RP20404i2c030set_IC_SDA_HOLD_IC_SDA_TX_HOLDE8uint16_t"></span><span id="RP2040::i2c0::set_IC_SDA_HOLD_IC_SDA_TX_HOLD__uint16_tV"></span><span class="target" id="structRP2040_1_1i2c0_1afa00f30eaf5f0d10a4dbf616c3d1bdeb"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_SDA_HOLD_IC_SDA_TX_HOLD</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030set_IC_SDA_HOLD_IC_SDA_TX_HOLDE8uint16_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_SDA_HOLD’s IC_SDA_TX_HOLD field.</p>
<p><p>Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a transmitter.</p>
<p>Reset value: IC_DEFAULT_SDA_HOLD[15:0].</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030get_IC_SDA_HOLD_IC_SDA_RX_HOLDEv">
<span id="_CPPv3NV6RP20404i2c030get_IC_SDA_HOLD_IC_SDA_RX_HOLDEv"></span><span id="_CPPv2NV6RP20404i2c030get_IC_SDA_HOLD_IC_SDA_RX_HOLDEv"></span><span id="RP2040::i2c0::get_IC_SDA_HOLD_IC_SDA_RX_HOLDV"></span><span class="target" id="structRP2040_1_1i2c0_1af0032cdc63e1ec90570bdbf76f1434bc"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_SDA_HOLD_IC_SDA_RX_HOLD</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030get_IC_SDA_HOLD_IC_SDA_RX_HOLDEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_SDA_HOLD’s IC_SDA_RX_HOLD field.</p>
<p><p>Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a receiver.</p>
<p>Reset value: IC_DEFAULT_SDA_HOLD[23:16].</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030set_IC_SDA_HOLD_IC_SDA_RX_HOLDE7uint8_t">
<span id="_CPPv3NV6RP20404i2c030set_IC_SDA_HOLD_IC_SDA_RX_HOLDE7uint8_t"></span><span id="_CPPv2NV6RP20404i2c030set_IC_SDA_HOLD_IC_SDA_RX_HOLDE7uint8_t"></span><span id="RP2040::i2c0::set_IC_SDA_HOLD_IC_SDA_RX_HOLD__uint8_tV"></span><span class="target" id="structRP2040_1_1i2c0_1a1d6c457f4ced9bab3f73d0eb73110fce"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_SDA_HOLD_IC_SDA_RX_HOLD</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030set_IC_SDA_HOLD_IC_SDA_RX_HOLDE7uint8_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_SDA_HOLD’s IC_SDA_RX_HOLD field.</p>
<p><p>Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a receiver.</p>
<p>Reset value: IC_DEFAULT_SDA_HOLD[23:16].</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c015get_IC_SDA_HOLDER8uint16_tR7uint8_t">
<span id="_CPPv3NV6RP20404i2c015get_IC_SDA_HOLDER8uint16_tR7uint8_t"></span><span id="_CPPv2NV6RP20404i2c015get_IC_SDA_HOLDER8uint16_tR7uint8_t"></span><span id="RP2040::i2c0::get_IC_SDA_HOLD__uint16_tR.uint8_tRV"></span><span class="target" id="structRP2040_1_1i2c0_1a5a2c80c46fa6158f1912bf5733044d9c"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_SDA_HOLD</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">IC_SDA_TX_HOLD</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">IC_SDA_RX_HOLD</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c015get_IC_SDA_HOLDER8uint16_tR7uint8_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get all of IC_SDA_HOLD’s bit fields.</p>
<p><p>(read-write) I2C SDA Hold Time Length Register</p>
<p>The bits [15:0] of this register are used to control the hold time of SDA during transmit in both slave and master mode (after SCL goes from HIGH to LOW).</p>
<p>The bits [23:16] of this register are used to extend the SDA transition (if any) whenever SCL is HIGH in the receiver in either master or slave mode.</p>
<p>Writes to this register succeed only when IC_ENABLE[0]=0.</p>
<p>The values in this register are in units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode (one cycle in master mode, seven cycles in slave mode) for the value to be implemented.</p>
<p>The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part of scl. Therefore the programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl period measured in ic_clk cycles.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c015set_IC_SDA_HOLDE8uint16_t7uint8_t">
<span id="_CPPv3NV6RP20404i2c015set_IC_SDA_HOLDE8uint16_t7uint8_t"></span><span id="_CPPv2NV6RP20404i2c015set_IC_SDA_HOLDE8uint16_t7uint8_t"></span><span id="RP2040::i2c0::set_IC_SDA_HOLD__uint16_t.uint8_tV"></span><span class="target" id="structRP2040_1_1i2c0_1a228d186972756f7064242607d52d0f68"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_SDA_HOLD</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">IC_SDA_TX_HOLD</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">IC_SDA_RX_HOLD</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c015set_IC_SDA_HOLDE8uint16_t7uint8_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set all of IC_SDA_HOLD’s bit fields.</p>
<p><p>(read-write) I2C SDA Hold Time Length Register</p>
<p>The bits [15:0] of this register are used to control the hold time of SDA during transmit in both slave and master mode (after SCL goes from HIGH to LOW).</p>
<p>The bits [23:16] of this register are used to extend the SDA transition (if any) whenever SCL is HIGH in the receiver in either master or slave mode.</p>
<p>Writes to this register succeed only when IC_ENABLE[0]=0.</p>
<p>The values in this register are in units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode (one cycle in master mode, seven cycles in slave mode) for the value to be implemented.</p>
<p>The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part of scl. Therefore the programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl period measured in ic_clk cycles.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c040get_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACKEv">
<span id="_CPPv3NV6RP20404i2c040get_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACKEv"></span><span id="_CPPv2NV6RP20404i2c040get_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACKEv"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACKV"></span><span class="target" id="structRP2040_1_1i2c0_1aebbe3b8642b980ec82eb6e6626341021"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c040get_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACKEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_ABRT_SOURCE’s ABRT_7B_ADDR_NOACK bit.</p>
<p><p>This field indicates that the Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.</p>
<p>Reset value: 0x0</p>

 Role of DW_apb_i2c: Master-Transmitter or Master-Receiver </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c040get_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACKEv">
<span id="_CPPv3NV6RP20404i2c040get_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACKEv"></span><span id="_CPPv2NV6RP20404i2c040get_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACKEv"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACKV"></span><span class="target" id="structRP2040_1_1i2c0_1a8fb29ecea4dde2831b8de425d1d34a56"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c040get_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACKEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_ABRT_SOURCE’s ABRT_10ADDR1_NOACK bit.</p>
<p><p>This field indicates that the Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.</p>
<p>Reset value: 0x0</p>

 Role of DW_apb_i2c: Master-Transmitter or Master-Receiver </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c040get_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACKEv">
<span id="_CPPv3NV6RP20404i2c040get_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACKEv"></span><span id="_CPPv2NV6RP20404i2c040get_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACKEv"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACKV"></span><span class="target" id="structRP2040_1_1i2c0_1af73d12e41cd082798adeba496c5cdfe7"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c040get_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACKEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_ABRT_SOURCE’s ABRT_10ADDR2_NOACK bit.</p>
<p><p>This field indicates that the Master is in 10-bit address mode and that the second address byte of the 10-bit address was not acknowledged by any slave.</p>
<p>Reset value: 0x0</p>

 Role of DW_apb_i2c: Master-Transmitter or Master-Receiver </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c039get_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACKEv">
<span id="_CPPv3NV6RP20404i2c039get_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACKEv"></span><span id="_CPPv2NV6RP20404i2c039get_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACKEv"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACKV"></span><span class="target" id="structRP2040_1_1i2c0_1af3ab7881d8338f5c639cafa95dedafde"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c039get_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACKEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_ABRT_SOURCE’s ABRT_TXDATA_NOACK bit.</p>
<p><p>This field indicates the master-mode only bit. When the master receives an acknowledgement for the address, but when it sends data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).</p>
<p>Reset value: 0x0</p>

 Role of DW_apb_i2c: Master-Transmitter </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c038get_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACKEv">
<span id="_CPPv3NV6RP20404i2c038get_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACKEv"></span><span id="_CPPv2NV6RP20404i2c038get_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACKEv"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACKV"></span><span class="target" id="structRP2040_1_1i2c0_1a01ec7295eafb7b1b6fea5592b8310643"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c038get_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACKEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_ABRT_SOURCE’s ABRT_GCALL_NOACK bit.</p>
<p><p>This field indicates that DW_apb_i2c in master mode has sent a General Call and no slave on the bus acknowledged the General Call.</p>
<p>Reset value: 0x0</p>

 Role of DW_apb_i2c: Master-Transmitter </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c037get_IC_TX_ABRT_SOURCE_ABRT_GCALL_READEv">
<span id="_CPPv3NV6RP20404i2c037get_IC_TX_ABRT_SOURCE_ABRT_GCALL_READEv"></span><span id="_CPPv2NV6RP20404i2c037get_IC_TX_ABRT_SOURCE_ABRT_GCALL_READEv"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE_ABRT_GCALL_READV"></span><span class="target" id="structRP2040_1_1i2c0_1ac5608734b9987fb7d9b274391b7613c6"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c037get_IC_TX_ABRT_SOURCE_ABRT_GCALL_READEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_ABRT_SOURCE’s ABRT_GCALL_READ bit.</p>
<p><p>This field indicates that DW_apb_i2c in the master mode has sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1).</p>
<p>Reset value: 0x0</p>

 Role of DW_apb_i2c: Master-Transmitter </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c036get_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDETEv">
<span id="_CPPv3NV6RP20404i2c036get_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDETEv"></span><span id="_CPPv2NV6RP20404i2c036get_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDETEv"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDETV"></span><span class="target" id="structRP2040_1_1i2c0_1aa9f8dea9ea94bbcb1447fe4f735eab3b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c036get_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_ABRT_SOURCE’s ABRT_HS_ACKDET bit.</p>
<p><p>This field indicates that the Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).</p>
<p>Reset value: 0x0</p>

 Role of DW_apb_i2c: Master </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c039get_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDETEv">
<span id="_CPPv3NV6RP20404i2c039get_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDETEv"></span><span id="_CPPv2NV6RP20404i2c039get_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDETEv"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDETV"></span><span class="target" id="structRP2040_1_1i2c0_1af1ce8420d685c513f269d4880da46aca"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c039get_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_ABRT_SOURCE’s ABRT_SBYTE_ACKDET bit.</p>
<p><p>This field indicates that the Master has sent a START Byte and the START Byte was acknowledged (wrong behavior).</p>
<p>Reset value: 0x0</p>

 Role of DW_apb_i2c: Master </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c037get_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRTEv">
<span id="_CPPv3NV6RP20404i2c037get_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRTEv"></span><span id="_CPPv2NV6RP20404i2c037get_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRTEv"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRTV"></span><span class="target" id="structRP2040_1_1i2c0_1a96302c1c8c9009f1c620767c53a641a0"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c037get_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_ABRT_SOURCE’s ABRT_HS_NORSTRT bit.</p>
<p><p>This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to use the master to transfer data in High Speed mode.</p>
<p>Reset value: 0x0</p>

 Role of DW_apb_i2c: Master-Transmitter or Master-Receiver </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c040get_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRTEv">
<span id="_CPPv3NV6RP20404i2c040get_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRTEv"></span><span id="_CPPv2NV6RP20404i2c040get_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRTEv"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRTV"></span><span class="target" id="structRP2040_1_1i2c0_1aa2b1639e2a309669cb77a4289bd13383"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c040get_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_ABRT_SOURCE’s ABRT_SBYTE_NORSTRT bit.</p>
<p><p>To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets reasserted. When this field is set to 1, the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to send a START Byte.</p>
<p>Reset value: 0x0</p>

 Role of DW_apb_i2c: Master </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c041get_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRTEv">
<span id="_CPPv3NV6RP20404i2c041get_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRTEv"></span><span id="_CPPv2NV6RP20404i2c041get_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRTEv"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRTV"></span><span class="target" id="structRP2040_1_1i2c0_1af9162b752740ab89f53df1f9cf9317e1"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c041get_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_ABRT_SOURCE’s ABRT_10B_RD_NORSTRT bit.</p>
<p><p>This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the master sends a read command in 10-bit addressing mode.</p>
<p>Reset value: 0x0</p>

 Role of DW_apb_i2c: Master-Receiver </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c037get_IC_TX_ABRT_SOURCE_ABRT_MASTER_DISEv">
<span id="_CPPv3NV6RP20404i2c037get_IC_TX_ABRT_SOURCE_ABRT_MASTER_DISEv"></span><span id="_CPPv2NV6RP20404i2c037get_IC_TX_ABRT_SOURCE_ABRT_MASTER_DISEv"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE_ABRT_MASTER_DISV"></span><span class="target" id="structRP2040_1_1i2c0_1a778558474f663fa07832c36e81a8e62e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c037get_IC_TX_ABRT_SOURCE_ABRT_MASTER_DISEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_ABRT_SOURCE’s ABRT_MASTER_DIS bit.</p>
<p><p>This field indicates that the User tries to initiate a Master operation with the Master mode disabled.</p>
<p>Reset value: 0x0</p>

 Role of DW_apb_i2c: Master-Transmitter or Master-Receiver </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030get_IC_TX_ABRT_SOURCE_ARB_LOSTEv">
<span id="_CPPv3NV6RP20404i2c030get_IC_TX_ABRT_SOURCE_ARB_LOSTEv"></span><span id="_CPPv2NV6RP20404i2c030get_IC_TX_ABRT_SOURCE_ARB_LOSTEv"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE_ARB_LOSTV"></span><span class="target" id="structRP2040_1_1i2c0_1abf24be7968d8e460fcca6aac1410eba3"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE_ARB_LOST</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030get_IC_TX_ABRT_SOURCE_ARB_LOSTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_ABRT_SOURCE’s ARB_LOST bit.</p>
<p><p>This field specifies that the Master has lost arbitration, or if IC_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration.</p>
<p>Reset value: 0x0</p>

 Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c042get_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFOEv">
<span id="_CPPv3NV6RP20404i2c042get_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFOEv"></span><span id="_CPPv2NV6RP20404i2c042get_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFOEv"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFOV"></span><span class="target" id="structRP2040_1_1i2c0_1ab02e30771ef2357c9de8f42b2ed295ff"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c042get_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFOEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_ABRT_SOURCE’s ABRT_SLVFLUSH_TXFIFO bit.</p>
<p><p>This field specifies that the Slave has received a read command and some data exists in the TX FIFO, so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.</p>
<p>Reset value: 0x0</p>

 Role of DW_apb_i2c: Slave-Transmitter </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c038get_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOSTEv">
<span id="_CPPv3NV6RP20404i2c038get_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOSTEv"></span><span id="_CPPv2NV6RP20404i2c038get_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOSTEv"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOSTV"></span><span class="target" id="structRP2040_1_1i2c0_1acc783bc1cefb56ca880dbae60b010793"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c038get_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOSTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_ABRT_SOURCE’s ABRT_SLV_ARBLOST bit.</p>
<p><p>This field indicates that a Slave has lost the bus while transmitting data to a remote master. IC_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never ‘owns’ the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then DW_apb_i2c no longer own the bus.</p>
<p>Reset value: 0x0</p>

 Role of DW_apb_i2c: Slave-Transmitter </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c037get_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTXEv">
<span id="_CPPv3NV6RP20404i2c037get_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTXEv"></span><span id="_CPPv2NV6RP20404i2c037get_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTXEv"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTXV"></span><span class="target" id="structRP2040_1_1i2c0_1a58c3da3e72e2f8491f93e7d63d621344"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c037get_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTXEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_ABRT_SOURCE’s ABRT_SLVRD_INTX bit.</p>
<p><p>1: When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of IC_DATA_CMD register.</p>
<p>Reset value: 0x0</p>

 Role of DW_apb_i2c: Slave-Transmitter </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c036get_IC_TX_ABRT_SOURCE_ABRT_USER_ABRTEv">
<span id="_CPPv3NV6RP20404i2c036get_IC_TX_ABRT_SOURCE_ABRT_USER_ABRTEv"></span><span id="_CPPv2NV6RP20404i2c036get_IC_TX_ABRT_SOURCE_ABRT_USER_ABRTEv"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE_ABRT_USER_ABRTV"></span><span class="target" id="structRP2040_1_1i2c0_1ad73c96bd8240ac3dbdea443163655fd7"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c036get_IC_TX_ABRT_SOURCE_ABRT_USER_ABRTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_ABRT_SOURCE’s ABRT_USER_ABRT bit.</p>
<p><p>This is a master-mode-only bit. Master has detected the transfer abort (IC_ENABLE[1])</p>
<p>Reset value: 0x0</p>

 Role of DW_apb_i2c: Master-Transmitter </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c034get_IC_TX_ABRT_SOURCE_TX_FLUSH_CNTEv">
<span id="_CPPv3NV6RP20404i2c034get_IC_TX_ABRT_SOURCE_TX_FLUSH_CNTEv"></span><span id="_CPPv2NV6RP20404i2c034get_IC_TX_ABRT_SOURCE_TX_FLUSH_CNTEv"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE_TX_FLUSH_CNTV"></span><span class="target" id="structRP2040_1_1i2c0_1a06dfd086fc4754ed416222d34b17fd0b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c034get_IC_TX_ABRT_SOURCE_TX_FLUSH_CNTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_TX_ABRT_SOURCE’s TX_FLUSH_CNT field.</p>
<p><p>This field indicates the number of Tx FIFO Data Commands which are flushed due to TX_ABRT interrupt. It is cleared whenever I2C is disabled.</p>
<p>Reset value: 0x0</p>

 Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c021get_IC_TX_ABRT_SOURCEERbRbRbRbRbRbRbRbRbRbRbRbRbRbRbRbRbR8uint16_t">
<span id="_CPPv3NV6RP20404i2c021get_IC_TX_ABRT_SOURCEERbRbRbRbRbRbRbRbRbRbRbRbRbRbRbRbRbR8uint16_t"></span><span id="_CPPv2NV6RP20404i2c021get_IC_TX_ABRT_SOURCEERbRbRbRbRbRbRbRbRbRbRbRbRbRbRbRbRbR8uint16_t"></span><span id="RP2040::i2c0::get_IC_TX_ABRT_SOURCE__bR.bR.bR.bR.bR.bR.bR.bR.bR.bR.bR.bR.bR.bR.bR.bR.bR.uint16_tRV"></span><span class="target" id="structRP2040_1_1i2c0_1a6b7e9f58aacea479d572f3dc5af8abd8"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_TX_ABRT_SOURCE</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ABRT_7B_ADDR_NOACK</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ABRT_10ADDR1_NOACK</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ABRT_10ADDR2_NOACK</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ABRT_TXDATA_NOACK</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ABRT_GCALL_NOACK</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ABRT_GCALL_READ</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ABRT_HS_ACKDET</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ABRT_SBYTE_ACKDET</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ABRT_HS_NORSTRT</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ABRT_SBYTE_NORSTRT</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ABRT_10B_RD_NORSTRT</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ABRT_MASTER_DIS</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ARB_LOST</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ABRT_SLVFLUSH_TXFIFO</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ABRT_SLV_ARBLOST</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ABRT_SLVRD_INTX</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ABRT_USER_ABRT</span></span>, <span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">TX_FLUSH_CNT</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c021get_IC_TX_ABRT_SOURCEERbRbRbRbRbRbRbRbRbRbRbRbRbRbRbRbRbR8uint16_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get all of IC_TX_ABRT_SOURCE’s bit fields.</p>
<p><p>(read-only) I2C Transmit Abort Source Register</p>
<p>This register has 32 bits that indicate the source of the TX_ABRT bit. Except for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the IC_CLR_INTR register is read. To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]).</p>

 Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, Bit 9 clears for one cycle and is then re-asserted. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030get_IC_SLV_DATA_NACK_ONLY_NACKEv">
<span id="_CPPv3NV6RP20404i2c030get_IC_SLV_DATA_NACK_ONLY_NACKEv"></span><span id="_CPPv2NV6RP20404i2c030get_IC_SLV_DATA_NACK_ONLY_NACKEv"></span><span id="RP2040::i2c0::get_IC_SLV_DATA_NACK_ONLY_NACKV"></span><span class="target" id="structRP2040_1_1i2c0_1ab664e251d08aca8b643b1566da6533bb"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_SLV_DATA_NACK_ONLY_NACK</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030get_IC_SLV_DATA_NACK_ONLY_NACKEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_SLV_DATA_NACK_ONLY’s NACK bit.</p>
<p><p>Generate NACK. This NACK generation only occurs when DW_apb_i2c is a slave-receiver. If this register is set to a value of 1, it can only generate a NACK after a data byte is received; hence, the data transfer is aborted and the data received is not pushed to the receive buffer.</p>
<p>When the register is set to a value of 0, it generates NACK/ACK, depending on normal criteria. - 1: generate NACK after data byte received - 0: generate NACK/ACK normally Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c030set_IC_SLV_DATA_NACK_ONLY_NACKEv">
<span id="_CPPv3NV6RP20404i2c030set_IC_SLV_DATA_NACK_ONLY_NACKEv"></span><span id="_CPPv2NV6RP20404i2c030set_IC_SLV_DATA_NACK_ONLY_NACKEv"></span><span id="RP2040::i2c0::set_IC_SLV_DATA_NACK_ONLY_NACKV"></span><span class="target" id="structRP2040_1_1i2c0_1a55c84e81734ec79af4d1e6883e6de0e7"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_SLV_DATA_NACK_ONLY_NACK</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c030set_IC_SLV_DATA_NACK_ONLY_NACKEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_SLV_DATA_NACK_ONLY’s NACK bit.</p>
<p><p>Generate NACK. This NACK generation only occurs when DW_apb_i2c is a slave-receiver. If this register is set to a value of 1, it can only generate a NACK after a data byte is received; hence, the data transfer is aborted and the data received is not pushed to the receive buffer.</p>
<p>When the register is set to a value of 0, it generates NACK/ACK, depending on normal criteria. - 1: generate NACK after data byte received - 0: generate NACK/ACK normally Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c032clear_IC_SLV_DATA_NACK_ONLY_NACKEv">
<span id="_CPPv3NV6RP20404i2c032clear_IC_SLV_DATA_NACK_ONLY_NACKEv"></span><span id="_CPPv2NV6RP20404i2c032clear_IC_SLV_DATA_NACK_ONLY_NACKEv"></span><span id="RP2040::i2c0::clear_IC_SLV_DATA_NACK_ONLY_NACKV"></span><span class="target" id="structRP2040_1_1i2c0_1adf5878d37972de02c787eae287852234"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_SLV_DATA_NACK_ONLY_NACK</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c032clear_IC_SLV_DATA_NACK_ONLY_NACKEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_SLV_DATA_NACK_ONLY’s NACK bit.</p>
<p><p>Generate NACK. This NACK generation only occurs when DW_apb_i2c is a slave-receiver. If this register is set to a value of 1, it can only generate a NACK after a data byte is received; hence, the data transfer is aborted and the data received is not pushed to the receive buffer.</p>
<p>When the register is set to a value of 0, it generates NACK/ACK, depending on normal criteria. - 1: generate NACK after data byte received - 0: generate NACK/ACK normally Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c033toggle_IC_SLV_DATA_NACK_ONLY_NACKEv">
<span id="_CPPv3NV6RP20404i2c033toggle_IC_SLV_DATA_NACK_ONLY_NACKEv"></span><span id="_CPPv2NV6RP20404i2c033toggle_IC_SLV_DATA_NACK_ONLY_NACKEv"></span><span id="RP2040::i2c0::toggle_IC_SLV_DATA_NACK_ONLY_NACKV"></span><span class="target" id="structRP2040_1_1i2c0_1af270a1dafe89fd5d4a051a389083680e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_SLV_DATA_NACK_ONLY_NACK</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c033toggle_IC_SLV_DATA_NACK_ONLY_NACKEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_SLV_DATA_NACK_ONLY’s NACK bit.</p>
<p><p>Generate NACK. This NACK generation only occurs when DW_apb_i2c is a slave-receiver. If this register is set to a value of 1, it can only generate a NACK after a data byte is received; hence, the data transfer is aborted and the data received is not pushed to the receive buffer.</p>
<p>When the register is set to a value of 0, it generates NACK/ACK, depending on normal criteria. - 1: generate NACK after data byte received - 0: generate NACK/ACK normally Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c019get_IC_DMA_CR_RDMAEEv">
<span id="_CPPv3NV6RP20404i2c019get_IC_DMA_CR_RDMAEEv"></span><span id="_CPPv2NV6RP20404i2c019get_IC_DMA_CR_RDMAEEv"></span><span id="RP2040::i2c0::get_IC_DMA_CR_RDMAEV"></span><span class="target" id="structRP2040_1_1i2c0_1a0283d5f065006a58bb5070656290c510"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_DMA_CR_RDMAE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c019get_IC_DMA_CR_RDMAEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_DMA_CR’s RDMAE bit.</p>
<p>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c019set_IC_DMA_CR_RDMAEEv">
<span id="_CPPv3NV6RP20404i2c019set_IC_DMA_CR_RDMAEEv"></span><span id="_CPPv2NV6RP20404i2c019set_IC_DMA_CR_RDMAEEv"></span><span id="RP2040::i2c0::set_IC_DMA_CR_RDMAEV"></span><span class="target" id="structRP2040_1_1i2c0_1a308f76a89d6ba8174e42edf42220d16b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_DMA_CR_RDMAE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c019set_IC_DMA_CR_RDMAEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_DMA_CR’s RDMAE bit.</p>
<p>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c021clear_IC_DMA_CR_RDMAEEv">
<span id="_CPPv3NV6RP20404i2c021clear_IC_DMA_CR_RDMAEEv"></span><span id="_CPPv2NV6RP20404i2c021clear_IC_DMA_CR_RDMAEEv"></span><span id="RP2040::i2c0::clear_IC_DMA_CR_RDMAEV"></span><span class="target" id="structRP2040_1_1i2c0_1a54226c0f7df2afcb22f4df32ba4f0c2d"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_DMA_CR_RDMAE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c021clear_IC_DMA_CR_RDMAEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_DMA_CR’s RDMAE bit.</p>
<p>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c022toggle_IC_DMA_CR_RDMAEEv">
<span id="_CPPv3NV6RP20404i2c022toggle_IC_DMA_CR_RDMAEEv"></span><span id="_CPPv2NV6RP20404i2c022toggle_IC_DMA_CR_RDMAEEv"></span><span id="RP2040::i2c0::toggle_IC_DMA_CR_RDMAEV"></span><span class="target" id="structRP2040_1_1i2c0_1aa32c907fa225b6cde64f685c04ef5182"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_DMA_CR_RDMAE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c022toggle_IC_DMA_CR_RDMAEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_DMA_CR’s RDMAE bit.</p>
<p>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c019get_IC_DMA_CR_TDMAEEv">
<span id="_CPPv3NV6RP20404i2c019get_IC_DMA_CR_TDMAEEv"></span><span id="_CPPv2NV6RP20404i2c019get_IC_DMA_CR_TDMAEEv"></span><span id="RP2040::i2c0::get_IC_DMA_CR_TDMAEV"></span><span class="target" id="structRP2040_1_1i2c0_1ad56076aa2341c63e461f50f6fa2cae61"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_DMA_CR_TDMAE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c019get_IC_DMA_CR_TDMAEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_DMA_CR’s TDMAE bit.</p>
<p>Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c019set_IC_DMA_CR_TDMAEEv">
<span id="_CPPv3NV6RP20404i2c019set_IC_DMA_CR_TDMAEEv"></span><span id="_CPPv2NV6RP20404i2c019set_IC_DMA_CR_TDMAEEv"></span><span id="RP2040::i2c0::set_IC_DMA_CR_TDMAEV"></span><span class="target" id="structRP2040_1_1i2c0_1a4db5440f349c255e2a782734d0dec43b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_DMA_CR_TDMAE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c019set_IC_DMA_CR_TDMAEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_DMA_CR’s TDMAE bit.</p>
<p>Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c021clear_IC_DMA_CR_TDMAEEv">
<span id="_CPPv3NV6RP20404i2c021clear_IC_DMA_CR_TDMAEEv"></span><span id="_CPPv2NV6RP20404i2c021clear_IC_DMA_CR_TDMAEEv"></span><span id="RP2040::i2c0::clear_IC_DMA_CR_TDMAEV"></span><span class="target" id="structRP2040_1_1i2c0_1abd001cedfad26c1ec4205ec2435b2b56"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_DMA_CR_TDMAE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c021clear_IC_DMA_CR_TDMAEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_DMA_CR’s TDMAE bit.</p>
<p>Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c022toggle_IC_DMA_CR_TDMAEEv">
<span id="_CPPv3NV6RP20404i2c022toggle_IC_DMA_CR_TDMAEEv"></span><span id="_CPPv2NV6RP20404i2c022toggle_IC_DMA_CR_TDMAEEv"></span><span id="RP2040::i2c0::toggle_IC_DMA_CR_TDMAEV"></span><span class="target" id="structRP2040_1_1i2c0_1a97cff2633f739c8de97cce6090b24c26"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_DMA_CR_TDMAE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c022toggle_IC_DMA_CR_TDMAEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_DMA_CR’s TDMAE bit.</p>
<p>Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c013get_IC_DMA_CRERbRb">
<span id="_CPPv3NV6RP20404i2c013get_IC_DMA_CRERbRb"></span><span id="_CPPv2NV6RP20404i2c013get_IC_DMA_CRERbRb"></span><span id="RP2040::i2c0::get_IC_DMA_CR__bR.bRV"></span><span class="target" id="structRP2040_1_1i2c0_1ad9b0bdec502626916582fd99c9ceda81"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_DMA_CR</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">RDMAE</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">TDMAE</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c013get_IC_DMA_CRERbRb" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get all of IC_DMA_CR’s bit fields.</p>
<p><p>(read-write) DMA Control Register</p>
<p>The register is used to enable the DMA Controller interface operation. There is a separate bit for transmit and receive. This can be programmed regardless of the state of IC_ENABLE.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c013set_IC_DMA_CREbb">
<span id="_CPPv3NV6RP20404i2c013set_IC_DMA_CREbb"></span><span id="_CPPv2NV6RP20404i2c013set_IC_DMA_CREbb"></span><span id="RP2040::i2c0::set_IC_DMA_CR__b.bV"></span><span class="target" id="structRP2040_1_1i2c0_1adcf548e90df09971951ac90b08f876c3"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_DMA_CR</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">RDMAE</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">TDMAE</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c013set_IC_DMA_CREbb" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set all of IC_DMA_CR’s bit fields.</p>
<p><p>(read-write) DMA Control Register</p>
<p>The register is used to enable the DMA Controller interface operation. There is a separate bit for transmit and receive. This can be programmed regardless of the state of IC_ENABLE.</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c022get_IC_DMA_TDLR_DMATDLEv">
<span id="_CPPv3NV6RP20404i2c022get_IC_DMA_TDLR_DMATDLEv"></span><span id="_CPPv2NV6RP20404i2c022get_IC_DMA_TDLR_DMATDLEv"></span><span id="RP2040::i2c0::get_IC_DMA_TDLR_DMATDLV"></span><span class="target" id="structRP2040_1_1i2c0_1afaf26cec48c6926db813ee69fa613521"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_DMA_TDLR_DMATDL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c022get_IC_DMA_TDLR_DMATDLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_DMA_TDLR’s DMATDL field.</p>
<p><p>Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c022set_IC_DMA_TDLR_DMATDLE7uint8_t">
<span id="_CPPv3NV6RP20404i2c022set_IC_DMA_TDLR_DMATDLE7uint8_t"></span><span id="_CPPv2NV6RP20404i2c022set_IC_DMA_TDLR_DMATDLE7uint8_t"></span><span id="RP2040::i2c0::set_IC_DMA_TDLR_DMATDL__uint8_tV"></span><span class="target" id="structRP2040_1_1i2c0_1aa287d51de4cb82bb437a5c4fe000f676"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_DMA_TDLR_DMATDL</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c022set_IC_DMA_TDLR_DMATDLE7uint8_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_DMA_TDLR’s DMATDL field.</p>
<p><p>Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c022get_IC_DMA_RDLR_DMARDLEv">
<span id="_CPPv3NV6RP20404i2c022get_IC_DMA_RDLR_DMARDLEv"></span><span id="_CPPv2NV6RP20404i2c022get_IC_DMA_RDLR_DMARDLEv"></span><span id="RP2040::i2c0::get_IC_DMA_RDLR_DMARDLV"></span><span class="target" id="structRP2040_1_1i2c0_1ad9a50fc5e239a542bc4f57fb4f3f4ccd"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_DMA_RDLR_DMARDL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c022get_IC_DMA_RDLR_DMARDLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_DMA_RDLR’s DMARDL field.</p>
<p><p>Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c022set_IC_DMA_RDLR_DMARDLE7uint8_t">
<span id="_CPPv3NV6RP20404i2c022set_IC_DMA_RDLR_DMARDLE7uint8_t"></span><span id="_CPPv2NV6RP20404i2c022set_IC_DMA_RDLR_DMARDLE7uint8_t"></span><span id="RP2040::i2c0::set_IC_DMA_RDLR_DMARDL__uint8_tV"></span><span class="target" id="structRP2040_1_1i2c0_1abcf34dd10f560c24dd8f002dca903d1a"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_DMA_RDLR_DMARDL</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c022set_IC_DMA_RDLR_DMARDLE7uint8_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_DMA_RDLR’s DMARDL field.</p>
<p><p>Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026get_IC_SDA_SETUP_SDA_SETUPEv">
<span id="_CPPv3NV6RP20404i2c026get_IC_SDA_SETUP_SDA_SETUPEv"></span><span id="_CPPv2NV6RP20404i2c026get_IC_SDA_SETUP_SDA_SETUPEv"></span><span id="RP2040::i2c0::get_IC_SDA_SETUP_SDA_SETUPV"></span><span class="target" id="structRP2040_1_1i2c0_1a2ef87e7c8419874ae74dc978e854fa79"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_SDA_SETUP_SDA_SETUP</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026get_IC_SDA_SETUP_SDA_SETUPEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_SDA_SETUP’s SDA_SETUP field.</p>
<p>SDA Setup. It is recommended that if the required delay is 1000ns, then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11. IC_SDA_SETUP must be programmed with a minimum value of 2. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026set_IC_SDA_SETUP_SDA_SETUPE7uint8_t">
<span id="_CPPv3NV6RP20404i2c026set_IC_SDA_SETUP_SDA_SETUPE7uint8_t"></span><span id="_CPPv2NV6RP20404i2c026set_IC_SDA_SETUP_SDA_SETUPE7uint8_t"></span><span id="RP2040::i2c0::set_IC_SDA_SETUP_SDA_SETUP__uint8_tV"></span><span class="target" id="structRP2040_1_1i2c0_1aaa115e241ec43a0e38850da8aa0f0c9e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_SDA_SETUP_SDA_SETUP</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026set_IC_SDA_SETUP_SDA_SETUPE7uint8_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_SDA_SETUP’s SDA_SETUP field.</p>
<p>SDA Setup. It is recommended that if the required delay is 1000ns, then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11. IC_SDA_SETUP must be programmed with a minimum value of 2. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c036get_IC_ACK_GENERAL_CALL_ACK_GEN_CALLEv">
<span id="_CPPv3NV6RP20404i2c036get_IC_ACK_GENERAL_CALL_ACK_GEN_CALLEv"></span><span id="_CPPv2NV6RP20404i2c036get_IC_ACK_GENERAL_CALL_ACK_GEN_CALLEv"></span><span id="RP2040::i2c0::get_IC_ACK_GENERAL_CALL_ACK_GEN_CALLV"></span><span class="target" id="structRP2040_1_1i2c0_1a33f0522a4d975b534fa6bdca7b943a3a"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_ACK_GENERAL_CALL_ACK_GEN_CALL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c036get_IC_ACK_GENERAL_CALL_ACK_GEN_CALLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_ACK_GENERAL_CALL’s ACK_GEN_CALL bit.</p>
<p>ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with a NACK (by negating ic_data_oe). </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c036set_IC_ACK_GENERAL_CALL_ACK_GEN_CALLEv">
<span id="_CPPv3NV6RP20404i2c036set_IC_ACK_GENERAL_CALL_ACK_GEN_CALLEv"></span><span id="_CPPv2NV6RP20404i2c036set_IC_ACK_GENERAL_CALL_ACK_GEN_CALLEv"></span><span id="RP2040::i2c0::set_IC_ACK_GENERAL_CALL_ACK_GEN_CALLV"></span><span class="target" id="structRP2040_1_1i2c0_1ab602a5af8e3d67e88f7d5d75f6065b2e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_ACK_GENERAL_CALL_ACK_GEN_CALL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c036set_IC_ACK_GENERAL_CALL_ACK_GEN_CALLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_ACK_GENERAL_CALL’s ACK_GEN_CALL bit.</p>
<p>ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with a NACK (by negating ic_data_oe). </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c038clear_IC_ACK_GENERAL_CALL_ACK_GEN_CALLEv">
<span id="_CPPv3NV6RP20404i2c038clear_IC_ACK_GENERAL_CALL_ACK_GEN_CALLEv"></span><span id="_CPPv2NV6RP20404i2c038clear_IC_ACK_GENERAL_CALL_ACK_GEN_CALLEv"></span><span id="RP2040::i2c0::clear_IC_ACK_GENERAL_CALL_ACK_GEN_CALLV"></span><span class="target" id="structRP2040_1_1i2c0_1aee8ba741df49281d44975b461623e183"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_IC_ACK_GENERAL_CALL_ACK_GEN_CALL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c038clear_IC_ACK_GENERAL_CALL_ACK_GEN_CALLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear IC_ACK_GENERAL_CALL’s ACK_GEN_CALL bit.</p>
<p>ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with a NACK (by negating ic_data_oe). </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c039toggle_IC_ACK_GENERAL_CALL_ACK_GEN_CALLEv">
<span id="_CPPv3NV6RP20404i2c039toggle_IC_ACK_GENERAL_CALL_ACK_GEN_CALLEv"></span><span id="_CPPv2NV6RP20404i2c039toggle_IC_ACK_GENERAL_CALL_ACK_GEN_CALLEv"></span><span id="RP2040::i2c0::toggle_IC_ACK_GENERAL_CALL_ACK_GEN_CALLV"></span><span class="target" id="structRP2040_1_1i2c0_1a3f7a042114a87225c3ce2676e807b2f2"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toggle_IC_ACK_GENERAL_CALL_ACK_GEN_CALL</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c039toggle_IC_ACK_GENERAL_CALL_ACK_GEN_CALLEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Toggle IC_ACK_GENERAL_CALL’s ACK_GEN_CALL bit.</p>
<p>ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with a NACK (by negating ic_data_oe). </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c026get_IC_ENABLE_STATUS_IC_ENEv">
<span id="_CPPv3NV6RP20404i2c026get_IC_ENABLE_STATUS_IC_ENEv"></span><span id="_CPPv2NV6RP20404i2c026get_IC_ENABLE_STATUS_IC_ENEv"></span><span id="RP2040::i2c0::get_IC_ENABLE_STATUS_IC_ENV"></span><span class="target" id="structRP2040_1_1i2c0_1adbeff715ca322a58e737cd037798ebe8"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_ENABLE_STATUS_IC_EN</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c026get_IC_ENABLE_STATUS_IC_ENEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_ENABLE_STATUS’s IC_EN bit.</p>
<p><p>ic_en Status. This bit always reflects the value driven on the output port ic_en. - When read as 1, DW_apb_i2c is deemed to be in an enabled state. - When read as 0, DW_apb_i2c is deemed completely inactive. Note: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1).</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c044get_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSYEv">
<span id="_CPPv3NV6RP20404i2c044get_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSYEv"></span><span id="_CPPv2NV6RP20404i2c044get_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSYEv"></span><span id="RP2040::i2c0::get_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSYV"></span><span class="target" id="structRP2040_1_1i2c0_1acb2c1d0a81f5d1efb55b241ec3a57f9b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c044get_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSYEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_ENABLE_STATUS’s SLV_DISABLED_WHILE_BUSY bit.</p>
<p><p>Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting bit 0 of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:</p>
<p>(a) DW_apb_i2c is receiving the address byte of the Slave-Transmitter operation from a remote master;</p>
<p>OR,</p>
<p>(b) address and data bytes of the Slave-Receiver operation from a remote master.</p>
<p>When read as 1, DW_apb_i2c is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in DW_apb_i2c (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.</p>
<p>Note: If the remote I2C master terminates the transfer with a STOP condition before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit will also be set to 1.</p>
<p>When read as 0, DW_apb_i2c is deemed to have been disabled when there is master activity, or when the I2C bus is idle.</p>
<p>Note: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.</p>

 Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c037get_IC_ENABLE_STATUS_SLV_RX_DATA_LOSTEv">
<span id="_CPPv3NV6RP20404i2c037get_IC_ENABLE_STATUS_SLV_RX_DATA_LOSTEv"></span><span id="_CPPv2NV6RP20404i2c037get_IC_ENABLE_STATUS_SLV_RX_DATA_LOSTEv"></span><span id="RP2040::i2c0::get_IC_ENABLE_STATUS_SLV_RX_DATA_LOSTV"></span><span class="target" id="structRP2040_1_1i2c0_1afce4d19ce2f4e8fdb9c099018ba712ee"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_ENABLE_STATUS_SLV_RX_DATA_LOST</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c037get_IC_ENABLE_STATUS_SLV_RX_DATA_LOSTEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_ENABLE_STATUS’s SLV_RX_DATA_LOST bit.</p>
<p><p>Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting bit 0 of IC_ENABLE from 1 to 0. When read as 1, DW_apb_i2c is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK.</p>
<p>Note: If the remote I2C master terminates the transfer with a STOP condition before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit is also set to 1.</p>
<p>When read as 0, DW_apb_i2c is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.</p>
<p>Note: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.</p>

 Reset value: 0x0 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c020get_IC_ENABLE_STATUSERbRbRb">
<span id="_CPPv3NV6RP20404i2c020get_IC_ENABLE_STATUSERbRbRb"></span><span id="_CPPv2NV6RP20404i2c020get_IC_ENABLE_STATUSERbRbRb"></span><span id="RP2040::i2c0::get_IC_ENABLE_STATUS__bR.bR.bRV"></span><span class="target" id="structRP2040_1_1i2c0_1aa44536e81d76f309dc6707989da5d9bb"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_ENABLE_STATUS</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">IC_EN</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">SLV_DISABLED_WHILE_BUSY</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">SLV_RX_DATA_LOST</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c020get_IC_ENABLE_STATUSERbRbRb" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get all of IC_ENABLE_STATUS’s bit fields.</p>
<p><p>(read-only) I2C Enable Status Register</p>
<p>The register is used to report the DW_apb_i2c hardware status when the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is disabled.</p>
<p>If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced to 1.</p>
<p>If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is read as ‘0’.</p>

 Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read as 0 because disabling the DW_apb_i2c depends on I2C bus activities. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029get_IC_FS_SPKLEN_IC_FS_SPKLENEv">
<span id="_CPPv3NV6RP20404i2c029get_IC_FS_SPKLEN_IC_FS_SPKLENEv"></span><span id="_CPPv2NV6RP20404i2c029get_IC_FS_SPKLEN_IC_FS_SPKLENEv"></span><span id="RP2040::i2c0::get_IC_FS_SPKLEN_IC_FS_SPKLENV"></span><span class="target" id="structRP2040_1_1i2c0_1a0bc16ac15be3372c7b69d6f04083d314"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_FS_SPKLEN_IC_FS_SPKLEN</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029get_IC_FS_SPKLEN_IC_FS_SPKLENEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_FS_SPKLEN’s IC_FS_SPKLEN field.</p>
<p>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. or more information, refer to ‘Spike Suppression’. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029set_IC_FS_SPKLEN_IC_FS_SPKLENE7uint8_t">
<span id="_CPPv3NV6RP20404i2c029set_IC_FS_SPKLEN_IC_FS_SPKLENE7uint8_t"></span><span id="_CPPv2NV6RP20404i2c029set_IC_FS_SPKLEN_IC_FS_SPKLENE7uint8_t"></span><span id="RP2040::i2c0::set_IC_FS_SPKLEN_IC_FS_SPKLEN__uint8_tV"></span><span class="target" id="structRP2040_1_1i2c0_1a2c3a15187e63497a99534459c79ff750"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_IC_FS_SPKLEN_IC_FS_SPKLEN</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029set_IC_FS_SPKLEN_IC_FS_SPKLENE7uint8_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set IC_FS_SPKLEN’s IC_FS_SPKLEN field.</p>
<p>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. or more information, refer to ‘Spike Suppression’. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c038get_IC_CLR_RESTART_DET_CLR_RESTART_DETEv">
<span id="_CPPv3NV6RP20404i2c038get_IC_CLR_RESTART_DET_CLR_RESTART_DETEv"></span><span id="_CPPv2NV6RP20404i2c038get_IC_CLR_RESTART_DET_CLR_RESTART_DETEv"></span><span id="RP2040::i2c0::get_IC_CLR_RESTART_DET_CLR_RESTART_DETV"></span><span class="target" id="structRP2040_1_1i2c0_1ae4db0d75ebacdfdcb2840c49f5fd75f6"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_CLR_RESTART_DET_CLR_RESTART_DET</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c038get_IC_CLR_RESTART_DET_CLR_RESTART_DETEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_CLR_RESTART_DET’s CLR_RESTART_DET bit.</p>
<p><p>Read this register to clear the RESTART_DET interrupt (bit 12) of IC_RAW_INTR_STAT register.</p>
<p>Reset value: 0x0</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c034get_IC_COMP_PARAM_1_APB_DATA_WIDTHEv">
<span id="_CPPv3NV6RP20404i2c034get_IC_COMP_PARAM_1_APB_DATA_WIDTHEv"></span><span id="_CPPv2NV6RP20404i2c034get_IC_COMP_PARAM_1_APB_DATA_WIDTHEv"></span><span id="RP2040::i2c0::get_IC_COMP_PARAM_1_APB_DATA_WIDTHV"></span><span class="target" id="structRP2040_1_1i2c0_1a650cc0f4e3451227b74c9fa62108e387"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_COMP_PARAM_1_APB_DATA_WIDTH</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c034get_IC_COMP_PARAM_1_APB_DATA_WIDTHEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_COMP_PARAM_1’s APB_DATA_WIDTH field.</p>
<p>APB data bus width is 32 bits </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c034get_IC_COMP_PARAM_1_MAX_SPEED_MODEEv">
<span id="_CPPv3NV6RP20404i2c034get_IC_COMP_PARAM_1_MAX_SPEED_MODEEv"></span><span id="_CPPv2NV6RP20404i2c034get_IC_COMP_PARAM_1_MAX_SPEED_MODEEv"></span><span id="RP2040::i2c0::get_IC_COMP_PARAM_1_MAX_SPEED_MODEV"></span><span class="target" id="structRP2040_1_1i2c0_1ac3e8dc90444c8daed25f2226f0a08afe"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_COMP_PARAM_1_MAX_SPEED_MODE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c034get_IC_COMP_PARAM_1_MAX_SPEED_MODEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_COMP_PARAM_1’s MAX_SPEED_MODE field.</p>
<p>MAX SPEED MODE = FAST MODE </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c035get_IC_COMP_PARAM_1_HC_COUNT_VALUESEv">
<span id="_CPPv3NV6RP20404i2c035get_IC_COMP_PARAM_1_HC_COUNT_VALUESEv"></span><span id="_CPPv2NV6RP20404i2c035get_IC_COMP_PARAM_1_HC_COUNT_VALUESEv"></span><span id="RP2040::i2c0::get_IC_COMP_PARAM_1_HC_COUNT_VALUESV"></span><span class="target" id="structRP2040_1_1i2c0_1a580da86a1654a027b497a0f9197f74c4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_COMP_PARAM_1_HC_COUNT_VALUES</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c035get_IC_COMP_PARAM_1_HC_COUNT_VALUESEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_COMP_PARAM_1’s HC_COUNT_VALUES bit.</p>
<p>Programmable count values for each mode. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027get_IC_COMP_PARAM_1_INTR_IOEv">
<span id="_CPPv3NV6RP20404i2c027get_IC_COMP_PARAM_1_INTR_IOEv"></span><span id="_CPPv2NV6RP20404i2c027get_IC_COMP_PARAM_1_INTR_IOEv"></span><span id="RP2040::i2c0::get_IC_COMP_PARAM_1_INTR_IOV"></span><span class="target" id="structRP2040_1_1i2c0_1a7594e9ebac30a7e30fb74af3ef13a96a"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_COMP_PARAM_1_INTR_IO</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027get_IC_COMP_PARAM_1_INTR_IOEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_COMP_PARAM_1’s INTR_IO bit.</p>
<p>COMBINED Interrupt outputs </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c027get_IC_COMP_PARAM_1_HAS_DMAEv">
<span id="_CPPv3NV6RP20404i2c027get_IC_COMP_PARAM_1_HAS_DMAEv"></span><span id="_CPPv2NV6RP20404i2c027get_IC_COMP_PARAM_1_HAS_DMAEv"></span><span id="RP2040::i2c0::get_IC_COMP_PARAM_1_HAS_DMAV"></span><span class="target" id="structRP2040_1_1i2c0_1ad669773b4cbfe1fee0a3dce9ef82665c"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_COMP_PARAM_1_HAS_DMA</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c027get_IC_COMP_PARAM_1_HAS_DMAEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_COMP_PARAM_1’s HAS_DMA bit.</p>
<p>DMA handshaking signals are enabled </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c038get_IC_COMP_PARAM_1_ADD_ENCODED_PARAMSEv">
<span id="_CPPv3NV6RP20404i2c038get_IC_COMP_PARAM_1_ADD_ENCODED_PARAMSEv"></span><span id="_CPPv2NV6RP20404i2c038get_IC_COMP_PARAM_1_ADD_ENCODED_PARAMSEv"></span><span id="RP2040::i2c0::get_IC_COMP_PARAM_1_ADD_ENCODED_PARAMSV"></span><span class="target" id="structRP2040_1_1i2c0_1a98aa9061b250f6816649d2b305d9cbfb"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c038get_IC_COMP_PARAM_1_ADD_ENCODED_PARAMSEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_COMP_PARAM_1’s ADD_ENCODED_PARAMS bit.</p>
<p>Encoded parameters not visible </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c035get_IC_COMP_PARAM_1_RX_BUFFER_DEPTHEv">
<span id="_CPPv3NV6RP20404i2c035get_IC_COMP_PARAM_1_RX_BUFFER_DEPTHEv"></span><span id="_CPPv2NV6RP20404i2c035get_IC_COMP_PARAM_1_RX_BUFFER_DEPTHEv"></span><span id="RP2040::i2c0::get_IC_COMP_PARAM_1_RX_BUFFER_DEPTHV"></span><span class="target" id="structRP2040_1_1i2c0_1a10eee33bfff466109313da2200b045dd"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_COMP_PARAM_1_RX_BUFFER_DEPTH</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c035get_IC_COMP_PARAM_1_RX_BUFFER_DEPTHEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_COMP_PARAM_1’s RX_BUFFER_DEPTH field.</p>
<p>RX Buffer Depth = 16 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c035get_IC_COMP_PARAM_1_TX_BUFFER_DEPTHEv">
<span id="_CPPv3NV6RP20404i2c035get_IC_COMP_PARAM_1_TX_BUFFER_DEPTHEv"></span><span id="_CPPv2NV6RP20404i2c035get_IC_COMP_PARAM_1_TX_BUFFER_DEPTHEv"></span><span id="RP2040::i2c0::get_IC_COMP_PARAM_1_TX_BUFFER_DEPTHV"></span><span class="target" id="structRP2040_1_1i2c0_1afc4b3601a2c74b167d80770fe7955a25"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_COMP_PARAM_1_TX_BUFFER_DEPTH</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c035get_IC_COMP_PARAM_1_TX_BUFFER_DEPTHEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_COMP_PARAM_1’s TX_BUFFER_DEPTH field.</p>
<p>TX Buffer Depth = 16 </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c019get_IC_COMP_PARAM_1ER7uint8_tR7uint8_tRbRbRbRbR7uint8_tR7uint8_t">
<span id="_CPPv3NV6RP20404i2c019get_IC_COMP_PARAM_1ER7uint8_tR7uint8_tRbRbRbRbR7uint8_tR7uint8_t"></span><span id="_CPPv2NV6RP20404i2c019get_IC_COMP_PARAM_1ER7uint8_tR7uint8_tRbRbRbRbR7uint8_tR7uint8_t"></span><span id="RP2040::i2c0::get_IC_COMP_PARAM_1__uint8_tR.uint8_tR.bR.bR.bR.bR.uint8_tR.uint8_tRV"></span><span class="target" id="structRP2040_1_1i2c0_1ad8d8843e2f5b220b90e81d395f1c25cc"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_COMP_PARAM_1</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">APB_DATA_WIDTH</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">MAX_SPEED_MODE</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">HC_COUNT_VALUES</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">INTR_IO</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">HAS_DMA</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">ADD_ENCODED_PARAMS</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">RX_BUFFER_DEPTH</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">TX_BUFFER_DEPTH</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c019get_IC_COMP_PARAM_1ER7uint8_tR7uint8_tRbRbRbRbR7uint8_tR7uint8_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get all of IC_COMP_PARAM_1’s bit fields.</p>
<p><p>(read-only) Component Parameter Register 1</p>
<p>Note This register is not implemented and therefore reads as 0. If it was implemented it would be a constant read-only register that contains encoded information about the component’s parameter settings. Fields shown below are the settings for those parameters</p>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c035get_IC_COMP_VERSION_IC_COMP_VERSIONEv">
<span id="_CPPv3NV6RP20404i2c035get_IC_COMP_VERSION_IC_COMP_VERSIONEv"></span><span id="_CPPv2NV6RP20404i2c035get_IC_COMP_VERSION_IC_COMP_VERSIONEv"></span><span id="RP2040::i2c0::get_IC_COMP_VERSION_IC_COMP_VERSIONV"></span><span class="target" id="structRP2040_1_1i2c0_1ad073f01035f94b6642187afff4455d71"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_COMP_VERSION_IC_COMP_VERSION</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c035get_IC_COMP_VERSION_IC_COMP_VERSIONEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_COMP_VERSION’s IC_COMP_VERSION field. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NV6RP20404i2c029get_IC_COMP_TYPE_IC_COMP_TYPEEv">
<span id="_CPPv3NV6RP20404i2c029get_IC_COMP_TYPE_IC_COMP_TYPEEv"></span><span id="_CPPv2NV6RP20404i2c029get_IC_COMP_TYPE_IC_COMP_TYPEEv"></span><span id="RP2040::i2c0::get_IC_COMP_TYPE_IC_COMP_TYPEV"></span><span class="target" id="structRP2040_1_1i2c0_1a480408127461d8daf3c8a8df967c437e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_IC_COMP_TYPE_IC_COMP_TYPE</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">volatile</span></span><a class="headerlink" href="#_CPPv4NV6RP20404i2c029get_IC_COMP_TYPE_IC_COMP_TYPEEv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get IC_COMP_TYPE’s IC_COMP_TYPE field.</p>
<p>Designware Component Type number = 0x44_57_01_40. This assigned unique hex value is constant and is derived from the two ASCII letters ‘DW’ followed by a 16-bit unsigned number. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c06IC_CONE">
<span id="_CPPv3N6RP20404i2c06IC_CONE"></span><span id="_CPPv2N6RP20404i2c06IC_CONE"></span><span id="RP2040::i2c0::IC_CON__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1a0ed2ae7d061dc8bec4d7ef3a2f174cde"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_CON</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c06IC_CONE" title="Permalink to this definition">#</a><br /></dt>
<dd><p><p>(read-write) I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</p>
<p>Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are read only.</p>
</p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c06IC_TARE">
<span id="_CPPv3N6RP20404i2c06IC_TARE"></span><span id="_CPPv2N6RP20404i2c06IC_TARE"></span><span id="RP2040::i2c0::IC_TAR__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1a65f062f4968b6348b89da8a4d6cceea2"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_TAR</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c06IC_TARE" title="Permalink to this definition">#</a><br /></dt>
<dd><p><p>(read-write) I2C Target Address Register</p>
<p>This register is 12 bits wide, and bits 31:12 are reserved. This register can be written to only when IC_ENABLE[0] is set to 0.</p>

 Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any write to this register if DW_apb_i2c is enabled as an I2C slave only. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c06IC_SARE">
<span id="_CPPv3N6RP20404i2c06IC_SARE"></span><span id="_CPPv2N6RP20404i2c06IC_SARE"></span><span id="RP2040::i2c0::IC_SAR__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1a507cdc822b5c8f3ab93a90bd95d7aa51"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_SAR</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c06IC_SARE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-write) I2C Slave Address Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c017reserved_padding0E">
<span id="_CPPv3N6RP20404i2c017reserved_padding0E"></span><span id="_CPPv2N6RP20404i2c017reserved_padding0E"></span><span id="RP2040::i2c0::reserved_padding0__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1aeabc47b3f37739e039c8adb0d6ef2a8c"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">reserved_padding0</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c017reserved_padding0E" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c011IC_DATA_CMDE">
<span id="_CPPv3N6RP20404i2c011IC_DATA_CMDE"></span><span id="_CPPv2N6RP20404i2c011IC_DATA_CMDE"></span><span id="RP2040::i2c0::IC_DATA_CMD__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1a845c936c97a89d24af71568a6f24869e"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_DATA_CMD</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c011IC_DATA_CMDE" title="Permalink to this definition">#</a><br /></dt>
<dd><p><p>(read-write) I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO.</p>
<p>The size of the register changes as follows:</p>

 Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read:<ul class="simple">
<li><p>12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a read command should be written for every byte that is to be received; otherwise the DW_apb_i2c will stop acknowledging. </p></li>
</ul>
</p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c014IC_SS_SCL_HCNTE">
<span id="_CPPv3N6RP20404i2c014IC_SS_SCL_HCNTE"></span><span id="_CPPv2N6RP20404i2c014IC_SS_SCL_HCNTE"></span><span id="RP2040::i2c0::IC_SS_SCL_HCNT__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1aedf025c1cd62ffd1b2c3d6a2270e7fea"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_SS_SCL_HCNT</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c014IC_SS_SCL_HCNTE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-write) Standard Speed I2C Clock SCL High Count Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c014IC_SS_SCL_LCNTE">
<span id="_CPPv3N6RP20404i2c014IC_SS_SCL_LCNTE"></span><span id="_CPPv2N6RP20404i2c014IC_SS_SCL_LCNTE"></span><span id="RP2040::i2c0::IC_SS_SCL_LCNT__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1a07619618784331508697d2b1a4c238af"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_SS_SCL_LCNT</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c014IC_SS_SCL_LCNTE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-write) Standard Speed I2C Clock SCL Low Count Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c014IC_FS_SCL_HCNTE">
<span id="_CPPv3N6RP20404i2c014IC_FS_SCL_HCNTE"></span><span id="_CPPv2N6RP20404i2c014IC_FS_SCL_HCNTE"></span><span id="RP2040::i2c0::IC_FS_SCL_HCNT__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1a90fb6ebbe53fc008ea5ebc9cdbd4c989"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_FS_SCL_HCNT</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c014IC_FS_SCL_HCNTE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-write) Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c014IC_FS_SCL_LCNTE">
<span id="_CPPv3N6RP20404i2c014IC_FS_SCL_LCNTE"></span><span id="_CPPv2N6RP20404i2c014IC_FS_SCL_LCNTE"></span><span id="RP2040::i2c0::IC_FS_SCL_LCNT__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1ae0722cf6f92d6ca83dd8bcb1eafac532"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_FS_SCL_LCNT</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c014IC_FS_SCL_LCNTE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-write) Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c017reserved_padding1E">
<span id="_CPPv3N6RP20404i2c017reserved_padding1E"></span><span id="_CPPv2N6RP20404i2c017reserved_padding1E"></span><span id="RP2040::i2c0::reserved_padding1__uint32_tCA"></span><span class="target" id="structRP2040_1_1i2c0_1a3bea3b528de61711b01b3777b6d7d6bf"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">reserved_padding1</span></span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4N6RP20404i2c024reserved_padding1_lengthE" title="RP2040::i2c0::reserved_padding1_length"><span class="n"><span class="pre">reserved_padding1_length</span></span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c017reserved_padding1E" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c012IC_INTR_STATE">
<span id="_CPPv3N6RP20404i2c012IC_INTR_STATE"></span><span id="_CPPv2N6RP20404i2c012IC_INTR_STATE"></span><span id="RP2040::i2c0::IC_INTR_STAT__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1a6c38bb5cf3b3b6b0ff4c5c2b0b0ac5bf"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_INTR_STAT</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c012IC_INTR_STATE" title="Permalink to this definition">#</a><br /></dt>
<dd><p><p>(read-only) I2C Interrupt Status Register</p>
<p>Each bit in this register has a corresponding mask bit in the IC_INTR_MASK register. These bits are cleared by reading the matching interrupt clear register. The unmasked raw versions of these bits are available in the IC_RAW_INTR_STAT register.</p>
</p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c012IC_INTR_MASKE">
<span id="_CPPv3N6RP20404i2c012IC_INTR_MASKE"></span><span id="_CPPv2N6RP20404i2c012IC_INTR_MASKE"></span><span id="RP2040::i2c0::IC_INTR_MASK__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1a40a3b62ca6fc1ed3e2e769bd4c19707c"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_INTR_MASK</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c012IC_INTR_MASKE" title="Permalink to this definition">#</a><br /></dt>
<dd><p><p>(read-write) I2C Interrupt Mask Register.</p>
<p>These bits mask their corresponding interrupt status bits. This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt.</p>
</p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c016IC_RAW_INTR_STATE">
<span id="_CPPv3N6RP20404i2c016IC_RAW_INTR_STATE"></span><span id="_CPPv2N6RP20404i2c016IC_RAW_INTR_STATE"></span><span id="RP2040::i2c0::IC_RAW_INTR_STAT__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1a213a36dcb8b7c6ce0e07288e78572d2b"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_RAW_INTR_STAT</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c016IC_RAW_INTR_STATE" title="Permalink to this definition">#</a><br /></dt>
<dd><p><p>(read-only) I2C Raw Interrupt Status Register</p>
<p>Unlike the IC_INTR_STAT register, these bits are not masked so they always show the true status of the DW_apb_i2c.</p>
</p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c08IC_RX_TLE">
<span id="_CPPv3N6RP20404i2c08IC_RX_TLE"></span><span id="_CPPv2N6RP20404i2c08IC_RX_TLE"></span><span id="RP2040::i2c0::IC_RX_TL__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1aa619d4480210ab2038e0ccb0f6f7e066"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_RX_TL</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c08IC_RX_TLE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-write) I2C Receive FIFO Threshold Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c08IC_TX_TLE">
<span id="_CPPv3N6RP20404i2c08IC_TX_TLE"></span><span id="_CPPv2N6RP20404i2c08IC_TX_TLE"></span><span id="RP2040::i2c0::IC_TX_TL__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1afedbf995cc99dd08426a8ec4ae5fbd4e"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_TX_TL</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c08IC_TX_TLE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-write) I2C Transmit FIFO Threshold Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c011IC_CLR_INTRE">
<span id="_CPPv3N6RP20404i2c011IC_CLR_INTRE"></span><span id="_CPPv2N6RP20404i2c011IC_CLR_INTRE"></span><span id="RP2040::i2c0::IC_CLR_INTR__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1ae786ae8112376c77cf936f7fce574f03"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_CLR_INTR</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c011IC_CLR_INTRE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-only) Clear Combined and Individual Interrupt Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c015IC_CLR_RX_UNDERE">
<span id="_CPPv3N6RP20404i2c015IC_CLR_RX_UNDERE"></span><span id="_CPPv2N6RP20404i2c015IC_CLR_RX_UNDERE"></span><span id="RP2040::i2c0::IC_CLR_RX_UNDER__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1a05b791ebc5985282f14b0a6510ad6485"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_CLR_RX_UNDER</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c015IC_CLR_RX_UNDERE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-only) Clear RX_UNDER Interrupt Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c014IC_CLR_RX_OVERE">
<span id="_CPPv3N6RP20404i2c014IC_CLR_RX_OVERE"></span><span id="_CPPv2N6RP20404i2c014IC_CLR_RX_OVERE"></span><span id="RP2040::i2c0::IC_CLR_RX_OVER__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1a4f8ba2c439aac11f82c83d084e462f14"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_CLR_RX_OVER</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c014IC_CLR_RX_OVERE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-only) Clear RX_OVER Interrupt Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c014IC_CLR_TX_OVERE">
<span id="_CPPv3N6RP20404i2c014IC_CLR_TX_OVERE"></span><span id="_CPPv2N6RP20404i2c014IC_CLR_TX_OVERE"></span><span id="RP2040::i2c0::IC_CLR_TX_OVER__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1a47fb426572d5bfc0394404429393d42f"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_CLR_TX_OVER</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c014IC_CLR_TX_OVERE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-only) Clear TX_OVER Interrupt Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c013IC_CLR_RD_REQE">
<span id="_CPPv3N6RP20404i2c013IC_CLR_RD_REQE"></span><span id="_CPPv2N6RP20404i2c013IC_CLR_RD_REQE"></span><span id="RP2040::i2c0::IC_CLR_RD_REQ__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1ae27dbc8bf0321222dc96134bd1228767"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_CLR_RD_REQ</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c013IC_CLR_RD_REQE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-only) Clear RD_REQ Interrupt Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c014IC_CLR_TX_ABRTE">
<span id="_CPPv3N6RP20404i2c014IC_CLR_TX_ABRTE"></span><span id="_CPPv2N6RP20404i2c014IC_CLR_TX_ABRTE"></span><span id="RP2040::i2c0::IC_CLR_TX_ABRT__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1a888244b2f7a408ebba305e2e9c5eff76"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_CLR_TX_ABRT</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c014IC_CLR_TX_ABRTE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-only) Clear TX_ABRT Interrupt Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c014IC_CLR_RX_DONEE">
<span id="_CPPv3N6RP20404i2c014IC_CLR_RX_DONEE"></span><span id="_CPPv2N6RP20404i2c014IC_CLR_RX_DONEE"></span><span id="RP2040::i2c0::IC_CLR_RX_DONE__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1a090c918fa350d4056c860ab8849de704"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_CLR_RX_DONE</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c014IC_CLR_RX_DONEE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-only) Clear RX_DONE Interrupt Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c015IC_CLR_ACTIVITYE">
<span id="_CPPv3N6RP20404i2c015IC_CLR_ACTIVITYE"></span><span id="_CPPv2N6RP20404i2c015IC_CLR_ACTIVITYE"></span><span id="RP2040::i2c0::IC_CLR_ACTIVITY__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1af70ae34e7060a2984e6bfc8bf73ac5ec"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_CLR_ACTIVITY</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c015IC_CLR_ACTIVITYE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-only) Clear ACTIVITY Interrupt Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c015IC_CLR_STOP_DETE">
<span id="_CPPv3N6RP20404i2c015IC_CLR_STOP_DETE"></span><span id="_CPPv2N6RP20404i2c015IC_CLR_STOP_DETE"></span><span id="RP2040::i2c0::IC_CLR_STOP_DET__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1a0debc5de4bef1c5bf66e0afac682b455"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_CLR_STOP_DET</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c015IC_CLR_STOP_DETE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-only) Clear STOP_DET Interrupt Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c016IC_CLR_START_DETE">
<span id="_CPPv3N6RP20404i2c016IC_CLR_START_DETE"></span><span id="_CPPv2N6RP20404i2c016IC_CLR_START_DETE"></span><span id="RP2040::i2c0::IC_CLR_START_DET__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1a712114d5ae99ec6526e8393ba4b44b3c"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_CLR_START_DET</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c016IC_CLR_START_DETE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-only) Clear START_DET Interrupt Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c015IC_CLR_GEN_CALLE">
<span id="_CPPv3N6RP20404i2c015IC_CLR_GEN_CALLE"></span><span id="_CPPv2N6RP20404i2c015IC_CLR_GEN_CALLE"></span><span id="RP2040::i2c0::IC_CLR_GEN_CALL__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1ac3c45d54601d16d4f9583ace4a8fa05b"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_CLR_GEN_CALL</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c015IC_CLR_GEN_CALLE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-only) Clear GEN_CALL Interrupt Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c09IC_ENABLEE">
<span id="_CPPv3N6RP20404i2c09IC_ENABLEE"></span><span id="_CPPv2N6RP20404i2c09IC_ENABLEE"></span><span id="RP2040::i2c0::IC_ENABLE__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1a9830f4b28c85fdae64060150735cf2e6"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_ENABLE</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c09IC_ENABLEE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-write) I2C Enable Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c09IC_STATUSE">
<span id="_CPPv3N6RP20404i2c09IC_STATUSE"></span><span id="_CPPv2N6RP20404i2c09IC_STATUSE"></span><span id="RP2040::i2c0::IC_STATUS__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1a30345339ae3e92f49f0482143e3f6be1"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_STATUS</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c09IC_STATUSE" title="Permalink to this definition">#</a><br /></dt>
<dd><p><p>(read-only) I2C Status Register</p>
<p>This is a read-only register used to indicate the current transfer status and FIFO status. The status register may be read at any time. None of the bits in this register request an interrupt.</p>

 When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state machines goes to idle and ic_en=0:<ul class="simple">
<li><p>Bits 5 and 6 are set to 0 </p></li>
</ul>
</p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c08IC_TXFLRE">
<span id="_CPPv3N6RP20404i2c08IC_TXFLRE"></span><span id="_CPPv2N6RP20404i2c08IC_TXFLRE"></span><span id="RP2040::i2c0::IC_TXFLR__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1ac8158530c8821a170ab4fb36fef0bcb4"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_TXFLR</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c08IC_TXFLRE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-only) I2C Transmit FIFO Level Register This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is disabled - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c08IC_RXFLRE">
<span id="_CPPv3N6RP20404i2c08IC_RXFLRE"></span><span id="_CPPv2N6RP20404i2c08IC_RXFLRE"></span><span id="RP2040::i2c0::IC_RXFLR__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1a2bb8fc7eb91e7f80e117ad7b26853b38"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_RXFLR</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c08IC_RXFLRE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-only) I2C Receive FIFO Level Register This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever: - The I2C is disabled - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c011IC_SDA_HOLDE">
<span id="_CPPv3N6RP20404i2c011IC_SDA_HOLDE"></span><span id="_CPPv2N6RP20404i2c011IC_SDA_HOLDE"></span><span id="RP2040::i2c0::IC_SDA_HOLD__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1ad85b729fa0e8de530afadbff167328ad"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_SDA_HOLD</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c011IC_SDA_HOLDE" title="Permalink to this definition">#</a><br /></dt>
<dd><p><p>(read-write) I2C SDA Hold Time Length Register</p>
<p>The bits [15:0] of this register are used to control the hold time of SDA during transmit in both slave and master mode (after SCL goes from HIGH to LOW).</p>
<p>The bits [23:16] of this register are used to extend the SDA transition (if any) whenever SCL is HIGH in the receiver in either master or slave mode.</p>
<p>Writes to this register succeed only when IC_ENABLE[0]=0.</p>
<p>The values in this register are in units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode (one cycle in master mode, seven cycles in slave mode) for the value to be implemented.</p>
<p>The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part of scl. Therefore the programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl period measured in ic_clk cycles.</p>
</p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c017IC_TX_ABRT_SOURCEE">
<span id="_CPPv3N6RP20404i2c017IC_TX_ABRT_SOURCEE"></span><span id="_CPPv2N6RP20404i2c017IC_TX_ABRT_SOURCEE"></span><span id="RP2040::i2c0::IC_TX_ABRT_SOURCE__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1a376b0365484f0736a531ddc811e6b13f"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_TX_ABRT_SOURCE</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c017IC_TX_ABRT_SOURCEE" title="Permalink to this definition">#</a><br /></dt>
<dd><p><p>(read-only) I2C Transmit Abort Source Register</p>
<p>This register has 32 bits that indicate the source of the TX_ABRT bit. Except for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the IC_CLR_INTR register is read. To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]).</p>

 Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, Bit 9 clears for one cycle and is then re-asserted. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c021IC_SLV_DATA_NACK_ONLYE">
<span id="_CPPv3N6RP20404i2c021IC_SLV_DATA_NACK_ONLYE"></span><span id="_CPPv2N6RP20404i2c021IC_SLV_DATA_NACK_ONLYE"></span><span id="RP2040::i2c0::IC_SLV_DATA_NACK_ONLY__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1acdf728e625e1980249c4482b395ebbf1"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_SLV_DATA_NACK_ONLY</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c021IC_SLV_DATA_NACK_ONLYE" title="Permalink to this definition">#</a><br /></dt>
<dd><p><p>(read-write) Generate Slave Data NACK Register</p>
<p>The register is used to generate a NACK for the data part of a transfer when DW_apb_i2c is acting as a slave-receiver. This register only exists when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this parameter disabled, this register does not exist and writing to the register’s address has no effect.</p>

 A write can occur on this register if both of the following conditions are met: - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) - Slave part is inactive (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register read-back location for the internal slv_activity signal; the user should poll this before writing the ic_slv_data_nack_only bit. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c09IC_DMA_CRE">
<span id="_CPPv3N6RP20404i2c09IC_DMA_CRE"></span><span id="_CPPv2N6RP20404i2c09IC_DMA_CRE"></span><span id="RP2040::i2c0::IC_DMA_CR__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1a935d5ced6d7b84dff8ac8581eac79ab8"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_DMA_CR</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c09IC_DMA_CRE" title="Permalink to this definition">#</a><br /></dt>
<dd><p><p>(read-write) DMA Control Register</p>
<p>The register is used to enable the DMA Controller interface operation. There is a separate bit for transmit and receive. This can be programmed regardless of the state of IC_ENABLE.</p>
</p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c011IC_DMA_TDLRE">
<span id="_CPPv3N6RP20404i2c011IC_DMA_TDLRE"></span><span id="_CPPv2N6RP20404i2c011IC_DMA_TDLRE"></span><span id="RP2040::i2c0::IC_DMA_TDLR__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1a33ccb9cb8632996d95ce143678770b42"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_DMA_TDLR</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c011IC_DMA_TDLRE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-write) DMA Transmit Data Level Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c011IC_DMA_RDLRE">
<span id="_CPPv3N6RP20404i2c011IC_DMA_RDLRE"></span><span id="_CPPv2N6RP20404i2c011IC_DMA_RDLRE"></span><span id="RP2040::i2c0::IC_DMA_RDLR__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1a91077f6d77d82d7145dbc317dcd79005"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_DMA_RDLR</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c011IC_DMA_RDLRE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-write) I2C Receive Data Level Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c012IC_SDA_SETUPE">
<span id="_CPPv3N6RP20404i2c012IC_SDA_SETUPE"></span><span id="_CPPv2N6RP20404i2c012IC_SDA_SETUPE"></span><span id="RP2040::i2c0::IC_SDA_SETUP__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1a57a5e4b1c7a8b1d16040a23b1a0f1e2c"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_SDA_SETUP</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c012IC_SDA_SETUPE" title="Permalink to this definition">#</a><br /></dt>
<dd><p><p>(read-write) I2C SDA Setup Register</p>
<p>This register controls the amount of time delay (in terms of number of ic_clk clock periods) introduced in the rising edge of SCL - relative to SDA changing</p>
<ul class="simple">
<li><p><p>when DW_apb_i2c services a read request in a slave-transmitter operation. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.</p>
<p>Writes to this register succeed only when IC_ENABLE[0] = 0.</p>

 Note: The length of setup time is calculated using [(IC_SDA_SETUP - 1) * (ic_clk_period)], so if the user requires 10 ic_clk periods of setup time, they should program a value of 11. The IC_SDA_SETUP register is only used by the DW_apb_i2c when operating as a slave transmitter. </p></li>
</ul>
</p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c019IC_ACK_GENERAL_CALLE">
<span id="_CPPv3N6RP20404i2c019IC_ACK_GENERAL_CALLE"></span><span id="_CPPv2N6RP20404i2c019IC_ACK_GENERAL_CALLE"></span><span id="RP2040::i2c0::IC_ACK_GENERAL_CALL__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1a88ee48ca4b42bd8b8450104730a9f841"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_ACK_GENERAL_CALL</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c019IC_ACK_GENERAL_CALLE" title="Permalink to this definition">#</a><br /></dt>
<dd><p><p>(read-write) I2C ACK General Call Register</p>
<p>The register controls whether DW_apb_i2c responds with a ACK or NACK when it receives an I2C General Call address.</p>

 This register is applicable only when the DW_apb_i2c is in slave mode. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c016IC_ENABLE_STATUSE">
<span id="_CPPv3N6RP20404i2c016IC_ENABLE_STATUSE"></span><span id="_CPPv2N6RP20404i2c016IC_ENABLE_STATUSE"></span><span id="RP2040::i2c0::IC_ENABLE_STATUS__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1a60afe2cd4017ef8555f26366122ca85a"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_ENABLE_STATUS</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c016IC_ENABLE_STATUSE" title="Permalink to this definition">#</a><br /></dt>
<dd><p><p>(read-only) I2C Enable Status Register</p>
<p>The register is used to report the DW_apb_i2c hardware status when the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is disabled.</p>
<p>If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced to 1.</p>
<p>If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is read as ‘0’.</p>

 Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read as 0 because disabling the DW_apb_i2c depends on I2C bus activities. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c012IC_FS_SPKLENE">
<span id="_CPPv3N6RP20404i2c012IC_FS_SPKLENE"></span><span id="_CPPv2N6RP20404i2c012IC_FS_SPKLENE"></span><span id="RP2040::i2c0::IC_FS_SPKLEN__uint32_t"></span><span class="target" id="structRP2040_1_1i2c0_1a1669c5ffd1bd856b16d94b56d3d73013"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_FS_SPKLEN</span></span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c012IC_FS_SPKLENE" title="Permalink to this definition">#</a><br /></dt>
<dd><p><p>(read-write) I2C SS, FS or FM+ spike suppression limit</p>
<p>This register is used to store the duration, measured in ic_clk cycles, of the longest spike that is filtered out by the spike suppression logic when the component is operating in SS, FS or FM+ modes. The relevant I2C requirement is tSP (table 4) as detailed in the I2C Bus Specification. This register must be programmed with a minimum value of 1.</p>
</p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c017reserved_padding2E">
<span id="_CPPv3N6RP20404i2c017reserved_padding2E"></span><span id="_CPPv2N6RP20404i2c017reserved_padding2E"></span><span id="RP2040::i2c0::reserved_padding2__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1aa4af6f232a791aaf3072f3752ba09a23"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">reserved_padding2</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c017reserved_padding2E" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c018IC_CLR_RESTART_DETE">
<span id="_CPPv3N6RP20404i2c018IC_CLR_RESTART_DETE"></span><span id="_CPPv2N6RP20404i2c018IC_CLR_RESTART_DETE"></span><span id="RP2040::i2c0::IC_CLR_RESTART_DET__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1a3f33e6f7f87c9ac16dc4d4839e3c4975"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_CLR_RESTART_DET</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c018IC_CLR_RESTART_DETE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-only) Clear RESTART_DET Interrupt Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c017reserved_padding3E">
<span id="_CPPv3N6RP20404i2c017reserved_padding3E"></span><span id="_CPPv2N6RP20404i2c017reserved_padding3E"></span><span id="RP2040::i2c0::reserved_padding3__uint32_tCA"></span><span class="target" id="structRP2040_1_1i2c0_1a561430f75db05838752c3c120687199d"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">reserved_padding3</span></span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4N6RP20404i2c024reserved_padding3_lengthE" title="RP2040::i2c0::reserved_padding3_length"><span class="n"><span class="pre">reserved_padding3_length</span></span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c017reserved_padding3E" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c015IC_COMP_PARAM_1E">
<span id="_CPPv3N6RP20404i2c015IC_COMP_PARAM_1E"></span><span id="_CPPv2N6RP20404i2c015IC_COMP_PARAM_1E"></span><span id="RP2040::i2c0::IC_COMP_PARAM_1__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1a0f9fac4ade06cfa726885fde63bbe4d6"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_COMP_PARAM_1</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c015IC_COMP_PARAM_1E" title="Permalink to this definition">#</a><br /></dt>
<dd><p><p>(read-only) Component Parameter Register 1</p>
<p>Note This register is not implemented and therefore reads as 0. If it was implemented it would be a constant read-only register that contains encoded information about the component’s parameter settings. Fields shown below are the settings for those parameters</p>
</p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c015IC_COMP_VERSIONE">
<span id="_CPPv3N6RP20404i2c015IC_COMP_VERSIONE"></span><span id="_CPPv2N6RP20404i2c015IC_COMP_VERSIONE"></span><span id="RP2040::i2c0::IC_COMP_VERSION__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1a42886301ea95492a363395a98e079c22"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_COMP_VERSION</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c015IC_COMP_VERSIONE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-only) I2C Component Version Register </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c012IC_COMP_TYPEE">
<span id="_CPPv3N6RP20404i2c012IC_COMP_TYPEE"></span><span id="_CPPv2N6RP20404i2c012IC_COMP_TYPEE"></span><span id="RP2040::i2c0::IC_COMP_TYPE__uint32_tC"></span><span class="target" id="structRP2040_1_1i2c0_1ac29a609bc2fed76bed0999881e17f13b"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IC_COMP_TYPE</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c012IC_COMP_TYPEE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>(read-only) I2C Component Type Register </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-static-attributes">Public Static Attributes</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c04sizeE">
<span id="_CPPv3N6RP20404i2c04sizeE"></span><span id="_CPPv2N6RP20404i2c04sizeE"></span><span id="RP2040::i2c0::size__std::s"></span><span class="target" id="structRP2040_1_1i2c0_1a8c3b485e17c7f7378535b79049cde0de"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">constexpr</span></span><span class="w"> </span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">size</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">256</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c04sizeE" title="Permalink to this definition">#</a><br /></dt>
<dd><p><a class="reference internal" href="#structRP2040_1_1i2c0"><span class="std std-ref">i2c0</span></a>’s size in bytes. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c024reserved_padding1_lengthE">
<span id="_CPPv3N6RP20404i2c024reserved_padding1_lengthE"></span><span id="_CPPv2N6RP20404i2c024reserved_padding1_lengthE"></span><span id="RP2040::i2c0::reserved_padding1_length__std::s"></span><span class="target" id="structRP2040_1_1i2c0_1ac87f7e83b520bea4d59a4c9a9289b04b"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">constexpr</span></span><span class="w"> </span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">reserved_padding1_length</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">2</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c024reserved_padding1_lengthE" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N6RP20404i2c024reserved_padding3_lengthE">
<span id="_CPPv3N6RP20404i2c024reserved_padding3_lengthE"></span><span id="_CPPv2N6RP20404i2c024reserved_padding3_lengthE"></span><span id="RP2040::i2c0::reserved_padding3_length__std::s"></span><span class="target" id="structRP2040_1_1i2c0_1a0bcbb4a9a4a8678e3878da01d81c0561"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">constexpr</span></span><span class="w"> </span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">reserved_padding3_length</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">18</span></span><a class="headerlink" href="#_CPPv4N6RP20404i2c024reserved_padding3_lengthE" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</section>
</section>


                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="structRP2040_1_1dma.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Struct dma</p>
      </div>
    </a>
    <a class="right-next"
       href="structRP2040_1_1io__bank0.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Struct io_bank0</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#struct-documentation">Struct Documentation</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Vaughn Kottler
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2023, Vaughn Kottler.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>